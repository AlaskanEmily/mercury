%-----------------------------------------------------------------------------%
% Copyright (C) 2003 University of Melbourne.
% This file may only be copied under the terms of the GNU Library General
% Public License - see the file COPYING.LIB in the Mercury distribution.
%-----------------------------------------------------------------------------%
% File: aditi_private_builtin.m
% Author: stayl
%
% Internals of the Mercury->Aditi interface.
%
% This module is automatically imported when `--aditi' is passed to
% the compiler.
%
% Calls to some of these predicates are generated by the compiler,
% and some are called from aditi.m.
%
% None of these predicates should appear in user programs.
%
%-----------------------------------------------------------------------------%
:- module aditi_private_builtin.

:- interface.

:- import_module io.
:- import_module aditi.

:- type aditi_private_builtin__relation.

:- pred connect(string, string, string, int, aditi__connection,
		io__state, io__state).
:- mode connect(in, in, in, out, out, di, uo) is det.

:- pred disconnect(aditi__connection, int, io__state, io__state).
:- mode disconnect(in, out, di, uo) is det.

:- pred start_transaction(aditi__connection, aditi__result(aditi__state),
		io__state, io__state).
:- mode start_transaction(in, out, di, uo) is det.

:- pred commit_transaction(aditi__state, io__state, io__state).
:- mode commit_transaction(in, di, uo) is det.

:- pred abort_transaction(aditi__state, io__state, io__state).
:- mode abort_transaction(in, di, uo) is det.

	% do_call_returning_relation(ProcName, InputSchema, InputTuple,
	%		OutputRel).
	%
	% Call an Aditi procedure, returning a reference to the output
	% relation. InputTuple is a tuple containing the
	% input arguments. InputSchema is an Aditi schema string
	% describing the tuple of input arguments.
:- impure pred do_call_returning_relation(aditi__state, string, string,
		T, relation).
:- mode do_call_returning_relation(aditi_mui, in, in, in, out) is det.

	% Find the single solution for a deterministic database call.
	% Abort the transaction if the call does not succeed at
	% least once.
	% InputTuple and OutputTuple must have type '{}/N' (the arity
	% depends on the relation being called).
:- impure pred do_det_call(aditi__state, string, string,
		InputTuple, OutputTuple).
:- mode do_det_call(aditi_mui, in, in, in, out) is det.

:- impure pred do_semidet_call(aditi__state, string, string,
		InputTuple, OutputTuple).
:- mode do_semidet_call(aditi_mui, in, in, in, out) is semidet.

:- impure pred do_nondet_call(aditi__state, string, string,
		InputTuple, OutputTuple).
:- mode do_nondet_call(aditi_mui, in, in, in, out) is nondet.

:- impure pred do_multi_call(aditi__state, string, string,
		InputTuple, OutputTuple).
:- mode do_multi_call(aditi_mui, in, in, in, out) is multi.

	% XXX I'm not sure whether it makes sense to have
	% committed choice Aditi predicates.
:- impure pred do_cc_nondet_call(aditi__state, string, string,
		InputTuple, OutputTuple).
:- mode do_cc_nondet_call(aditi_mui, in, in, in, out) is cc_nondet.

:- impure pred do_cc_multi_call(aditi__state, string, string,
		InputTuple, OutputTuple).
:- mode do_cc_multi_call(aditi_mui, in, in, in, out) is cc_multi.

:- impure pred do_erroneous_call(aditi__state, string, string,
		InputTuple, OutputTuple).
:- mode do_erroneous_call(aditi_mui, in, in, in, out) is erroneous.

:- impure pred do_failure_call(aditi__state, string, string,
		InputTuple, OutputTuple).
:- mode do_failure_call(aditi_mui, in, in, in, out) is failure.

	% do_insert_tuple(BaseRelationName, Tuple).
	%
	% TypeInfos is an array containing the type-infos for
	% the tuple to insert. TupleArgs contains the attribute
	% values of the tuple to insert.
:- pred do_insert_tuple(string, InputTuple, aditi__state, aditi__state).
:- mode do_insert_tuple(in, in, aditi_di, aditi_uo) is det.

	% do_delete_tuple(BaseRelationName, DeleteProcName,
	%	DeleteProcInputSchema, Tuple).
:- pred do_delete_tuple(string, string, string, Tuple,
		aditi__state, aditi__state).
:- mode do_delete_tuple(in, in, in, in, aditi_di, aditi_uo) is det.

:- type update_closure == pred(aditi__state, relation).
:- inst update_closure == (pred(aditi_ui, out) is det).

	% do_bulk_insert(BaseRelationName, UpdateProcName, Closure).
:- pred do_bulk_insert(string, string, update_closure,
		aditi__state, aditi__state).
:- mode do_bulk_insert(in, in, in(update_closure), aditi_di, aditi_uo) is det.

	% do_bulk_delete(BaseRelationName, UpdateProcName, Closure).
:- pred do_bulk_delete(string, string, update_closure,
		aditi__state, aditi__state).
:- mode do_bulk_delete(in, in, in(update_closure), aditi_di, aditi_uo) is det.

	% do_bulk_modify(BaseRelationName, UpdateProcName, Closure).
:- pred do_bulk_modify(string, string, update_closure,
		aditi__state, aditi__state).
:- mode do_bulk_modify(in, in, in(update_closure), aditi_di, aditi_uo) is det.

	% Try to classify an error code returned by Aditi.
:- pred error_code(int, aditi__error, string).
:- mode error_code(in, out, out) is det.

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%
:- implementation.

:- import_module bool, char, exception, int, list, require, std_util, string.

:- pragma foreign_type("C", relation, "apiID").

:- type cursor.
:- pragma foreign_type("C", cursor, "MADITI_Output_Info *").

:- pragma foreign_import_module("C", aditi).

:- pragma foreign_decl("C",
"
#include ""mercury_wrapper.h""
#include ""mercury_string.h""
#include ""mercury_reg_workarounds.h""

#include ""v2_api_without_engine.h""
#include ""AditiStatus.h""

#define MADITI_OK ADITI_ENUM(AditiStatus_OK)

	/*
	** MADITI_check can only be used within functions which return
	** an Aditi error code.
	*/
#define MADITI_check(status)						\\
    do {	int MADITI_line_xxx = __LINE__;				\\
		int MADITI_check_status_xxx;				\\
		MADITI_check_status_xxx = status;			\\
		MADITI_do_debug_status(MADITI_check_status_xxx,		\\
			MADITI_line_xxx);				\\
		if (MADITI_check_status_xxx != MADITI_OK) {		\\
			MADITI_status = MADITI_check_status_xxx;	\\
    			return MADITI_check_status_xxx;			\\
		}							\\
    } while(0)

#define MADITI_debug_status(status)					\\
    do {	int MADITI_line_xxx_2 = __LINE__;			\\
		int MADITI_check_status_xxx_2;				\\
		MADITI_check_status_xxx_2 = status;			\\
	    	MADITI_do_debug_status(MADITI_check_status_xxx_2,	\\
			MADITI_line_xxx_2);				\\
    } while(0)

#define MADITI_do_debug_status(status, line)				\\
    do {	int MADITI_do_debug_status_xxx;				\\
		MADITI_do_debug_status_xxx = status;			\\
		if (MADITI_do_debug_status_xxx != MADITI_OK) {		\\
			MR_DEBUG(fprintf(stderr, ""\\naditi_private_builtin.m:%d: API call failed, returned %d\\n"", \\
			line, MADITI_do_debug_status_xxx));		\\
	}								\\
    } while(0)

typedef enum { MADITI_INSERT_TUPLE, MADITI_DELETE_TUPLE } MADITI_Insert_Delete;
typedef enum { MADITI_INSERT, MADITI_DELETE, MADITI_MODIFY } MADITI_Bulk_Op;

/*
** Information used to clean up a call result if there is a commit
** or an exception across a database call.
*/
typedef struct {
	MADITI_State	state;
	apiID		relation;
	apiID		cursor;
	bool		cleaned_up;
} MADITI_Output_Info;

static apiID MADITI_session;		/* Current connection ticket. */
static int MADITI_status;		/* Return code of the last
					** Aditi API call.
					*/

static int MADITI_run_procedure(MADITI_State *DB, MR_String proc_name,
		MR_String input_schema, MR_String input_tuple,
		apiID *output_relation);
static int MADITI_create_cursor(MADITI_State *DB, apiID relation,
		MADITI_Output_Info **output_info_ptr);
static int MADITI_do_insert_delete_tuple(MADITI_State *DB,
		MADITI_Insert_Delete operation,
		MR_String relation_name, MR_String update_proc,
		MR_String update_schema, MR_String tuple);
static int MADITI_do_bulk_operation(MADITI_State *DB, MADITI_Bulk_Op operation,
		MR_String relation_name, MR_String update_proc,
		apiID closure_result);
static int MADITI_cleanup_call_output(MADITI_Output_Info *);

#ifdef MR_USE_TRAIL
static void MADITI_trail_cleanup_call_output(void *cleanup_data,
		MR_untrail_reason reason);
#endif

static int MADITI_list_rel(MADITI_State DB, apiID rel);
").

:- pragma c_code("

	/*
	** No effort is made to ensure that MR_hp is valid where
	** memory is allocated. Given that it is likely that a better
	** way of allocating memory from C code is will be implemented
	** when the accurate garbage collector is finished, I don't
	** see much point in cluttering the code here with
	** save_transient_registers()/restore_transient_registers() calls.
	*/
#ifndef CONSERVATIVE_GC
#error ""The Aditi interface requires conservative garbage collection. \\
                Use a compilation grade containing .gc.""
#endif
").

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

	%
	% Code to handle connections.
	%
:- pragma foreign_proc("C",
	connect(_XXXHost::in, User::in, Passwd::in,
		Stat::out, Connection::out, IO0::di, IO::uo),
	[will_not_call_mercury, promise_pure, tabled_for_io],
"
{
    apiID transport_id;
    char *challenge = NULL;
    MR_Box boxed_connection;
    MR_Box boxed_bytecode_transaction;

    Stat = ADITI_FUNC(api_init)((apiString) ""D"", 0,
    		NULL, NULL, &transport_id);
    if (Stat == MADITI_OK) {
        /*
        ** Log in.
        ** XXX handle extra authentication using
        ** ADITI_FUNC(session_authenticate)
        */
        Stat = ADITI_FUNC(session_create)(User, Passwd, 0,
                &(Connection.connection), &challenge);
        if (Stat == MADITI_OK) {

            MR_DEBUG(fprintf(stderr, ""connected\\n""));

            /*
            ** Create a transaction which will run as long as the connection.
            ** The bytecode will be stored in this transaction.
            */
            Stat = ADITI_FUNC(transaction_begin)(Connection.connection,
                                    &(Connection.bytecode_transaction));
            if (Stat == MADITI_OK) {
                /*
                ** Upload all the RL code for the program to 
                ** the database.
                */

                /* XXX The new API doesn't provide any way to do this */
                /* MR_DEBUG(ADITI_FUNC(set_debug)()); */

                MR_DEBUG(fprintf(stderr, ""logged in\\n""));

                /*
                ** The casts to `void *' are to avoid the Mercury runtime
                ** depending on Aditi headers.
                */
		MR_MAYBE_BOX_FOREIGN_TYPE(apiID, Connection.connection,
			boxed_connection);
		MR_MAYBE_BOX_FOREIGN_TYPE(apiID,
			Connection.bytecode_transaction,
			boxed_bytecode_transaction);
                Stat = MR_load_aditi_rl_code(boxed_connection,
                        boxed_bytecode_transaction);
                if (Stat == MADITI_OK) {
                    MR_DEBUG(fprintf(stderr, ""code loaded\\n""));
                } else {
                    ADITI_FUNC(transaction_abort)(Connection.connection,
                            Connection.bytecode_transaction);
                    ADITI_FUNC(session_disconnect)(Connection.connection);
                    ADITI_FUNC(api_close)();
                }
            } else {
                ADITI_FUNC(session_disconnect)(Connection.connection);
                ADITI_FUNC(api_close)();
            }
        } else {
            ADITI_FUNC(api_close)();
        }
    }
    MADITI_debug_status(Stat);
    IO = IO0;
}
").

:- pragma foreign_proc("C",
	disconnect(Connection::in, Stat::out, IO0::di, IO::uo),
	[will_not_call_mercury, promise_pure, tabled_for_io],
"{
	ADITI_TYPE(AditiStatus) status;
        Stat = ADITI_FUNC(transaction_abort)(Connection.connection,
                Connection.bytecode_transaction);
        status = ADITI_FUNC(session_disconnect)(Connection.connection);
	if (Stat == MADITI_OK) {
		Stat = status;
	}
        status = ADITI_FUNC(api_close)();
	if (Stat == MADITI_OK) {
		Stat = status;
	}
        MADITI_debug_status(Stat);
        IO = IO0;
}").

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

	%
	% This section handles starting, committing and aborting transactions.
	%

start_transaction(Connection, Result) -->
	start_transaction_2(Connection, Status, DB),
	{ Status = 0 ->
		Result = ok(DB)
	;
		error_code(Status, Error, String),
		Result = error(Error, String)
	}.

:- pred start_transaction_2(aditi__connection, int,
		aditi__state, io__state, io__state).
:- mode start_transaction_2(in, out, out, di, uo) is det.

:- pragma foreign_proc("C",
	start_transaction_2(Connection::in, Stat::out,
		DB::out, IO0::di, IO::uo),
	[will_not_call_mercury, promise_pure, tabled_for_io],
"{
	IO = IO0;
	MR_DEBUG(fprintf(stderr, ""starting transaction...""));
	DB.connection = Connection.connection;
	DB.bytecode_transaction = Connection.bytecode_transaction;
	Stat = ADITI_FUNC(transaction_begin)(Connection.connection,
		&(DB.transaction));
	MADITI_debug_status(Stat);
	MADITI_status = Stat;
	MR_DEBUG(fprintf(stderr, ""done\\n""));
}").

:- pragma foreign_proc("C",
	abort_transaction(DB::in, IO0::di, IO::uo),
	[will_not_call_mercury, promise_pure, tabled_for_io],
"{
	/*
	** Ignore the return code -- we're more interested
	** in the error which caused the abort.
	*/
	ADITI_FUNC(transaction_abort)(DB.connection, DB.transaction);
	IO = IO0;
}").

:- pragma promise_pure(commit_transaction/3).
commit_transaction(DB) -->
	{ semipure check_for_old_error },
	commit_transaction_2(DB, Status),
	{ semipure maybe_throw_aditi_exception(Status) }.

:- pred commit_transaction_2(aditi__state, int, io__state, io__state).
:- mode commit_transaction_2(in, out, di, uo) is det.

:- pragma c_code(commit_transaction_2(DB::in, Stat::out, IO0::di, IO::uo),
		will_not_call_mercury,
"{
	Stat = ADITI_FUNC(transaction_commit)(DB.connection, DB.transaction);
	MADITI_debug_status(Stat);
	IO = IO0;
}").

	% Throw an exception to abort the transaction if the status
	% is not MADITI_OK.
	% This needs to be impure to stop it being reordered with
	% other calls.
:- semipure pred maybe_throw_aditi_exception(int).
:- mode maybe_throw_aditi_exception(in) is det.

maybe_throw_aditi_exception(Status) :-
	semipure get_aditi_status(_),
	( Status = 0 ->
		true
	;
		error_code(Status, Error, String),
		throw(aditi__exception(Error, String))
	).	

:- pred maybe_throw_aditi_exception(int, aditi__state, aditi__state).
:- mode maybe_throw_aditi_exception(in, aditi_di, aditi_uo) is det.
:- pragma promise_pure(maybe_throw_aditi_exception/3).

maybe_throw_aditi_exception(Status) -->
	{ semipure maybe_throw_aditi_exception(Status) }.

	% If a call result is cleaned up by untrailing, any errors
	% will not result in the transaction being aborted immediately
	% because there is no way to throw an exception from a trail
	% function. Instead, a global variable is set to indicate that
	% an error has occurred, and the next database call will
	% check for the error and abort the transaction.
	% This needs to be semipure to stop it being reordered with
	% other calls.
:- semipure pred check_for_old_error is det.

check_for_old_error :-
	semipure get_aditi_status(Status),
	semipure maybe_throw_aditi_exception(Status).

:- pred check_for_old_error(aditi__state, aditi__state).
:- mode check_for_old_error(aditi_di, aditi_uo) is det.
:- pragma promise_pure(check_for_old_error/2).

check_for_old_error -->
	{ semipure check_for_old_error }.

:- semipure pred get_aditi_status(int).
:- mode get_aditi_status(out) is det.

:- pragma c_code(get_aditi_status(Stat::out), will_not_call_mercury,
		"Stat = MADITI_status;").

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

	%
	% This section handles calls to Aditi predicates and functions.
	%

do_det_call(DB, ProcName, InputSchema, InputTuple, OutputTuple) :-
	impure do_call_returning_relation(DB, ProcName, 
		InputSchema, InputTuple, OutputRel),
	impure create_cursor(DB, OutputRel, CursorStatus, Cursor0),
	semipure maybe_throw_aditi_exception(CursorStatus),
	( get_next_tuple(OutputTuple0, Cursor0, Cursor) ->
		OutputTuple = OutputTuple0,
		impure destroy_cursor(DB, Cursor, DestroyStatus),
		semipure maybe_throw_aditi_exception(DestroyStatus)
	;
		impure destroy_cursor(DB, Cursor0, DestroyStatus),
		semipure maybe_throw_aditi_exception(DestroyStatus),
		determinism_error("no solution", "det", ProcName)
	).

do_semidet_call(DB, ProcName, InputSchema, InputTuple, OutputTuple) :-
	impure do_call_returning_relation(DB, ProcName,
		InputSchema, InputTuple, OutputRel),
	impure create_cursor(DB, OutputRel, CursorStatus, Cursor0),
	semipure maybe_throw_aditi_exception(CursorStatus),
	( get_next_tuple(OutputTuple0, Cursor0, Cursor) ->
		%
		% Assume that if a call succeeds multiple times,
		% the other solutions are just duplicates.
		%
		OutputTuple = OutputTuple0,
		impure destroy_cursor(DB, Cursor, DestroyStatus),
		semipure maybe_throw_aditi_exception(DestroyStatus)
	;
		impure destroy_cursor(DB, Cursor0, DestroyStatus),
		semipure maybe_throw_aditi_exception(DestroyStatus),
		fail
	).

do_nondet_call(DB, ProcName, InputSchema, InputTuple, OutputTuple) :-
	impure do_call_returning_relation(DB, ProcName, InputSchema,
		InputTuple, OutputRel),
	impure create_cursor(DB, OutputRel, CursorStatus, Cursor),
	semipure maybe_throw_aditi_exception(CursorStatus),
	impure collect_nondet_output_tuples(DB, Cursor, OutputTuple).

do_multi_call(DB, ProcName, InputSchema, InputTuple, OutputTuple) :-
	(
		impure do_nondet_call(DB, ProcName, InputSchema,
			InputTuple, OutputTuple0)
	->
		OutputTuple = OutputTuple0
	;
		determinism_error("no solution", "multi", ProcName)
	).

do_cc_nondet_call(DB, ProcName, InputSchema, InputTuple, OutputTuple) :-
	impure do_nondet_call(DB, ProcName, InputSchema,
		InputTuple, OutputTuple).

do_cc_multi_call(DB, ProcName, InputSchema, InputTuple, OutputTuple) :-
	impure do_multi_call(DB, ProcName, InputSchema,
		InputTuple, OutputTuple).

do_erroneous_call(DB, ProcName, InputSchema, InputTuple, OutputTuple) :-
	impure do_det_call(DB, ProcName, InputSchema, InputTuple, OutputTuple),
	determinism_error("solution", "erroneous", ProcName).

do_failure_call(DB, ProcName, InputSchema, InputTuple, OutputTuple) :-
	(
		impure do_semidet_call(DB, ProcName, InputSchema,
			InputTuple, OutputTuple0)
	->
		OutputTuple = OutputTuple0,
		determinism_error("solution", "failure", ProcName)
	;
		fail
	).

:- pred determinism_error(string, string, string).
:- mode determinism_error(in, in, in) is erroneous.

determinism_error(Solution, Det, ProcName) :-	
	string__format(
		"Error in Aditi call: %s for procedure with determinism %s\n",
		[s(Solution), s(Det), s(ProcName)], Msg),
	throw(aditi__exception(determinism_error, Msg)).

:- impure pred collect_nondet_output_tuples(aditi__state, cursor, T).
:- mode collect_nondet_output_tuples(in, in, out) is nondet.

collect_nondet_output_tuples(DB, Cursor0, OutputTuple) :-
	semipure check_for_old_error,
	(
		get_next_tuple(OutputTuple0, Cursor0, Cursor)
	->
		(
			OutputTuple = OutputTuple0
		;
			impure collect_nondet_output_tuples(DB, Cursor,
				OutputTuple)
		)
	;
		impure destroy_cursor(DB, Cursor0, DestroyStatus),
		semipure maybe_throw_aditi_exception(DestroyStatus),
		fail
	).

% XXX Work around GCC register bug.
:- pragma no_inline(do_call_returning_relation/5).

do_call_returning_relation(DB, ProcName, InputSchema, InputTuple, OutputRel) :-
	construct_input_tuple(InputTuple, InputTupleStr),
	impure do_call_returning_relation_2(DB, ProcName, InputSchema,
		InputTupleStr, Status, OutputRel),
	semipure maybe_throw_aditi_exception(Status).

:- impure pred do_call_returning_relation_2(aditi__state, string, string,
		string, int, relation).
:- mode do_call_returning_relation_2(aditi_mui, in, in, in, out, out) is det.

:- pragma foreign_proc("C",
	do_call_returning_relation_2(DB::aditi_mui, ProcName::in,
		InputSchema::in, InputTuple::in, Stat::out, OutputRel::out),
	[will_not_call_mercury],
"{
	Stat = MADITI_run_procedure(&DB, ProcName, InputSchema,
			InputTuple, &OutputRel);
}").

	% Create a cursor, adding an entry to the trail if possible
	% to make sure that it is cleaned up.
:- impure pred create_cursor(aditi__state, relation, int, cursor).
:- mode create_cursor(aditi_mui, in, out, out) is det.

:- pragma foreign_proc("C",
	create_cursor(DB::aditi_mui, Relation::in, Stat::out, Cursor::out),
	[will_not_call_mercury],
"{
	Stat = MADITI_create_cursor(&DB, Relation, &Cursor);
}").

:- impure pred destroy_cursor(aditi__state, cursor, int).
:- mode destroy_cursor(aditi_mui, in, out) is det.

:- pragma foreign_proc("C",
	destroy_cursor(_DB::aditi_mui, Cursor::in, Stat::out),
	[will_not_call_mercury],
"
	Stat = MADITI_cleanup_call_output(Cursor);
").

:- pred get_next_tuple(T, cursor, cursor).
:- mode get_next_tuple(out, in, out) is semidet.

get_next_tuple(OutputTuple, Cursor0, Cursor) :-
	cursor_next(TupleStr, Cursor0, Cursor),
	ArgTypeDescs = type_args(type_of(OutputTuple)),
	Posn0 = posn(1, 0, 0),
	string__length(TupleStr, TupleLength),
	parse_output_tuple(ArgTypeDescs, TupleStr, TupleLength, Posn0,
		OutputArgUnivs),
	OutputTuple0 = univ_value(construct_tuple(OutputArgUnivs)),
	OutputTuple = cast(OutputTuple0).

	% The arguments of the output tuple were constructed using
	% the argument types passed in -- we don't need to check
	% that they match again.
:- func cast(T) = U.
:- pragma c_code(cast(T::in) = (U::out), will_not_call_mercury, "U = T;").

:- pred cursor_next(string, cursor, cursor).
:- mode cursor_next(out, in, out) is semidet.

:- pragma foreign_proc("C",
	cursor_next(Tuple::out, Cursor0::in, Cursor::out),
	[will_not_call_mercury, promise_pure],
"{
	int rc;
	char *tuple_str;
#ifdef MR_INT_LEAST64_TYPE
	MR_uint_least64_t file_page_slot;
#else
	#error ""The Aditi interface needs a 64 bit integer type""
#endif

	Cursor = Cursor0;
	rc = ADITI_FUNC(cursor_get_next)((Cursor->state).connection,
		(Cursor->state).transaction, Cursor->relation,
		Cursor->cursor, &file_page_slot);
	MADITI_debug_status(rc);

	/*
	** XXX This check should be more specific, but there is no
	** Aditi return code for no more tuples. 
	*/
	if (rc == MADITI_OK) {
		rc = ADITI_FUNC(cursor_get_current)((Cursor->state).connection,
			(Cursor->state).transaction, Cursor->relation,
			Cursor->cursor, &tuple_str);
		MADITI_debug_status(rc);
		if (rc == MADITI_OK) {
			MR_DEBUG(fprintf(stderr,
				""received tuple: %s\\n"", tuple_str));
			MR_make_aligned_string_copy(Tuple, tuple_str);
			free(tuple_str);
			SUCCESS_INDICATOR = TRUE;
		} else {
			SUCCESS_INDICATOR = FALSE;
		}
	} else {
		SUCCESS_INDICATOR = FALSE;
	}
}").

:- pred parse_output_tuple(list(type_desc), string, int,
		io__posn, list(univ)).
:- mode parse_output_tuple(in, in, in, in, out) is det.

parse_output_tuple([], _, _, _, []).
parse_output_tuple([TypeDesc | TypeDescs], Tuple, TupleLength, Posn0,
		[Arg | Args]) :-
	has_read_result_type(Result, TypeDesc),
	io__read_from_string_with_int_instead_of_char("Aditi result tuple",
		Tuple, TupleLength, Result, Posn0, Posn),
	(
		Result = ok(Field),
		Arg = univ(Field)
	;
		Result = eof,
		string__format("Aditi: unexpected end of tuple: %s",
			[s(Tuple)], ErrorMsg),
		throw(aditi__exception(parse_error_in_tuple, ErrorMsg))
	;
		Result = error(Msg, _),
		string__format("Aditi: invalid tuple returned: %s",
			[s(Msg)], ErrorMsg),
		throw(aditi__exception(parse_error_in_tuple, ErrorMsg))
	),
	parse_output_tuple(TypeDescs, Tuple, TupleLength, Posn, Args).

	% Use existential types to set up the type of the output argument
	% using the type-info passed for the output tuple. 
:- some [T] pred has_read_result_type(io__read_result(T), type_desc).
:- mode has_read_result_type(unused, in) is det.

has_read_result_type(Result, TypeDesc) :-
	has_type(Var, TypeDesc), 
	read_result_type(Var, Result).

:- pred read_result_type(T, io__read_result(T)).
:- mode read_result_type(unused, unused) is det.

read_result_type(_, _).

:- pragma foreign_decl("C",
"
/* 
** Given an RL procedure name, the schema of the input relation and a tuple
** to insert into the input relation, run the procedure, returning a ticket
** for the output relation.
*/
static int
MADITI_run_procedure(MADITI_State *DB, MR_String proc_name,
	MR_String input_schema, MR_String input_tuple, apiID *output_relation)
{
	apiID input_relation;

	/*
	** Create a temporary relation to hold the input tuple.
	*/
	MR_DEBUG(fprintf(stderr, ""creating input temporary (schema %s)..."",
		input_schema));
	MADITI_check(ADITI_FUNC(relation_create)(DB->connection,
		DB->transaction, input_schema,
		(apiString) """", /* unnamed */
		0, /* temporary relation */
		&input_relation));
	MR_DEBUG(fprintf(stderr, ""done\\n""));

	/*
	** Insert the input tuple into the relation.
	*/
	MR_DEBUG(fprintf(stderr, ""adding input tuple...%s"", input_tuple));
	MADITI_check(ADITI_FUNC(relation_tuple_add)(DB->connection,
		DB->transaction, input_relation, input_tuple,
		0 /* !use_internal_save_point */));
	MR_DEBUG(fprintf(stderr, ""done\\n""));

	/*
	** Run the procedure.
	*/
	MR_DEBUG(fprintf(stderr, ""running procedure... ""));
	MADITI_check(ADITI_FUNC(procedure_run)(DB->connection, DB->transaction,
		proc_name, input_relation, DB->bytecode_transaction,
		1 /* output is used */,
		output_relation));
	MR_DEBUG(fprintf(stderr, ""done\\n""));

	/*
	** Drop the input relation.
	*/
	MR_DEBUG(fprintf(stderr, ""dropping input temporary...""));
	MADITI_check(ADITI_FUNC(relation_destroy)(DB->connection,
		DB->transaction, input_relation));
	MR_DEBUG(fprintf(stderr, ""done\\n""));

	MR_DEBUG(fprintf(stderr, ""output tuples\\n""));
	MR_DEBUG(MADITI_check(MADITI_list_rel(DB, *output_relation)));
	MR_DEBUG(fprintf(stderr, ""\\n\\n""));
	
	return MADITI_OK;
}

static int
MADITI_create_cursor(MADITI_State *DB, apiID relation,
		MADITI_Output_Info **output_info_ptr)
{
	apiID cursor;
	MADITI_Output_Info *output_info;

	/* create cursor on the output relation */
	MR_DEBUG(fprintf(stderr, ""opening output cursor...""));
	MADITI_check(ADITI_FUNC(cursor_create)(DB->connection,
		DB->transaction, relation,
		(apiString) """" /* no index */,
		&cursor));
	MADITI_check(ADITI_FUNC(cursor_open)(DB->connection,
		DB->transaction, relation, cursor,
		0 /* forwards */,
		(apiString) """", 0, (apiString) """", 0 /* not used */));
	MR_DEBUG(fprintf(stderr, ""done\\n""));

	output_info = MR_GC_NEW(MADITI_Output_Info);
	MR_assign_structure(output_info->state, DB);
	output_info->relation = relation;
	output_info->cursor = cursor;
	output_info->cleaned_up = FALSE;
#ifdef MR_USE_TRAIL
	MR_trail_function(MADITI_trail_cleanup_call_output,
		(void *) output_info);
#endif
	*output_info_ptr = output_info;
	return MADITI_OK;
}

static int
MADITI_list_rel(MADITI_State DB, apiID relation)
{
	size_t len;
	apiID cursor;
	char *tuple_str;
	int rc;
#ifdef MR_INT_LEAST64_TYPE
	MR_uint_least64_t file_page_slot;
#else
	#error ""The Aditi interface needs a 64 bit integer type""
#endif


	MADITI_check(ADITI_FUNC(cursor_create)(DB.connection,
		DB.transaction, relation,
		(apiString) """" /* no index */,
		&cursor));
	MADITI_check(ADITI_FUNC(cursor_open)(DB.connection,
		DB.transaction, relation, cursor,
		0 /* forwards */,
		(apiString) """", 0, (apiString) """", 0 /* not used */));

	len = 0;
	fflush(stdout);

	/*
	** XXX This check should be more specific, but there is no
	** Aditi return code for no more tuples. 
	*/
	while (ADITI_FUNC(cursor_get_next)(DB.connection, DB.transaction,
			relation, cursor, &file_page_slot) == MADITI_OK)
	{
		rc = ADITI_FUNC(cursor_get_current)(DB.connection,
			DB.transaction, relation, cursor, &tuple_str);
		if (rc == MADITI_OK) {
			fprintf(stderr, ""tuple: %s\\n"", tuple_str);
			free(tuple_str);
			len = 0;
			tuple_str = NULL;
		}
	}

	MADITI_check(ADITI_FUNC(cursor_close)(DB.connection,
		DB.transaction, relation, cursor));
	MADITI_check(ADITI_FUNC(cursor_destroy)(DB.connection,
		DB.transaction, relation, cursor));
	return MADITI_OK;
}

/*---------------------------------------------------------------------------*/

/*
** Free all resources used by a database call.
*/

#ifdef MR_USE_TRAIL
static void
MADITI_trail_cleanup_call_output(void *data, MR_untrail_reason reason)
{
    switch (reason) {
	case MR_commit:
	case MR_exception:
	case MR_retry:
	    /*
	    ** Clean up the output relation. If the transaction
	    ** status is not MADITI_OK, the transaction is about
	    ** to be aborted, so it's best not to try to clean up.
	    ** The database will do any cleaning up that is required.
	    */
	    if (MADITI_status == MADITI_OK) {
		MR_DEBUG(fprintf(stderr, 
		    ""MADITI_trail_cleanup_call_output: cleaning up %d\\n"",
		    reason));
		/*
		** We shouldn't throw exceptions during an untrail operation,
		** so we just set the status so that the next Aditi operation
		** called will abort the transaction if there were any errors.
		*/
		MADITI_status = MADITI_cleanup_call_output(
			(MADITI_Output_Info *)data);
	    }
	    break;
	case MR_solve:
	case MR_undo:
	    /*
	    ** Undo on backtracking will be handled by
	    ** do_*_call, so that the  cleanup will happen
	    ** even if trailing is not being used.
	    */
	    break;

	case MR_gc:
	default:
	    MR_fatal_error(""MADITI_trail_cleanup_call_output"");
    }
}
#endif /* MR_USE_TRAIL */

static int 
MADITI_cleanup_call_output(MADITI_Output_Info *output_info)
{
	if (output_info->cleaned_up) {

		/*
		** This can happen if there is a commit followed
		** by an exception -- the commit will not reset
		** the trail.
		*/
		MR_DEBUG(fprintf(stderr, 
			""MADITI_cleanup_call_output: already cleaned up\\n""
		));

	} else {

		MR_DEBUG(fprintf(stderr, 
			""MADITI_cleanup_call_output: cleaning up\\n""
		));

		/* close cursor */
		MR_DEBUG(fprintf(stderr, ""closing cursor\\n""));
		MADITI_check(
			ADITI_FUNC(cursor_close)(
				(output_info->state).connection,
				(output_info->state).transaction,
				output_info->relation,
				output_info->cursor)
		);

		/* destroy cursor */
		MR_DEBUG(fprintf(stderr, ""destroying cursor\\n""));
		MADITI_check(
			ADITI_FUNC(cursor_destroy)(
				(output_info->state).connection,
				(output_info->state).transaction,
				output_info->relation,
				output_info->cursor)
		);

		/* close output temporary */
		MR_DEBUG(fprintf(stderr,
			""closing output temporary relation\\n""));
		MADITI_check(ADITI_FUNC(relation_close)(
			(output_info->state).connection,
			(output_info->state).transaction,
			output_info->relation));

		/* Make sure we don't do this again. */
		output_info->cleaned_up = TRUE;
	}

	return MADITI_OK;
}
").

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

	%
	% This section handles updates.
	%

do_insert_tuple(RelationName, Args) -->
	% There are no compiler-generated procedures for inserting
	% a single tuple into a relation.
	{ UpdateProc = "" },
	{ UpdateSchema = "" },

	do_insert_delete_tuple(insert_tuple, RelationName,
		UpdateProc, UpdateSchema, Args).

do_delete_tuple(RelationName, DeleteProc, DeleteProcInputSchema, Args) -->
	do_insert_delete_tuple(delete_tuple, RelationName,
		DeleteProc, DeleteProcInputSchema, Args).

:- pred do_insert_delete_tuple(int, string, string, string,
		T, aditi__state, aditi__state).
:- mode do_insert_delete_tuple(in, in, in, in, in, aditi_di, aditi_uo) is det.

do_insert_delete_tuple(InsertDelete, RelationName,
		UpdateProc, UpdateSchema, Args) -->
	check_for_old_error,
	{ construct_input_tuple(Args, Tuple) },
	do_insert_delete_tuple_2(InsertDelete, RelationName,
		UpdateProc, UpdateSchema, Tuple, Status),
	maybe_throw_aditi_exception(Status).

:- pred do_insert_delete_tuple_2(int, string, string, string, string, int,
		aditi__state, aditi__state).
:- mode do_insert_delete_tuple_2(in, in, in, in, in, out,
		aditi_di, aditi_uo) is det.

:- pragma foreign_proc("C",
	do_insert_delete_tuple_2(InsertDelete::in, RelationName::in,
		UpdateProc::in, UpdateSchema::in, Tuple::in, Stat::out,
		DB0::aditi_di, DB::aditi_uo),
	[will_not_call_mercury, promise_pure],
"{
	MR_assign_structure(DB, DB0);
	Stat = MADITI_do_insert_delete_tuple(&DB,
			(MADITI_Insert_Delete) InsertDelete,
			RelationName, UpdateProc, UpdateSchema, Tuple);
}").

:- func insert_tuple = int.
:- pragma foreign_proc("C",
	insert_tuple = (InsertTuple::out),
	[will_not_call_mercury, promise_pure, thread_safe],
"{
	InsertTuple = MADITI_INSERT_TUPLE;
}").

:- func delete_tuple = int.
:- pragma foreign_proc("C",
	delete_tuple = (DeleteTuple::out),
	[will_not_call_mercury, promise_pure, thread_safe],
"{
	DeleteTuple = MADITI_DELETE_TUPLE;
}").

do_bulk_insert(RelationName, InsertProcName, Closure) -->
	do_bulk_operation(bulk_insert, RelationName, InsertProcName, Closure).

do_bulk_delete(RelationName, DeleteProcName, Closure) -->
	do_bulk_operation(bulk_delete, RelationName, DeleteProcName, Closure).
	
do_bulk_modify(RelationName, ModifyProcName, Closure) -->
	do_bulk_operation(bulk_delete, RelationName, ModifyProcName, Closure).

:- pred do_bulk_operation(int, string, string, update_closure,
		aditi__state, aditi__state).
:- mode do_bulk_operation(in, in, in, in(update_closure),
		aditi_di, aditi_uo) is det.

do_bulk_operation(Op, RelationName, UpdateProc, Closure) -->
	check_for_old_error,
	=(DB),
	{ Closure(DB, ResultRelation) },
	do_bulk_operation_2(Op, RelationName, UpdateProc,
		ResultRelation, Status),
	maybe_throw_aditi_exception(Status).

:- pred do_bulk_operation_2(int, string, string, relation, int,
		aditi__state, aditi__state).
:- mode do_bulk_operation_2(in, in, in, in, out,
		aditi_di, aditi_uo) is det.

:- pragma c_code(do_bulk_operation_2(Op::in, RelationName::in, UpdateProc::in,
		ResultRelation::in, Stat::out, DB0::aditi_di, DB::aditi_uo),
		will_not_call_mercury,
"{
	MR_assign_structure(DB, DB0);
	Stat = MADITI_do_bulk_operation(&DB, (MADITI_Bulk_Op) Op,
			RelationName, UpdateProc, ResultRelation);
}").			

:- func bulk_insert = int.
:- pragma foreign_proc("C",
	bulk_insert = (Insert::out),
	[will_not_call_mercury, promise_pure, thread_safe],
"{
	Insert = MADITI_INSERT;
}").

:- func bulk_delete = int.
:- pragma foreign_proc("C",
	bulk_delete = (Delete::out),
	[will_not_call_mercury, promise_pure, thread_safe],
"{
	Delete = MADITI_DELETE;
}").

:- func bulk_modify = int.
:- pragma foreign_proc("C",
	bulk_modify = (Modify::out),
	[will_not_call_mercury, promise_pure, thread_safe],
"{
	Modify = MADITI_MODIFY;
}").

%-----------------------------------------------------------------------------%

:- pragma foreign_code("C",
"
static int
MADITI_do_insert_delete_tuple(MADITI_State *DB, MADITI_Insert_Delete operation,
		MR_String relation_name, MR_String update_proc,
		MR_String update_schema, MR_String tuple)
{
	apiID delete_output_rel;
	apiID relation;

	switch (operation) {
		case MADITI_INSERT_TUPLE:
			MR_DEBUG(fprintf(stderr, 
				""inserting tuple %s into relation %s\\n"",
				tuple, relation_name));
			MADITI_check(ADITI_FUNC(relation_open)(DB->connection,
				DB->transaction, relation_name, &relation));
			MADITI_check(ADITI_FUNC(relation_tuple_add)(
				DB->connection, DB->transaction,
				relation, tuple,
				0 /* !use_internal_save_point */));
			MADITI_check(ADITI_FUNC(relation_close)(DB->connection,
				DB->transaction, relation));
			MR_DEBUG(fprintf(stderr, ""finished insertion\\n""));
			break;

		case MADITI_DELETE_TUPLE:
			MR_DEBUG(fprintf(stderr, 
				""deleting tuple %s from relation %s\\n"",
				tuple , relation_name));
			MADITI_check(MADITI_run_procedure(DB,
				update_proc, update_schema, tuple,
				&delete_output_rel));
			MADITI_check(ADITI_FUNC(relation_close)(DB->connection,
				DB->transaction, delete_output_rel));
			MR_DEBUG(fprintf(stderr, ""finished deletion\\n""));
			break;
	}
	return MADITI_OK;
}

static int
MADITI_do_bulk_operation(MADITI_State *DB, MADITI_Bulk_Op operation,
		MR_String relation_name, MR_String update_proc,
		apiID closure_result)
{
	apiID output_relation;

	MR_DEBUG(
	    switch (operation) {
		case MADITI_INSERT:
			fprintf(stderr,
				""aditi_bulk_insert(%s)\\n"", relation_name);	
			break;
		case MADITI_DELETE:
			fprintf(stderr,
				""aditi_bulk_delete(%s)\\n"", relation_name);
			break;
		case MADITI_MODIFY:
			fprintf(stderr,
				""aditi_bulk_delete(%s)\\n"", relation_name);	
			break;
	    }
	)

	/*
	** Call the procedure generated by the compiler to apply the update.
	*/
	MR_DEBUG(fprintf(stderr, ""Calling update procedure %s\\n"",
		update_proc));
	MADITI_check(ADITI_FUNC(procedure_run)(DB->connection,
		DB->transaction, update_proc, closure_result,
		DB->bytecode_transaction,
		0 /* output is not used */,
		&output_relation));

	/*
	** Clean up.
	*/
	MADITI_check(ADITI_FUNC(relation_close)(DB->connection,
		DB->transaction, closure_result));
	return MADITI_OK;
}

").

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%
	%
	% Data conversion.
	%

:- pred construct_input_tuple(T, string).
:- mode construct_input_tuple(in, out) is det.

construct_input_tuple(Tuple, TupleStr) :-
	NumArgs = type_ctor_arity(type_ctor(type_of(Tuple))),
	construct_input_tuple_2(0, NumArgs, Tuple, ["("], RevStrings),

	% XXX deforest this to reduce memory usage.
	list__reverse([")\n" | RevStrings], Strings),
	string__append_list(Strings, TupleStr).

:- pred construct_input_tuple_2(int, int, T, list(string), list(string)).
:- mode construct_input_tuple_2(in, in, in, in, out) is det.

construct_input_tuple_2(Index, NumArgs, Tuple, Strings0, Strings) :-
	( Index < NumArgs ->
		univ_to_string(det_argument(Tuple, Index), String),
		( Index = 0 ->
			Strings1 = [String | Strings0]
		;
			Strings1 = [String, ", " | Strings0]
		),
		construct_input_tuple_2(Index + 1, NumArgs, Tuple,
			Strings1, Strings)
	;
		Strings = Strings0
	).

	% This is very similar to io__write except
	% a) it writes to a string
	% b) everything is written in prefix form.
	% c) arrays, c_pointers, type_infos and univs result in an abort.
:- pred univ_to_string(univ, string).
:- mode univ_to_string(in, out) is det.

univ_to_string(Univ, String) :-
	%
	% we need to special-case the builtin types:
	%	int, char, float, string
	%	type_info, univ, c_pointer, array
	%
	( univ_to_type(Univ, String1) ->
		string__append_list(["\"", String1, "\""], String)
	; univ_to_type(Univ, Char) ->
		char__to_int(Char, CharInt),
		string__int_to_string(CharInt, String)
	; univ_to_type(Univ, Int) ->
		string__int_to_string(Int, String)
	; univ_to_type(Univ, Float) ->
		string__float_to_string(Float, String)
	;
		ordinary_term_to_string(Univ, String)
	).

:- pred ordinary_term_to_string(univ, string).
:- mode ordinary_term_to_string(in, out) is det.

ordinary_term_to_string(Term, String) :-
	deconstruct(univ_value(Term), Functor, _Arity, Args),
	quote_atom(Functor, FunctorStr),
	term_args_to_strings(yes, Args, ["(" | FunctorStr],
		Strings0),
	list__reverse([")" | Strings0], Strings),
	string__append_list(Strings, String).

:- pred term_args_to_strings(bool, list(univ),
		list(string), list(string)).
:- mode term_args_to_strings(in, in, in, out) is det.

term_args_to_strings(_, [], Strings, Strings).
term_args_to_strings(IsFirst, [X | Xs], Strings0, Strings) :-
	univ_to_string(X, XStr),
	( IsFirst = yes ->
		Comma = ""
	;
		Comma = ", "
	),
	term_args_to_strings(no, Xs, [XStr, Comma | Strings0], Strings).

:- pred quote_atom(string::in, list(string)::out) is det.

quote_atom(String0, Quoted) :-
	( string__is_alnum_or_underscore(String0) ->
		Quoted = [String0]
	;
		Quoted = ["'", String0, "'"]
	).

%-----------------------------------------------------------------------------%
	%
	% Attempt to make sense of the Aditi return code.
	% XXX Aditi needs some way to return more descriptive
	% error messages.
	%

error_code(Status, Error, String) :-
	( error_code_2(Status, Error0) ->
		Error = Error0,
		error_message(Status, String)
	;
		Error = general_failure,
		string__format("invalid Aditi error code %i",
			[i(Status)], String)
	).

:- pred error_code_2(int::in, aditi__error::out) is semidet.
	
error_code_2(-1, invalid_passwd).
error_code_2(-2, invalid_passwd).
error_code_2(-3, general_failure).
error_code_2(-4, general_failure).
error_code_2(-5, too_many_connections).
error_code_2(-6, general_failure).
error_code_2(-7, general_failure).
error_code_2(-8, already_logged_in).
error_code_2(-9, not_logged_in).
error_code_2(-10, general_failure).
error_code_2(-11, general_failure).
error_code_2(-12, general_failure).
error_code_2(-13, general_failure).
error_code_2(-14, error_creating_client).
error_code_2(-15, general_failure).
error_code_2(-16, not_implemented).
error_code_2(-17, abort).
error_code_2(-18, general_failure).
error_code_2(-19, general_failure).
error_code_2(-20, general_failure).
error_code_2(-21, bad_value).
error_code_2(-22, not_connected).
error_code_2(-23, bad_rl_code).
error_code_2(-24, bad_rl_code).
error_code_2(-25, bad_rl_code).
error_code_2(-26, error_opening_relation).
error_code_2(-27, bad_rl_code).
error_code_2(-28, bad_rl_code).
error_code_2(-29, security_violation).
error_code_2(-30, bad_rl_code).
error_code_2(-31, bad_rl_code).
error_code_2(-32, bad_rl_code).
error_code_2(-33, unique_key_violation).
error_code_2(-34, relation_or_cursor_not_open).
error_code_2(-35, general_failure).
error_code_2(-36, bad_value).
error_code_2(-37, timeout).

:- pred error_message(int::in, string::out) is det.

:- pragma c_code(error_message(Stat::in, Msg::out),
		will_not_call_mercury,
"
	MR_make_aligned_string_copy(Msg,
		ADITI_FUNC(AditiError_as_string)(
			(ADITI_TYPE(AditiStatus)) Stat));
").


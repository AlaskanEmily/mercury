%-----------------------------------------------------------------------------%

% Value_number.nl - optimization of straight-line LLDS code.

% Main author: zs.

%-----------------------------------------------------------------------------%

:- module value_number.

:- interface.
:- import_module llds, list.

:- pred value_number__main(list(instruction), list(instruction)).
:- mode value_number__main(in, out) is det.

:- pred value_number__post_main(list(instruction), list(instruction)).
:- mode value_number__post_main(in, out) is det.

% the rest are exported only for vn_util and for debugging.

:- type vn == int.

:- type vnlval		--->	vn_reg(reg)
			;	vn_stackvar(int)
			;	vn_framevar(int)
			;	vn_succip
			;	vn_maxfr
			;	vn_curredoip
			;	vn_hp
			;	vn_sp
			;	vn_field(tag, vn, vn)		% lval
			;	vn_temp(int).

			% these lvals do not have vnlval parallels
			%	lvar(var)

:- type vnrval		--->	vn_origlval(vnlval)
			;	vn_mkword(tag, vn)		% rval
			;	vn_const(rval_const)
			;	vn_create(tag, list(maybe(rval)), int)
			;	vn_unop(unary_op, vn)		% rval
			;	vn_binop(binary_op, vn, vn).	% rval, rval

			% these rvals do not have vnrval parallels
			%	var(var)

:- type vn_src		--->	src_ctrl(int)
			;	src_liveval(vnlval)
			;	src_vn(int).

:- type vn_node		--->	node_shared(vn)
			;	node_lval(vnlval)
			;	node_origlval(vnlval)
			;	node_ctrl(int).

:- type vn_instr	--->	vn_call(code_addr, code_addr, list(liveinfo))
			;	vn_call_closure(bool, code_addr, list(liveinfo))
			;	vn_mkframe(string, int, code_addr)
			;	vn_modframe(code_addr)
			;	vn_label(label)
			;	vn_goto(code_addr)
			;	vn_computed_goto(vn, list(label))
			;	vn_if_val(vn, code_addr)
			;	vn_mark_hp(vnlval)
			;	vn_restore_hp(vn).

:- type livemap == map(label, lvalset).
:- type lvalset == bintree_set(lval).
:- type vnlvalset == bintree_set(vnlval).

:- type ctrlmap		== map(int, vn_instr).
:- type flushmap	== map(int, flushmapentry).
:- type flushmapentry	== map(vnlval, vn).

% XXX map__update/set should be det, should call error if key not already there

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

:- implementation.
:- import_module atsort, vn_util, opt_util, opt_debug, map, bintree_set.
:- import_module int, string, require, std_util.

	% Find straight-line code sequences and optimize them using
	% value numbering.

	% We can't find out what variables are used by C code sequences,
	% so we don't optimize any predicates containing them.

value_number__main(Instrs0, Instrs) :-
	list__reverse(Instrs0, Backinstrs),
	vn__repeat_build_livemap(Backinstrs, Ccode, Livemap),
	(
		Ccode = no,
		vn__opt_non_block(Instrs0, Livemap, Instrs)
	;
		Ccode = yes,
		Instrs = Instrs0
	).

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

	% Build up a map of what lvals are live at each label.
	% This step must be iterated in the presence of backward
	% branches, which at the moment are generated by middle
	% recursion and the construction of closures.

:- pred vn__repeat_build_livemap(list(instruction), bool, livemap).
:- mode vn__repeat_build_livemap(in, out, out) is det.

vn__repeat_build_livemap(Backinstrs, Ccode, Livemap) :-
	map__init(Livemap0),
	vn__repeat_build_livemap_2(Backinstrs, Livemap0, Ccode, Livemap).

:- pred vn__repeat_build_livemap_2(list(instruction), livemap, bool, livemap).
:- mode vn__repeat_build_livemap_2(in, di, out, uo) is det.

vn__repeat_build_livemap_2(Backinstrs, Livemap0, Ccode, Livemap) :-
	bintree_set__init(Livevals0),
	vn__build_livemap(Backinstrs, Livevals0, no, Ccode1,
		Livemap0, Livemap1),
	opt_debug__dump_livemap(Livemap1, L_str),
	opt_debug__write("\n\nLivemap:\n\n"),
	opt_debug__write(L_str),
	( Ccode1 = yes ->
		Ccode = yes,
		Livemap = Livemap1
	; vn__equal_livemaps(Livemap0, Livemap1) ->
		Ccode = no,
		Livemap = Livemap1
	;
		vn__repeat_build_livemap_2(Backinstrs, Livemap1, Ccode, Livemap)
	).

:- pred vn__equal_livemaps(livemap, livemap).
:- mode vn__equal_livemaps(in, in) is semidet.

vn__equal_livemaps(Livemap1, Livemap2) :-
	map__keys(Livemap1, Labels),
	vn__equal_livemaps_keys(Labels, Livemap1, Livemap2).

:- pred vn__equal_livemaps_keys(list(label), livemap, livemap).
:- mode vn__equal_livemaps_keys(in, in, in) is semidet.

vn__equal_livemaps_keys([], _Livemap1, _Livemap2).
vn__equal_livemaps_keys([Label | Labels], Livemap1, Livemap2) :-
	map__lookup(Livemap1, Label, Liveset1),
	map__lookup(Livemap2, Label, Liveset2),
	bintree_set__equal(Liveset1, Liveset2),
	vn__equal_livemaps_keys(Labels, Livemap1, Livemap2).

%-----------------------------------------------------------------------------%

	% Build up a map of what lvals are live at each label.
	% The input instruction sequence is reversed.

:- pred vn__build_livemap(list(instruction), lvalset, bool, bool,
	livemap, livemap).
:- mode vn__build_livemap(in, in, in, out, di, uo) is det.

vn__build_livemap([], _, Ccode, Ccode, Livemap, Livemap).
vn__build_livemap([Instr|Moreinstrs], Livevals0, Ccode0, Ccode,
		Livemap0, Livemap) :-
	Instr = Uinstr - _Comment,
	(
		Uinstr = comment(_),
		Livemap1 = Livemap0,
		Livevals2 = Livevals0,
		Moreinstrs2 = Moreinstrs,
		Ccode1 = Ccode0
	;
		Uinstr = livevals(_),
		error("livevals found in backward scan in vn__build_livemap")
	;
		Uinstr = block(_, _),
		error("block found in backward scan in vn__build_livemap")
	;
		Uinstr = assign(Lval, Rval),

		% Make dead the variable assigned, but make any variables
		% needed to access it live. Make the variables in the assigned
		% expression live as well.
		% The deletion has to be done first. If the assigned-to lval
		% appears on the right hand side as well as the left, then we
		% want make_live to put it back into the liveval set.

		bintree_set__delete(Livevals0, Lval, Livevals1),
		vn__lval_access_rval(Lval, Rvals),
		vn__make_live([Rval | Rvals], Livevals1, Livevals2),
		Livemap1 = Livemap0,
		Moreinstrs2 = Moreinstrs,
		Ccode1 = Ccode0
	;
		Uinstr = call(_, _, _),
		opt_util__skip_comments(Moreinstrs, Moreinstrs1),
		(
			Moreinstrs1 = [Nextinstr | Evenmoreinstrs],
			Nextinstr = Nextuinstr - Nextcomment,
			Nextuinstr = livevals(Livevals1)
		->
			vn__filter_livevals(Livevals1, Livevals2),
			Livemap1 = Livemap0,
			Moreinstrs2 = Evenmoreinstrs,
			Ccode1 = Ccode0
		;
			error("call not preceded by livevals")
		)
	;
		Uinstr = call_closure(_, _, _),
		opt_util__skip_comments(Moreinstrs, Moreinstrs1),
		(
			Moreinstrs1 = [Nextinstr | Evenmoreinstrs],
			Nextinstr = Nextuinstr - Nextcomment,
			Nextuinstr = livevals(Livevals1)
		->
			vn__filter_livevals(Livevals1, Livevals2),
			Livemap1 = Livemap0,
			Moreinstrs2 = Evenmoreinstrs,
			Ccode1 = Ccode0
		;
			error("call_closure not preceded by livevals")
		)
	;
		Uinstr = mkframe(_, _, _),
		Livemap1 = Livemap0,
		Livevals2 = Livevals0,
		Moreinstrs2 = Moreinstrs,
		Ccode1 = Ccode0
	;
		Uinstr = modframe(_),
		Livemap1 = Livemap0,
		Livevals2 = Livevals0,
		Moreinstrs2 = Moreinstrs,
		Ccode1 = Ccode0
	;
		Uinstr = label(Label),
		map__set(Livemap0, Label, Livevals0, Livemap1),
		Livevals2 = Livevals0,
		Moreinstrs2 = Moreinstrs,
		Ccode1 = Ccode0
	;
		Uinstr = goto(CodeAddr),
		opt_util__skip_comments(Moreinstrs, Moreinstrs1),
		opt_util__livevals_addr(CodeAddr, LivevalsNeeded),
		( LivevalsNeeded = yes ->
			(
				Moreinstrs1 = [Nextinstr | Evenmoreinstrs],
				Nextinstr = Nextuinstr - Nextcomment,
				Nextuinstr = livevals(Livevals1)
			->
				vn__filter_livevals(Livevals1, Livevals2),
				Livemap1 = Livemap0,
				Moreinstrs2 = Evenmoreinstrs,
				Ccode1 = Ccode0
			;
				error("tailcall not preceded by livevals")
			)
		; CodeAddr = label(Label) ->
			bintree_set__init(Livevals1),
			vn__insert_label_livevals([Label], Livemap0,
				Livevals1, Livevals2),
			Livemap1 = Livemap0,
			Moreinstrs2 = Moreinstrs,
			Ccode1 = Ccode0
		;
			error("unknown label type in vn__build_livemap")
			% Livevals2 = Livevals0,
			% Livemap1 = Livemap0,
			% Moreinstrs2 = Moreinstrs,
			% Ccode1 = Ccode0
		)
	;
		Uinstr = computed_goto(_, Labels),
		bintree_set__init(Livevals1),
		vn__insert_label_livevals(Labels, Livemap0,
			Livevals1, Livevals2),
		Livemap1 = Livemap0,
		Moreinstrs2 = Moreinstrs,
		Ccode1 = Ccode0
	;
		Uinstr = c_code(_),
		Livemap1 = Livemap0,
		Livevals2 = Livevals0,
		Moreinstrs2 = Moreinstrs,
		Ccode1 = yes
	;
		Uinstr = if_val(Rval, CodeAddr),
		vn__make_live([Rval], Livevals0, Livevals1),
		( CodeAddr = label(Label) ->
			vn__insert_label_livevals([Label], Livemap0,
				Livevals1, Livevals2)
		;	
			Livevals2 = Livevals1
		),
		Livemap1 = Livemap0,
		Moreinstrs2 = Moreinstrs,
		Ccode1 = Ccode0
	;
		Uinstr = incr_hp(Lval, _, Rval),

		% Make dead the variable assigned, but make any variables
		% needed to access it live. Make the variables in the size
		% expression live as well.
		% The use of the size expression occurs after the assignment
		% to lval, but the two should never have any variables in
		% common. This is why doing the deletion first works.

		bintree_set__delete(Livevals0, Lval, Livevals1),
		vn__lval_access_rval(Lval, Rvals),
		vn__make_live([Rval | Rvals], Livevals1, Livevals2),
		Livemap1 = Livemap0,
		Moreinstrs2 = Moreinstrs,
		Ccode1 = Ccode0
	;
		Uinstr = mark_hp(Lval),
		vn__lval_access_rval(Lval, Rvals),
		vn__make_live(Rvals, Livevals0, Livevals2),
		Livemap1 = Livemap0,
		Moreinstrs2 = Moreinstrs,
		Ccode1 = Ccode0
	;
		Uinstr = restore_hp(Rval),
		vn__make_live([Rval], Livevals0, Livevals2),
		Livemap1 = Livemap0,
		Moreinstrs2 = Moreinstrs,
		Ccode1 = Ccode0
	;
		Uinstr = incr_sp(_),
		Livevals2 = Livevals0,
		Livemap1 = Livemap0,
		Moreinstrs2 = Moreinstrs,
		Ccode1 = Ccode0
	;
		Uinstr = decr_sp(_),
		Livevals2 = Livevals0,
		Livemap1 = Livemap0,
		Moreinstrs2 = Moreinstrs,
		Ccode1 = Ccode0
	),
	% opt_debug__dump_instr(Uinstr, Instr_str),
	% opt_debug__write("\nInstr: "),
	% opt_debug__write(Instr_str),
	% opt_debug__dump_livevals(Livevals2, Live_str),
	% opt_debug__write("\nLivevals: "),
	% opt_debug__write(Live_str),
	vn__build_livemap(Moreinstrs2, Livevals2, Ccode1, Ccode,
		Livemap1, Livemap).

%-----------------------------------------------------------------------------%

	% Set all lvals found in this rval to live, with the exception of
	% fields, since they are treated specially (the later stages consider
	% them to be live even if they are not explicitly in the live set).

:- pred vn__make_live(list(rval), lvalset, lvalset).
:- mode vn__make_live(in, di, uo) is det.

vn__make_live([], Livevals, Livevals).
vn__make_live([Rval | Rvals], Livevals0, Livevals) :-
	(
		Rval = lval(Lval),
		( Lval = field(_, Rval1, Rval2) ->
			vn__make_live([Rval1, Rval2], Livevals0, Livevals1)
		;
			bintree_set__insert(Livevals0, Lval, Livevals1)
		)
	;
		Rval = create(_, _, _),
		Livevals1 = Livevals0
	;
		Rval = mkword(_, Rval1),
		vn__make_live([Rval1], Livevals0, Livevals1)
	;
		Rval = const(_),
		Livevals1 = Livevals0
	;
		Rval = unop(_, Rval1),
		vn__make_live([Rval1], Livevals0, Livevals1)
	;
		Rval = binop(_, Rval1, Rval2),
		vn__make_live([Rval1, Rval2], Livevals0, Livevals1)
	;
		Rval = var(_),
		error("var rval should not propagate to value_number")
	),
	vn__make_live(Rvals, Livevals1, Livevals).

%-----------------------------------------------------------------------------%

:- pred vn__filter_livevals(lvalset, lvalset).
:- mode vn__filter_livevals(in, out) is det.

vn__filter_livevals(Livevals0, Livevals) :-
	bintree_set__to_sorted_list(Livevals0, Livelist),
	bintree_set__init(Livevals1),
	vn__insert_proper_livevals(Livelist, Livevals1, Livevals).

:- pred vn__insert_label_livevals(list(label), livemap, lvalset, lvalset).
:- mode vn__insert_label_livevals(in, in, di, uo) is det.

vn__insert_label_livevals([], _, Livevals, Livevals).
vn__insert_label_livevals([Label | Labels], Livemap, Livevals0, Livevals) :-
	( map__search(Livemap, Label, LabelLivevals) ->
		bintree_set__to_sorted_list(LabelLivevals, Livelist),
		vn__insert_proper_livevals(Livelist, Livevals0, Livevals1)
	;
		Livevals1 = Livevals0
	),
	vn__insert_label_livevals(Labels, Livemap, Livevals1, Livevals).

:- pred vn__insert_proper_livevals(list(lval), lvalset, lvalset).
:- mode vn__insert_proper_livevals(in, di, uo) is det.

vn__insert_proper_livevals([], Livevals, Livevals).
vn__insert_proper_livevals([Live | Livelist], Livevals0, Livevals) :-
	vn__insert_proper_liveval(Live, Livevals0, Livevals1),
	vn__insert_proper_livevals(Livelist, Livevals1, Livevals).

	% Make sure that we insert general register and stack references only.

:- pred vn__insert_proper_liveval(lval, lvalset, lvalset).
:- mode vn__insert_proper_liveval(in, di, uo) is det.

vn__insert_proper_liveval(Live, Livevals0, Livevals) :-
	( Live = reg(_) ->
		bintree_set__insert(Livevals0, Live, Livevals)
	; Live = stackvar(_) ->
		bintree_set__insert(Livevals0, Live, Livevals)
	; Live = framevar(_) ->
		bintree_set__insert(Livevals0, Live, Livevals)
	;
		Livevals = Livevals0
	).

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

	% Optimize instructions, assume we are outside of a block.

:- pred vn__opt_non_block(list(instruction), livemap, list(instruction)).
:- mode vn__opt_non_block(in, in, out) is det.

vn__opt_non_block([], _, []).
vn__opt_non_block([Instr0 | Instrs0], Livemap, Instrs) :-
	Instr0 = Uinstr0 - _Comment0,
	(
		Uinstr0 = label(Label)
	->
		map__lookup(Livemap, Label, Livevals),
		vn__init_templocs(5, 5, Livevals, Templocs),
		vn__init_tables(Vn_tables0),
		bintree_set__init(Liveset0),
		map__init(Ctrlmap0),
		map__init(Flushmap0),
		vn__opt_block(Instrs0, Vn_tables0, Livemap, Templocs, Liveset0,
			0, 0, no, Ctrlmap0, Flushmap0, 0, [], NewInstrs),
		Instrs = [Instr0 | NewInstrs]
	;
		Uinstr0 = comment(_)
	->
		vn__opt_non_block(Instrs0, Livemap, Instrs1),
		Instrs = Instrs1
	;
		% we get here only if label elim is switched off
		vn__opt_non_block(Instrs0, Livemap, Instrs1),
		Instrs = [Instr0 | Instrs1]
	).

	% Optimize instructions, assuming we are inside of a block.

:- pred vn__opt_block(list(instruction), vn_tables, livemap, templocs,
	vnlvalset, int, int, bool, ctrlmap, flushmap, int,
	list(instruction), list(instruction)).
:- mode vn__opt_block(in, in, in, in, in, in, in, in, in, in, in, in, out)
	is det.

vn__opt_block([], _, _, _, _, _, _, _, _, _, _, _, []) :-
	error("block has no terminator").
vn__opt_block([Instr0 | Instrs0], Vn_tables, Livemap, Templocs, Livevals,
		Incrsp, Decrsp, Incrhp, Ctrlmap0, Flushmap0, Ctrl0,
		Prev, Instrs) :-
	vn__handle_instr(Instr0, Vn_tables, Livemap, Templocs, Livevals,
		Incrsp, Decrsp, Incrhp, Ctrlmap0, Flushmap0, Ctrl0,
		Prev, Instrs0, Instrs).

%-----------------------------------------------------------------------------%

:- pred vn__handle_instr(instruction, vn_tables, livemap, templocs, vnlvalset,
	int, int, bool, ctrlmap, flushmap, int, list(instruction),
	list(instruction), list(instruction)).
:- mode vn__handle_instr(in, in, in, in, in, in, in, in, in, in, in, in, in,
	out) is det.

vn__handle_instr(Instr0, Vn_tables0, Livemap, Templocs0, Livevals0,
		Incrsp, Decrsp, Incrhp, Ctrlmap0, Flushmap0, Ctrl0, Prev,
		Instrs0, Instrs) :-
	Instr0 = Uinstr0 - _Comment,
	% opt_debug__dump_instr(Uinstr0, I_str),
	% opt_debug__write("\n\nInstr: "),
	% opt_debug__write(I_str),
	% bintree_set__to_sorted_list(Livevals0, Livelist),
	% opt_debug__dump_vnlvals(Livelist, L_str),
	% opt_debug__write("\nLivevals: "),
	% opt_debug__write(L_str),
	(
		Uinstr0 = comment(_),
		vn__opt_block(Instrs0, Vn_tables0, Livemap,
			Templocs0, Livevals0, Incrsp, Decrsp, Incrhp,
			Ctrlmap0, Flushmap0, Ctrl0, [Instr0 | Prev], Instrs)
	;
		Uinstr0 = livevals(Livevals),
		bintree_set__to_sorted_list(Livevals, List),
		vn__convert_to_vnlval_and_insert(List, Livevals0, Livevals1),
		vn__opt_block(Instrs0, Vn_tables0, Livemap,
			Templocs0, Livevals1, Incrsp, Decrsp, Incrhp,
			Ctrlmap0, Flushmap0, Ctrl0, [Instr0 | Prev], Instrs)
	;
		Uinstr0 = block(_, _),
		error("block should not be found in handle_instr")
	;
		Uinstr0 = assign(Lval, Rval),
		vn__rval_to_vn(Rval, Vn, Vn_tables0, Vn_tables1),
		vn__lval_to_vnlval(Lval, Vnlval, Vn_tables1, Vn_tables2),
		vn__set_desired_value(Vnlval, Vn, Vn_tables2, Vn_tables3),
		vn__find_specials(Vnlval, Specials),
		bintree_set__insert_list(Livevals0, Specials, Livevals1),
		vn__opt_block(Instrs0, Vn_tables3, Livemap,
			Templocs0, Livevals1, Incrsp, Decrsp, Incrhp,
			Ctrlmap0, Flushmap0, Ctrl0, [Instr0 | Prev], Instrs)
	;
		Uinstr0 = call(ProcAddr, ReturnAddr, LiveInfo),
		vn__new_ctrl_node(vn_call(ProcAddr, ReturnAddr, LiveInfo),
			Livemap, Vn_tables0, Vn_tables1, Livevals0, Livevals1,
			Ctrlmap0, Ctrlmap1, Flushmap0, Flushmap1, Ctrl0, Ctrl1),
		vn__flush_all_nodes(Livevals1, Templocs0, Vn_tables1,
			Incrsp, Decrsp, Incrhp, Ctrlmap1, Flushmap1, Ctrl1,
			[Instr0 | Prev], FlushInstrs),
		vn__opt_non_block(Instrs0, Livemap, Instrs1),
		list__append(FlushInstrs, Instrs1, Instrs)
	;
		Uinstr0 = call_closure(ClAddr, ReturnAddr, LiveInfo),
		vn__new_ctrl_node(vn_call_closure(ClAddr, ReturnAddr, LiveInfo),
			Livemap, Vn_tables0, Vn_tables1, Livevals0, Livevals1,
			Ctrlmap0, Ctrlmap1, Flushmap0, Flushmap1, Ctrl0, Ctrl1),
		vn__flush_all_nodes(Livevals1, Templocs0, Vn_tables1,
			Incrsp, Decrsp, Incrhp, Ctrlmap1, Flushmap1, Ctrl1,
			[Instr0 | Prev], FlushInstrs),
		vn__opt_non_block(Instrs0, Livemap, Instrs1),
		list__append(FlushInstrs, Instrs1, Instrs)
	;
		Uinstr0 = mkframe(Name, Size, Redoip),
		vn__new_ctrl_node(vn_mkframe(Name, Size, Redoip), Livemap,
			Vn_tables0, Vn_tables1, Livevals0, Livevals1,
			Ctrlmap0, Ctrlmap1, Flushmap0, Flushmap1, Ctrl0, Ctrl1),
		vn__opt_block(Instrs0, Vn_tables1, Livemap,
			Templocs0, Livevals1, Incrsp, Decrsp, Incrhp,
			Ctrlmap1, Flushmap1, Ctrl1, [Instr0 | Prev], Instrs)
	;
		Uinstr0 = modframe(Redoip),
		vn__new_ctrl_node(vn_modframe(Redoip), Livemap,
			Vn_tables0, Vn_tables1, Livevals0, Livevals1,
			Ctrlmap0, Ctrlmap1, Flushmap0, Flushmap1, Ctrl0, Ctrl1),
		vn__opt_block(Instrs0, Vn_tables1, Livemap,
			Templocs0, Livevals1, Incrsp, Decrsp, Incrhp,
			Ctrlmap1, Flushmap1, Ctrl1, [Instr0 | Prev], Instrs)
	;
		Uinstr0 = label(Label),
		vn__new_ctrl_node(vn_label(Label), Livemap,
			Vn_tables0, Vn_tables1, Livevals0, Livevals1,
			Ctrlmap0, Ctrlmap1, Flushmap0, Flushmap1, Ctrl0, Ctrl1),
		vn__flush_all_nodes(Livevals1, Templocs0, Vn_tables1,
			Incrsp, Decrsp, Incrhp, Ctrlmap1, Flushmap1, Ctrl1,
			[Instr0 | Prev], FlushInstrs),
		vn__opt_non_block([Instr0 | Instrs0], Livemap, Instrs1),
		list__append(FlushInstrs, Instrs1, Instrs)
	;
		Uinstr0 = goto(CodeAddr),
		vn__new_ctrl_node(vn_goto(CodeAddr), Livemap,
			Vn_tables0, Vn_tables1, Livevals0, Livevals1,
			Ctrlmap0, Ctrlmap1, Flushmap0, Flushmap1, Ctrl0, Ctrl1),
		vn__flush_all_nodes(Livevals1, Templocs0, Vn_tables1,
			Incrsp, Decrsp, Incrhp, Ctrlmap1, Flushmap1, Ctrl1,
			[Instr0 | Prev], FlushInstrs),
		vn__opt_non_block(Instrs0, Livemap, Instrs1),
		list__append(FlushInstrs, Instrs1, Instrs)
	;
		Uinstr0 = computed_goto(Rval, Labels),
		vn__rval_to_vn(Rval, Vn, Vn_tables0, Vn_tables1),
		vn__new_ctrl_node(vn_computed_goto(Vn, Labels), Livemap,
			Vn_tables1, Vn_tables2, Livevals0, Livevals1,
			Ctrlmap0, Ctrlmap1, Flushmap0, Flushmap1, Ctrl0, Ctrl1),
		vn__flush_all_nodes(Livevals1, Templocs0, Vn_tables2,
			Incrsp, Decrsp, Incrhp, Ctrlmap1, Flushmap1, Ctrl1,
			[Instr0 | Prev], FlushInstrs),
		vn__opt_non_block(Instrs0, Livemap, Instrs1),
		list__append(FlushInstrs, Instrs1, Instrs)
	;
		Uinstr0 = c_code(_),
		error("c_code in handle_instr")
	;
		Uinstr0 = if_val(Rval, CodeAddr),
		vn__rval_to_vn(Rval, Vn, Vn_tables0, Vn_tables1),
		vn__new_ctrl_node(vn_if_val(Vn, CodeAddr), Livemap,
			Vn_tables1, Vn_tables2, Livevals0, Livevals1,
			Ctrlmap0, Ctrlmap1, Flushmap0, Flushmap1, Ctrl0, Ctrl1),
		vn__opt_block(Instrs0, Vn_tables2, Livemap,
			Templocs0, Livevals1, Incrsp, Decrsp, Incrhp,
			Ctrlmap1, Flushmap1, Ctrl1, [Instr0 | Prev], Instrs)
	;
		Uinstr0 = incr_hp(Lval, MaybeTag, Rval),
		(
			MaybeTag = no,
			StoreInstr = assign(Lval, lval(hp)) - ""
		;
			MaybeTag = yes(Tag),
			StoreInstr = assign(Lval, mkword(Tag, lval(hp))) - ""
		),
		IncrInstr = assign(hp, binop((+), lval(hp),
			binop((*), Rval, const(int_const(4))))) - "",
		Instrs1 = [StoreInstr, IncrInstr | Instrs0],
		vn__opt_block(Instrs1, Vn_tables0, Livemap,
			Templocs0, Livevals0, Incrsp, Decrsp, yes,
			Ctrlmap0, Flushmap0, Ctrl0, [Instr0 | Prev], Instrs)
	;
		Uinstr0 = mark_hp(Lval),
		vn__lval_to_vnlval(Lval, Vnlval, Vn_tables0, Vn_tables1),
		vn__new_ctrl_node(vn_mark_hp(Vnlval), Livemap,
			Vn_tables1, Vn_tables2, Livevals0, Livevals1,
			Ctrlmap0, Ctrlmap1, Flushmap0, Flushmap1, Ctrl0, Ctrl1),
		vn__opt_block(Instrs0, Vn_tables2, Livemap,
			Templocs0, Livevals1, Incrsp, Decrsp, Incrhp,
			Ctrlmap1, Flushmap1, Ctrl1, [Instr0 | Prev], Instrs)
	;
		Uinstr0 = restore_hp(Rval),
		vn__rval_to_vn(Rval, Vn, Vn_tables0, Vn_tables1),
		vn__new_ctrl_node(vn_restore_hp(Vn), Livemap,
			Vn_tables1, Vn_tables2, Livevals0, Livevals1,
			Ctrlmap0, Ctrlmap1, Flushmap0, Flushmap1, Ctrl0, Ctrl1),
		vn__opt_block(Instrs0, Vn_tables2, Livemap,
			Templocs0, Livevals1, Incrsp, Decrsp, Incrhp,
			Ctrlmap1, Flushmap1, Ctrl1, [Instr0 | Prev], Instrs)
	;
		Uinstr0 = incr_sp(N),
		vn__opt_block(Instrs0, Vn_tables0, Livemap,
			Templocs0, Livevals0, N, Decrsp, Incrhp,
			Ctrlmap0, Flushmap0, Ctrl0, [Instr0 | Prev], Instrs)
	;
		Uinstr0 = decr_sp(N),
		vn__opt_block(Instrs0, Vn_tables0, Livemap,
			Templocs0, Livevals0, Incrsp, N, Incrhp,
			Ctrlmap0, Flushmap0, Ctrl0, [Instr0 | Prev], Instrs)
	).

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

% uncount all dead lvals
% map from (livelvals U shared_vn U ctrl) to set of (shared_vn U origlvals)
% count only unique paths, i.e. when arriving at a shared node
%  count only the shared vn, not anything else it points to
% build a topological sort based on this order, plus the order that
%  after the appearance of an lval no refs to its origlval be outstanding
%  this includes appearances as the bases of field references
%  plus the order that the livevals at a label must be before a branch
%  to that label

%-----------------------------------------------------------------------------%

:- pred vn__flush_all_nodes(vnlvalset, templocs, vn_tables, int, int, bool,
	ctrlmap, flushmap, int, list(instruction), list(instruction)).
:- mode vn__flush_all_nodes(in, in, in, in, in, in, in, in, in, in, out) is det.

vn__flush_all_nodes(Livevals, Templocs0, Vn_tables0, Incrsp, Decrsp, Incrhp,
		Ctrlmap, Flushmap, Ctrl, RevInstrs, Instrs) :-
	bintree_set__to_sorted_list(Livevals, Live),
	vn__build_uses(Livevals, Ctrlmap, Vn_tables0, Vn_tables1),

	opt_debug__write("\n\n"),
	opt_debug__dump_ctrlmap(Ctrlmap, Ctrl_str),
	opt_debug__write(Ctrl_str),
	opt_debug__dump_flushmap(Flushmap, Flush_str),
	opt_debug__write(Flush_str),
	opt_debug__dump_tables(Vn_tables1, Tables_str),
	opt_debug__write(Tables_str),

	(
		vn__req_order(Ctrlmap, Flushmap, Incrhp, Vn_tables1,
			MustSuccmap, MustPredmap)
	->
		Succmap0 = MustSuccmap,
		Predmap0 = MustPredmap,
		vn__prod_cons_order(Live, Vn_tables1, Vn_tables2,
			Succmap0, Succmap1, Predmap0, Predmap1),
		vn__use_before_redef(Succmap1, Succmap2, Predmap1, Predmap2),
		vn__vn_ctrl_order(0, Ctrlmap, Vn_tables2, Vn_tables3,
			Succmap2, Succmap3, Predmap2, Predmap3),
		vn__ctrl_vn_order(0, Flushmap, [],
			Succmap3, Succmap4, Predmap3, Predmap4),
		vn__pref_order(Succmap4, PrefOrder),

		% opt_debug__write("\nSuccmap:\n"),
		% opt_debug__dump_node_relmap(Succmap4, S_str),
		% opt_debug__write(S_str),
		% opt_debug__write("\nPredmap:\n"),
		% opt_debug__dump_node_relmap(Predmap4, P_str),
		% opt_debug__write(P_str),
		% opt_debug__write("\nMustSuccmap:\n"),
		% opt_debug__dump_node_relmap(MustSuccmap, MS_str),
		% opt_debug__write(MS_str),
		% opt_debug__write("\nMustPredmap:\n"),
		% opt_debug__dump_node_relmap(MustPredmap, MP_str),
		% opt_debug__write(MP_str),

		atsort(Succmap4, Predmap4, MustSuccmap, MustPredmap,
			PrefOrder, BlockOrder),
		LastCtrl is Ctrl - 1,
		vn__blockorder_to_order(BlockOrder, LastCtrl, Order),

		opt_debug__dump_longnodelist(Order, O_str),
		opt_debug__write("\nOrder:\n"),
		opt_debug__write(O_str),
		opt_debug__write("\n"),

		vn__flush_nodelist(Order, Ctrlmap, Vn_tables3, _Vn_tables,
			Templocs0, Templocs, Instrs0),

		( Incrsp > 0 ->
			vn__insert_incr_sp(Incrsp, Instrs0, Instrs1)
		;
			Instrs1 = Instrs0
		),
		( Decrsp > 0 ->
			vn__insert_decr_sp(Decrsp, Instrs1, Instrs2)
		;
			Instrs2 = Instrs1
		),
		vn__max_temploc(Templocs, Max),
		( Max > 0 ->
			Instrs = [block(Max, Instrs2) - ""]
		;
			Instrs = Instrs2
		)
	;
		list__reverse(RevInstrs, Instrs)
	).

%-----------------------------------------------------------------------------%

	% Given the information gathered on the control nodes, check whether
	% any side branch requires a value to be stored in a vnlval other than
	% the final one. If yes, we can't apply (this version of) value
	% numbering. If no, we can apply it, and we compute the compulsory
	% part of the order of nodes, which is that a vnlval that is live
	% at a side branch must be produced before that side branch.

:- pred vn__req_order(ctrlmap, flushmap, bool, vn_tables,
	relmap(vn_node), relmap(vn_node)).
:- mode vn__req_order(in, in, in, in, out, out) is semidet.

vn__req_order(Ctrlmap, Flushmap, Incrhp, Vn_tables, MustSuccmap, MustPredmap) :-
	map__init(MustSuccmap0),
	map__init(MustPredmap0),
	vn__req_order_2(0, Ctrlmap, Flushmap, Incrhp, Vn_tables,
		MustSuccmap0, MustSuccmap, MustPredmap0, MustPredmap).

:- pred vn__req_order_2(int, ctrlmap, flushmap, bool, vn_tables,
	relmap(vn_node), relmap(vn_node), relmap(vn_node), relmap(vn_node)).
:- mode vn__req_order_2(in, in, in, in, in, di, uo, di, uo) is semidet.

vn__req_order_2(Ctrl, Ctrlmap, Flushmap, Heapop0, Vn_tables,
		MustSuccmap0, MustSuccmap, MustPredmap0, MustPredmap) :-
	( map__search(Ctrlmap, Ctrl, VnInstr) ->
		( VnInstr = vn_mark_hp(_) ->
			Heapop0 = no,
			Heapop1 = yes
		; VnInstr = vn_restore_hp(_) ->
			Heapop0 = no,
			Heapop1 = yes
		;
			Heapop1 = Heapop0
		),
		map__lookup(Flushmap, Ctrl, FlushEntry),
		( Ctrl > 0 ->
			PrevCtrl is Ctrl - 1,
			vn__add_link(node_ctrl(PrevCtrl), node_ctrl(Ctrl),
				MustSuccmap0, MustSuccmap1,
				MustPredmap0, MustPredmap1)
		;
			vn__add_node(node_ctrl(Ctrl),
				MustSuccmap0, MustSuccmap1,
				MustPredmap0, MustPredmap1)
		),
		map__to_assoc_list(FlushEntry, FlushList),
		vn__record_ctrl_deps(FlushList, node_ctrl(Ctrl), Vn_tables,
			MustSuccmap1, MustSuccmap2, MustPredmap1, MustPredmap2),
		NextCtrl is Ctrl + 1,
		vn__req_order_2(NextCtrl, Ctrlmap, Flushmap, Heapop1, Vn_tables,
			MustSuccmap2, MustSuccmap, MustPredmap2, MustPredmap)
	;
		MustSuccmap = MustSuccmap0,
		MustPredmap = MustPredmap0
	).

:- pred vn__record_ctrl_deps(assoc_list(vnlval, vn), vn_node, vn_tables,
	relmap(vn_node), relmap(vn_node), relmap(vn_node), relmap(vn_node)).
:- mode vn__record_ctrl_deps(in, in, in, di, uo, di, uo) is semidet.

vn__record_ctrl_deps([], _Sink, _Vn_tables,
		MustSuccmap, MustSuccmap, MustPredmap, MustPredmap).
vn__record_ctrl_deps([Vnlval - Vn | FlushList], Sink, Vn_tables,
		MustSuccmap0, MustSuccmap, MustPredmap0, MustPredmap) :-
	vn__lookup_desired_value(Vnlval, Des_vn, Vn_tables),
	Vn = Des_vn,
	vn__add_link(node_lval(Vnlval), Sink,
		MustSuccmap0, MustSuccmap1, MustPredmap0, MustPredmap1),
	vn__record_ctrl_deps(FlushList, Sink, Vn_tables,
		MustSuccmap1, MustSuccmap, MustPredmap1, MustPredmap).

%-----------------------------------------------------------------------------%

	% Record the desirability of producing the vnlvals involved in the
	% expressions inside control nodes before producing the control nodes
	% themselves. This is stated as a suggestion, not a requirement, since
	% it can be overridden during the flushing process.

:- pred vn__vn_ctrl_order(int, ctrlmap, vn_tables, vn_tables,
	relmap(vn_node), relmap(vn_node), relmap(vn_node), relmap(vn_node)).
:- mode vn__vn_ctrl_order(in, in, di, uo, di, uo, di, uo) is det.

vn__vn_ctrl_order(Ctrl, Ctrlmap, Vn_tables0, Vn_tables,
		Succmap0, Succmap, Predmap0, Predmap) :-
	( map__search(Ctrlmap, Ctrl, Vn_instr) ->
		(
			Vn_instr = vn_call(_, _, _),
			Succmap1 = Succmap0,
			Predmap1 = Predmap0,
			Vn_tables1 = Vn_tables0
		;
			Vn_instr = vn_call_closure(_, _, _),
			Succmap1 = Succmap0,
			Predmap1 = Predmap0,
			Vn_tables1 = Vn_tables0
		;
			Vn_instr = vn_mkframe(_, _, _),
			Succmap1 = Succmap0,
			Predmap1 = Predmap0,
			Vn_tables1 = Vn_tables0
		;
			Vn_instr = vn_modframe(_),
			Succmap1 = Succmap0,
			Predmap1 = Predmap0,
			Vn_tables1 = Vn_tables0
		;
			Vn_instr = vn_label(_),
			Succmap1 = Succmap0,
			Predmap1 = Predmap0,
			Vn_tables1 = Vn_tables0
		;
			Vn_instr = vn_goto(_),
			Succmap1 = Succmap0,
			Predmap1 = Predmap0,
			Vn_tables1 = Vn_tables0
		;
			Vn_instr = vn_computed_goto(Vn, _),
			vn__find_links(Vn, node_ctrl(Ctrl),
				Vn_tables0, Vn_tables1,
				Succmap0, Succmap1, Predmap0, Predmap1)
		;
			Vn_instr = vn_if_val(Vn, _),
			vn__find_links(Vn, node_ctrl(Ctrl),
				Vn_tables0, Vn_tables1,
				Succmap0, Succmap1, Predmap0, Predmap1)
		;
			Vn_instr = vn_mark_hp(Vnlval),
			vn__vnlval_access_vn(Vnlval, Vns),
			vn__find_all_links(Vns, node_ctrl(Ctrl),
				Vn_tables0, Vn_tables1,
				Succmap0, Succmap1, Predmap0, Predmap1)
		;
			Vn_instr = vn_restore_hp(Vn),
			vn__find_links(Vn, node_ctrl(Ctrl),
				Vn_tables0, Vn_tables1,
				Succmap0, Succmap1, Predmap0, Predmap1)
		),
		NextCtrl is Ctrl + 1,
		vn__vn_ctrl_order(NextCtrl, Ctrlmap, Vn_tables1, Vn_tables,
			Succmap1, Succmap, Predmap1, Predmap)
	;
		Succmap = Succmap0,
		Predmap = Predmap0,
		Vn_tables = Vn_tables0
	).

%-----------------------------------------------------------------------------%

	% Record the desirability of not producing any lvals before a control
	% node expect those we absolutely have to, since any such production
	% will be wasted on one control path.

:- pred vn__ctrl_vn_order(int, flushmap, list(vnlval),
	relmap(vn_node), relmap(vn_node), relmap(vn_node), relmap(vn_node)).
:- mode vn__ctrl_vn_order(in, in, in, di, uo, di, uo) is det.

vn__ctrl_vn_order(Ctrl, Flushmap, FlushBefore,
		Succmap0, Succmap, Predmap0, Predmap) :-
	( map__search(Flushmap, Ctrl, FlushEntry) ->
		map__keys(Succmap0, Nodes),
		map__keys(FlushEntry, FlushVnlvals),
		list__append(FlushBefore, FlushVnlvals, FlushNow),
		vn__record_antideps(Nodes, FlushNow, Ctrl,
			Succmap0, Succmap1, Predmap0, Predmap1),
		NextCtrl is Ctrl + 1,
		vn__ctrl_vn_order(NextCtrl, Flushmap, FlushNow,
			Succmap1, Succmap, Predmap1, Predmap)
	;
		Succmap = Succmap0,
		Predmap = Predmap0
	).

:- pred vn__record_antideps(list(vn_node), list(vnlval), int,
	relmap(vn_node), relmap(vn_node), relmap(vn_node), relmap(vn_node)).
:- mode vn__record_antideps(in, in, in, di, uo, di, uo) is det.

vn__record_antideps([], _, _, Succmap, Succmap, Predmap, Predmap).
vn__record_antideps([Node | Nodelist], FlushVnlvals, Ctrl,
		Succmap0, Succmap, Predmap0, Predmap) :-
	(
		% once upon a time any shared node was also included
		Node = node_lval(Vnlval),
		\+ list__member(Vnlval, FlushVnlvals)
	->
		vn__add_link(node_ctrl(Ctrl), Node,
			Succmap0, Succmap1, Predmap0, Predmap1)
	;
		Succmap1 = Succmap0,
		Predmap1 = Predmap0
	),
	vn__record_antideps(Nodelist, FlushVnlvals, Ctrl,
		Succmap1, Succmap, Predmap1, Predmap).

%-----------------------------------------------------------------------------%

	% Record the natural producer-consumer relationships
	% induced by the live vnlvals.

:- pred vn__prod_cons_order(list(vnlval), vn_tables, vn_tables,
	relmap(vn_node), relmap(vn_node), relmap(vn_node), relmap(vn_node)).
:- mode vn__prod_cons_order(in, di, uo, di, uo, di, uo) is det.

vn__prod_cons_order([], Vn_tables, Vn_tables,
		Succmap, Succmap, Predmap, Predmap).
vn__prod_cons_order([Vnlval | Vnlvals], Vn_tables0, Vn_tables,
		Succmap0, Succmap, Predmap0, Predmap) :-
	vn__lookup_desired_value(Vnlval, Vn, Vn_tables0),
	vn__find_links(Vn, node_lval(Vnlval), Vn_tables0, Vn_tables1,
		Succmap0, Succmap1, Predmap0, Predmap1),
	vn__prod_cons_order(Vnlvals, Vn_tables1, Vn_tables,
		Succmap1, Succmap, Predmap1, Predmap).

%-----------------------------------------------------------------------------%

	% Try to make sure that all immediate users of the original value
	% of a vnlval are done before the vnlval is redefined. This avoids
	% an instruction to save the original value somewhere else.

:- pred vn__use_before_redef(relmap(vn_node), relmap(vn_node),
	relmap(vn_node), relmap(vn_node)).
:- mode vn__use_before_redef(di, uo, di, uo) is det.

vn__use_before_redef(Succmap0, Succmap, Predmap0, Predmap) :-
	map__keys(Predmap0, Sinks),
	vn__use_sinks_before_redef(Sinks, Succmap0, Succmap, Predmap0, Predmap).

:- pred vn__use_sinks_before_redef(list(vn_node),
	relmap(vn_node), relmap(vn_node), relmap(vn_node), relmap(vn_node)).
:- mode vn__use_sinks_before_redef(in, di, uo, di, uo) is det.

vn__use_sinks_before_redef([], Succmap, Succmap, Predmap, Predmap).
vn__use_sinks_before_redef([Sink | Sinks],
		Succmap0, Succmap, Predmap0, Predmap) :-
	(
		Sink = node_lval(Vnlval),
		map__search(Succmap0, node_origlval(Vnlval), Users)
	->
		vn__add_links(Users, Sink,
			Succmap0, Succmap1, Predmap0, Predmap1)
	;
		Succmap1 = Succmap0,
		Predmap1 = Predmap0
	),
	vn__use_sinks_before_redef(Sinks, Succmap1, Succmap, Predmap1, Predmap).

%-----------------------------------------------------------------------------%

	% Record the dependency of the nodes inside the given vn
	% on the given node.

:- pred vn__find_links(vn, vn_node, vn_tables, vn_tables,
	relmap(vn_node), relmap(vn_node), relmap(vn_node), relmap(vn_node)).
:- mode vn__find_links(in, in, di, uo, di, uo, di, uo) is det.

vn__find_links(Vn, Sink, Vn_tables0, Vn_tables,
		Succmap0, Succmap, Predmap0, Predmap) :-
	vn__lookup_uses(Vn, Uses0, Vn_tables0),
	(
		Uses0 = [_,_|_],
		\+ Sink = node_shared(_),
		vn__is_const_expr(Vn, no, Vn_tables0)
	->
		vn__add_link(node_shared(Vn), Sink,
			Succmap0, Succmap1, Predmap0, Predmap1),
		vn__find_links(Vn, node_shared(Vn), Vn_tables0, Vn_tables,
			Succmap1, Succmap, Predmap1, Predmap)
	;
		vn__lookup_defn(Vn, Vnrval, Vn_tables0),
		(
			Vnrval = vn_origlval(Vnlval),
			vn__vnlval_access_vn(Vnlval, Access_vns),
			vn__find_all_links(Access_vns, Sink,
				Vn_tables0, Vn_tables,
				Succmap0, Succmap1, Predmap0, Predmap1),
			vn__add_link(node_origlval(Vnlval), Sink,
				Succmap1, Succmap, Predmap1, Predmap)
		;
			Vnrval = vn_mkword(_Tag1, SubVn),
			vn__find_links(SubVn, Sink, Vn_tables0, Vn_tables,
				Succmap0, Succmap, Predmap0, Predmap)
		;
			Vnrval = vn_const(_Const),
			Succmap = Succmap0,
			Predmap = Predmap0,
			Vn_tables = Vn_tables0
		;
			Vnrval = vn_create(_Tag2, _Args, _Label),
			Succmap = Succmap0,
			Predmap = Predmap0,
			Vn_tables = Vn_tables0
		;
			Vnrval = vn_unop(_Unop, SubVn),
			vn__find_links(SubVn, Sink, Vn_tables0, Vn_tables,
				Succmap0, Succmap, Predmap0, Predmap)
		;
			Vnrval = vn_binop(_Binop, SubVn1, SubVn2),
			vn__find_links(SubVn1, Sink, Vn_tables0, Vn_tables1,
				Succmap0, Succmap1, Predmap0, Predmap1),
			vn__find_links(SubVn2, Sink, Vn_tables1, Vn_tables,
				Succmap1, Succmap, Predmap1, Predmap)
		)
	).

:- pred vn__find_all_links(list(vn), vn_node, vn_tables, vn_tables,
	relmap(vn_node), relmap(vn_node), relmap(vn_node), relmap(vn_node)).
:- mode vn__find_all_links(in, in, di, uo, di, uo, di, uo) is det.

vn__find_all_links([], _Sink, Vn_tables, Vn_tables,
		Succmap, Succmap, Predmap, Predmap).
vn__find_all_links([Vn | Vns], Sink, Vn_tables0, Vn_tables,
		Succmap0, Succmap, Predmap0, Predmap) :-
	vn__find_links(Vn, Sink, Vn_tables0, Vn_tables1,
		Succmap0, Succmap1, Predmap0, Predmap1),
	vn__find_all_links(Vns, Sink, Vn_tables1, Vn_tables,
		Succmap1, Succmap, Predmap1, Predmap).

%-----------------------------------------------------------------------------%

	% Add specified link(s) to succmap/predmap pairs.

:- pred vn__add_links(list(vn_node), vn_node,
	relmap(vn_node), relmap(vn_node), relmap(vn_node), relmap(vn_node)).
:- mode vn__add_links(in, in, di, uo, di, uo) is det.

vn__add_links([], _, Succmap, Succmap, Predmap, Predmap).
vn__add_links([Source | Sources], Sink, Succmap0, Succmap, Predmap0, Predmap) :-
	vn__add_link(Source, Sink, Succmap0, Succmap1, Predmap0, Predmap1),
	vn__add_links(Sources, Sink, Succmap1, Succmap, Predmap1, Predmap).

:- pred vn__add_link(vn_node, vn_node,
	relmap(vn_node), relmap(vn_node), relmap(vn_node), relmap(vn_node)).
:- mode vn__add_link(in, in, di, uo, di, uo) is det.

vn__add_link(Source, Sink, Succmap0, Succmap, Predmap0, Predmap) :-
	( Source = Sink ->
		Succmap = Succmap0,
		Predmap = Predmap0
	;
		( map__search(Succmap0, Source, Sinks0) ->
			vn__insert_if_not_there(Sink, Sinks0, Sinks1),
			map__set(Succmap0, Source, Sinks1, Succmap1)
		;
			map__set(Succmap0, Source, [Sink], Succmap1)
		),
		( map__search(Succmap0, Sink, _) ->
			Succmap = Succmap1
		;
			map__set(Succmap1, Sink, [], Succmap)
		),
		( map__search(Predmap0, Sink, Sources0) ->
			vn__insert_if_not_there(Source, Sources0, Sources1),
			map__set(Predmap0, Sink, Sources1, Predmap1)
		;
			map__set(Predmap0, Sink, [Source], Predmap1)
		),
		( map__search(Predmap0, Source, _) ->
			Predmap = Predmap1
		;
			map__set(Predmap1, Source, [], Predmap)
		)
	).

:- pred vn__insert_if_not_there(vn_node, list(vn_node), list(vn_node)).
:- mode vn__insert_if_not_there(in, di, uo) is det.

vn__insert_if_not_there(Node, Nodes0, Nodes) :-
	( list__member(Node, Nodes0) ->
		Nodes = Nodes0
	;
		Nodes = [Node | Nodes0]
	).

	% Ensure the presence of the given node without giving any links.

:- pred vn__add_node(vn_node,
	relmap(vn_node), relmap(vn_node), relmap(vn_node), relmap(vn_node)).
:- mode vn__add_node(in, di, uo, di, uo) is det.

vn__add_node(Node, Succmap0, Succmap, Predmap0, Predmap) :-
	( map__search(Succmap0, Node, _) ->
		Succmap = Succmap0
	;
		map__set(Succmap0, Node, [], Succmap)
	),
	( map__search(Predmap0, Node, _) ->
		Predmap = Predmap0
	;
		map__set(Predmap0, Node, [], Predmap)
	).

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

	% Flush the given nodes in the given order.

:- pred vn__flush_nodelist(list(vn_node), ctrlmap,
	vn_tables, vn_tables, templocs, templocs, list(instruction)).
:- mode vn__flush_nodelist(in, in, di, uo, di, uo, out) is det.

vn__flush_nodelist([], _Ctrlmap, Vn_tables, Vn_tables, Templocs, Templocs, []).
vn__flush_nodelist([Node | Nodes], Ctrlmap, Vn_tables0, Vn_tables,
		Templocs0, Templocs, Instrs) :-
	vn__flush_node(Node, Ctrlmap, Vn_tables0, Vn_tables1,
		Templocs0, Templocs1, Instrs0),
	vn__flush_nodelist(Nodes, Ctrlmap, Vn_tables1, Vn_tables,
		Templocs1, Templocs, Instrs1),
	list__append(Instrs0, Instrs1, Instrs).

	% Flush the given node.

:- pred vn__flush_node(vn_node, ctrlmap, vn_tables, vn_tables,
	templocs, templocs, list(instruction)).
:- mode vn__flush_node(in, in, di, uo, di, uo, out) is det.

vn__flush_node(Node, Ctrlmap, Vn_tables0, Vn_tables, Templocs0, Templocs,
		Instrs) :-
	(
		Node = node_shared(Vn),
		Debug = yes,
		vn__choose_best_loc(Vn, Vnlval, Vn_tables0,
			Templocs0, Templocs1),
		vn__ensure_assignment(Vnlval, Vn,
			Vn_tables0, Vn_tables, Templocs1, Templocs, Instrs)
	;
		Node = node_lval(Vnlval),
		Debug = yes,
		vn__lookup_desired_value(Vnlval, Vn, Vn_tables0),
		vn__ensure_assignment(Vnlval, Vn,
			Vn_tables0, Vn_tables, Templocs0, Templocs, Instrs)
	;
		Node = node_origlval(Vnlval),
		Debug = no,
		Vn_tables = Vn_tables0,
		Templocs = Templocs0,
		Instrs = []
	;
		Node = node_ctrl(N),
		Debug = yes,
		map__lookup(Ctrlmap, N, Vn_instr),
		(
			Vn_instr = vn_call(ProcAddr, RetAddr, LiveInfo),
			Vn_tables = Vn_tables0,
			Templocs = Templocs0,
			Instrs = [call(ProcAddr, RetAddr, LiveInfo) - ""]
		;
			Vn_instr = vn_call_closure(ClAddr, RetAddr, LiveInfo),
			Vn_tables = Vn_tables0,
			Templocs = Templocs0,
			Instrs = [call_closure(ClAddr, RetAddr, LiveInfo) - ""]
		;
			Vn_instr = vn_mkframe(Name, Size, Redoip),
			Vn_tables = Vn_tables0,
			Templocs = Templocs0,
			Instrs = [mkframe(Name, Size, Redoip) - ""]
		;
			Vn_instr = vn_modframe(Redoip),
			Vn_tables = Vn_tables0,
			Templocs = Templocs0,
			Instrs = [modframe(Redoip) - ""]
		;
			Vn_instr = vn_label(Label),
			Vn_tables = Vn_tables0,
			Templocs = Templocs0,
			Instrs = [goto(label(Label)) - "eliminated by postopt"]
		;
			Vn_instr = vn_goto(TargetAddr),
			Vn_tables = Vn_tables0,
			Templocs = Templocs0,
			Instrs = [goto(TargetAddr) - ""]
		;
			Vn_instr = vn_computed_goto(Vn, Labels),
			vn__flush_vn(Vn, src_ctrl(N), Rval,
				Vn_tables0, Vn_tables,
				Templocs0, Templocs, FlushInstrs),
			Instr = computed_goto(Rval, Labels) - "",
			list__append(FlushInstrs, [Instr], Instrs)
		;
			Vn_instr = vn_if_val(Vn, TargetAddr),
			vn__flush_vn(Vn, src_ctrl(N), Rval,
				Vn_tables0, Vn_tables,
				Templocs0, Templocs, FlushInstrs),
			Instr = if_val(Rval, TargetAddr) - "",
			list__append(FlushInstrs, [Instr], Instrs)
		;
			Vn_instr = vn_mark_hp(Vnlval),
			vn__flush_access_path(Vnlval, src_ctrl(N), Lval,
				Vn_tables0, Vn_tables,
				Templocs0, Templocs, FlushInstrs),
			Instr = mark_hp(Lval) - "",
			list__append(FlushInstrs, [Instr], Instrs)
		;
			Vn_instr = vn_restore_hp(Vn),
			vn__flush_vn(Vn, src_ctrl(N), Rval,
				Vn_tables0, Vn_tables,
				Templocs0, Templocs, FlushInstrs),
			Instr = restore_hp(Rval) - "",
			list__append(FlushInstrs, [Instr], Instrs)
		)
	),
	(
		Debug = yes,
		opt_debug__write("for node "),
		opt_debug__dump_node(Node, N_str),
		opt_debug__write(N_str),
		opt_debug__write(" generated instrs:\n"),
		opt_debug__dump_fullinstrs(Instrs, I_str),
		opt_debug__write(I_str),
		opt_debug__write("new use info\n"),
		opt_debug__dump_useful_vns(Vn_tables, U_str),
		opt_debug__write(U_str),
		true
	;
		Debug = no,
		true
	).

%-----------------------------------------------------------------------------%

	% Choose a location for a shared value number that does not have to go
	% anywhere specific right now. We prefer to choose a register that
	% already has the value. If we cannot, we would like to choose from
	% among those locations that eventually want to have that value number,
	% but this may not be worthwhile if the contents of that location would
	% have to be saved first.

:- pred vn__choose_best_loc(vn, vnlval, vn_tables, templocs, templocs).
:- mode vn__choose_best_loc(in, out, in, di, uo) is det.

vn__choose_best_loc(Vn, Chosen, Vn_tables, Templocs0, Templocs) :-
	(
		vn__lookup_current_locs(Vn, CurrentLocs, Vn_tables),
		CurrentLocs = [_|_]
	->
		vn__choose_cheapest_loc(CurrentLocs, no, no, Chosen),
		Templocs = Templocs0
	;
		vn__search_uses(Vn, Uses, Vn_tables),
		vn__find_unused_user(Uses, Locs, Vn_tables),
		Locs = [_|_]
	->
		vn__choose_cheapest_loc(Locs, no, no, Chosen),
		Templocs = Templocs0
	;
		vn__next_temploc(Templocs0, Templocs, Chosen)
	).

:- pred vn__find_unused_user(list(vn_src), list(vnlval), vn_tables).
:- mode vn__find_unused_user(in, out, in) is det.

vn__find_unused_user([], [], _Vn_tables).
vn__find_unused_user([Src | Srcs], Vnlvals, Vn_tables) :-
	vn__find_unused_user(Srcs, Vnlvals0, Vn_tables),
	(
		Src = src_liveval(Live),
		\+ Live = vn_field(_, _, _),
		\+ vn__search_current_value(Live, _, Vn_tables)
	->
		Vnlvals = [Live | Vnlvals0]
	;
		Src = src_liveval(Live),
		\+ Live = vn_field(_, _, _),
		vn__search_current_value(Live, Vn, Vn_tables),
		vn__lookup_uses(Vn, [], Vn_tables)
	->
		Vnlvals = [Live | Vnlvals0]
	;
		Vnlvals = Vnlvals0
	).

%-----------------------------------------------------------------------------%

	% Choose the cheapest location from among those already holding
	% the desired vn. Therefore access time is the only consideration.

:- pred vn__choose_cheapest_loc(list(vnlval), maybe(vnlval), maybe(vnlval),
	vnlval).
:- mode vn__choose_cheapest_loc(in, in, in, out) is det.

vn__choose_cheapest_loc([Loc | Locs], Stack0, Heap0, BestLoc) :-
	(
		Loc = vn_reg(_),
		BestLoc = Loc
	;
		Loc = vn_stackvar(_),
		vn__choose_cheapest_loc(Locs, yes(Loc), Heap0, BestLoc)
	;
		Loc = vn_framevar(_),
		vn__choose_cheapest_loc(Locs, yes(Loc), Heap0, BestLoc)
	;
		Loc = vn_succip,
		BestLoc = Loc
	;
		Loc = vn_maxfr,
		BestLoc = Loc
	;
		Loc = vn_curredoip,
		vn__choose_cheapest_loc(Locs, yes(Loc), Heap0, BestLoc)
	;
		Loc = vn_hp,
		BestLoc = Loc
	;
		Loc = vn_sp,
		BestLoc = Loc
	;
		Loc = vn_field(_, _, _),
		vn__choose_cheapest_loc(Locs, Stack0, yes(Loc), BestLoc)
	;
		Loc = vn_temp(_),
		BestLoc = Loc
	).
vn__choose_cheapest_loc([], Stack0, Heap0, BestLoc) :-
	( Stack0 = yes(Stack) ->
		BestLoc = Stack
	; Heap0 = yes(Heap) ->
		BestLoc = Heap
	;
		error("empty locations list in vn__choose_cheapest_loc")
	).

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

:- pred vn__ensure_assignment(vnlval, vn, vn_tables, vn_tables,
	templocs, templocs, list(instruction)).
:- mode vn__ensure_assignment(in, in, di, uo, di, uo, out) is det.

vn__ensure_assignment(Vnlval, Vn, Vn_tables0, Vn_tables,
		Templocs0, Templocs, Instrs) :-
	(
		vn__search_current_value(Vnlval, Cur_vn, Vn_tables0),
		Vn = Cur_vn
	->
		vn__del_old_use(Vn, src_liveval(Vnlval), Vn_tables0, Vn_tables),
		Templocs = Templocs0,
		Instrs = []
	;
		vn__generate_assignment(Vnlval, Vn, Vn_tables0, Vn_tables,
			Templocs0, Templocs, _, Instrs)
	).

:- pred vn__generate_assignment(vnlval, vn, vn_tables, vn_tables,
	templocs, templocs, lval, list(instruction)).
:- mode vn__generate_assignment(in, in, di, uo, di, uo, out, out) is det.

vn__generate_assignment(Vnlval, Vn, Vn_tables0, Vn_tables,
		Templocs0, Templocs, Lval, Instrs) :-
	% Only lvals on the heap must have their access path flushed,
	% but they cannot appear on the temploc list, so of the next
	% next two calls, at most one will modify temploc.
	vn__no_temploc(Vnlval, Templocs0, Templocs1),
	vn__flush_access_path(Vnlval, src_liveval(Vnlval), Lval,
		Vn_tables0, Vn_tables1, Templocs1, Templocs2, AccessInstrs),
	vn__flush_vn(Vn, src_liveval(Vnlval), Rval, Vn_tables1, Vn_tables2,
		Templocs2, Templocs3, FlushInstrs),
	vn__maybe_save_prev_value(Vnlval, Vn_tables2, Vn_tables3,
		Templocs3, Templocs, SaveInstrs),
	vn__set_current_value(Vnlval, Vn, Vn_tables3, Vn_tables),
	Instr = assign(Lval, Rval) - "vn flush",
	list__condense([AccessInstrs, FlushInstrs, SaveInstrs, [Instr]],
		Instrs).

%-----------------------------------------------------------------------------%

:- pred vn__flush_vn(vn, vn_src, rval, vn_tables, vn_tables,
	templocs, templocs, list(instruction)).
:- mode vn__flush_vn(in, in, out, di, uo, di, uo, out) is det.

vn__flush_vn(Vn, Src, Rval, Vn_tables0, Vn_tables,
		Templocs0, Templocs, Instrs) :-
	vn__is_const_expr(Vn, IsConst, Vn_tables0),
	(
		IsConst = yes,
		vn__flush_vn_value(Vn, Rval, Vn_tables0, Vn_tables1,
			Templocs0, Templocs, Instrs)
	;
		IsConst = no,
		vn__lookup_current_locs(Vn, Locs, Vn_tables0),
		( Locs = [] ->
			vn__lookup_uses(Vn, Uses, Vn_tables0),
			list__delete_all(Uses, Src, NewUses),
			% XXX rethink this condition
			( NewUses = [_|_], \+ Src = src_liveval(_) ->
				vn__choose_best_loc(Vn, Vnlval, Vn_tables0,
					Templocs0, Templocs1),
				vn__generate_assignment(Vnlval, Vn,
					Vn_tables0, Vn_tables1,
					Templocs1, Templocs, Lval, Instrs),
				Rval = lval(Lval)
			;
				vn__flush_vn_value(Vn, Rval,
					Vn_tables0, Vn_tables1,
					Templocs0, Templocs, Instrs)
			)
		;
			vn__choose_cheapest_loc(Locs, no, no, Loc),
			vn__flush_access_path(Loc, src_vn(Vn), Lval,
				Vn_tables0, Vn_tables1,
				Templocs0, Templocs, Instrs),
			Rval = lval(Lval)
		)
	),
	vn__del_old_use(Vn, Src, Vn_tables1, Vn_tables),
	true.
	% vn__lookup_uses(Vn, NewUses, Vn_tables),
	% ( NewUses = [_|_] ->
	% 	NewlyFree = NewlyFree0
	% ;
	% 	vn__lookup_current_locs(Vn, NewlyFree1, Vn_tables0)
	% 	list__append(NewlyFree0, NewlyFree1, NewlyFree)
	% ).

:- pred vn__flush_vn_value(vn, rval, vn_tables, vn_tables,
	templocs, templocs, list(instruction)).
:- mode vn__flush_vn_value(in, out, di, uo, di, uo, out) is det.

vn__flush_vn_value(Vn, Rval, Vn_tables0, Vn_tables, Templocs0, Templocs,
		Instrs) :-
	vn__lookup_defn(Vn, Vnrval, Vn_tables0),
	(
		Vnrval = vn_origlval(Vnlval),
		vn__lookup_current_value(Vnlval, CurVn, Vn_tables0),
		( Vn = CurVn ->
			% For code understandability, and for aesthetics,
			% prefer to take the value from its original home
			Loc = Vnlval
		;
			vn__lookup_current_locs(Vn, Locs, Vn_tables0),
			( Locs = [] ->
				error("cannot find copy of an origlval")
			;
				vn__choose_cheapest_loc(Locs, no, no, Loc)
			)
		),
		vn__flush_access_path(Loc, src_vn(Vn), Lval,
			Vn_tables0, Vn_tables, Templocs0, Templocs, Instrs),
		Rval = lval(Lval)
	;
		Vnrval = vn_mkword(Tag, SubVn1),
		vn__flush_vn(SubVn1, src_vn(Vn), Rval1, Vn_tables0, Vn_tables,
			Templocs0, Templocs, Instrs),
		Rval = mkword(Tag, Rval1)
	;
		Vnrval = vn_const(Const),
		Rval = const(Const),
		Vn_tables = Vn_tables0,
		Templocs = Templocs0,
		Instrs = []
	;
		Vnrval = vn_create(Tag, MaybeRvals, Label),
		Rval = create(Tag, MaybeRvals, Label),
		Vn_tables = Vn_tables0,
		Templocs = Templocs0,
		Instrs = []
	;
		Vnrval = vn_unop(Unop, SubVn1),
		vn__flush_vn(SubVn1, src_vn(Vn), Rval1, Vn_tables0, Vn_tables,
			Templocs0, Templocs, Instrs),
		Rval = unop(Unop, Rval1)
	;
		Vnrval = vn_binop(Binop, SubVn1, SubVn2),
		vn__flush_vn(SubVn1, src_vn(Vn), Rval1, Vn_tables0, Vn_tables1,
			Templocs0, Templocs1, Instrs1),
		vn__flush_vn(SubVn2, src_vn(Vn), Rval2, Vn_tables1, Vn_tables,
			Templocs1, Templocs, Instrs2),
		Rval = binop(Binop, Rval1, Rval2),
		list__append(Instrs1, Instrs2, Instrs)
	).

%-----------------------------------------------------------------------------%

:- pred vn__flush_access_path(vnlval, vn_src, lval, vn_tables, vn_tables,
	templocs, templocs, list(instruction)).
:- mode vn__flush_access_path(in, in, out, di, uo, di, uo, out) is det.

vn__flush_access_path(Vnlval, Src, Lval, Vn_tables0, Vn_tables,
		Templocs0, Templocs, AccessInstrs) :-
	(
		Vnlval = vn_reg(Reg),
		Lval = reg(Reg),
		Vn_tables = Vn_tables0,
		Templocs = Templocs0,
		AccessInstrs = []
	;
		Vnlval = vn_stackvar(Slot),
		Lval = stackvar(Slot),
		Vn_tables = Vn_tables0,
		Templocs = Templocs0,
		AccessInstrs = []
	;
		Vnlval = vn_framevar(Slot),
		Lval = framevar(Slot),
		Vn_tables = Vn_tables0,
		Templocs = Templocs0,
		AccessInstrs = []
	;
		Vnlval = vn_succip,
		Lval = succip,
		Vn_tables = Vn_tables0,
		Templocs = Templocs0,
		AccessInstrs = []
	;
		Vnlval = vn_maxfr,
		Lval = maxfr,
		Vn_tables = Vn_tables0,
		Templocs = Templocs0,
		AccessInstrs = []
	;
		Vnlval = vn_curredoip,
		Lval = curredoip,
		Vn_tables = Vn_tables0,
		Templocs = Templocs0,
		AccessInstrs = []
	;
		Vnlval = vn_hp,
		Lval = hp,
		Vn_tables = Vn_tables0,
		Templocs = Templocs0,
		AccessInstrs = []
	;
		Vnlval = vn_sp,
		Lval = sp,
		Vn_tables = Vn_tables0,
		Templocs = Templocs0,
		AccessInstrs = []
	;
		Vnlval = vn_field(Tag, Vn1, Vn2),
		vn__flush_vn(Vn1, Src, Rval1, Vn_tables0, Vn_tables1,
			Templocs0, Templocs1, AccessInstrs1),
		vn__flush_vn(Vn2, Src, Rval2, Vn_tables1, Vn_tables,
			Templocs1, Templocs, AccessInstrs2),
		Lval = field(Tag, Rval1, Rval2),
		list__append(AccessInstrs1, AccessInstrs2, AccessInstrs)
	;
		Vnlval = vn_temp(Num),
		Lval = temp(Num),
		Vn_tables = Vn_tables0,
		Templocs = Templocs0,
		AccessInstrs = []
	).

:- pred vn__find_lvals_matching_vn(assoc_list(vnlval,vn), vn, list(vnlval)).
:- mode vn__find_lvals_matching_vn(in, in, out) is det.

vn__find_lvals_matching_vn([], _, []).
vn__find_lvals_matching_vn([Vnlval - Vn | Tail], MatchVn, Res) :-
	vn__find_lvals_matching_vn(Tail, MatchVn, Res1),
	( Vn = MatchVn ->
		Res = [Vnlval | Res1]
	;
		Res = Res1
	).

	% If the value currently stored in the vnlval is used elsewhere,
	% and if it cannot be recreated blind (or at least not cheaply),
	% then save the value somewhere else. We prefer the somewhere else
	% to be a location where we have to store tha value anyway.

	% If we are overwriting a temporary location, it may not have
	% a current value entry in the vn tables.

:- pred vn__maybe_save_prev_value(vnlval, vn_tables, vn_tables,
	templocs, templocs, list(instruction)).
:- mode vn__maybe_save_prev_value(in, di, uo, di, uo, out) is det.

vn__maybe_save_prev_value(Vnlval, Vn_tables0, Vn_tables,
		Templocs0, Templocs, Instrs) :-
	(
		vn__search_current_value(Vnlval, Vn, Vn_tables0),
		vn__lookup_uses(Vn, Uses, Vn_tables0),
		Uses = [_|_],
		vn__is_const_expr(Vn, no, Vn_tables0),
		vn__lookup_current_locs(Vn, Locs0, Vn_tables0),
		list__delete_all(Locs0, Vnlval, Locs),
		Locs = []
	->
		(
			vn__find_unused_user(Uses, ReqLocs, Vn_tables0),
			ReqLocs = [_|_]
		->
			vn__choose_cheapest_loc(ReqLocs, no, no, Chosen),
			Templocs1 = Templocs0
		;
			vn__next_temploc(Templocs0, Templocs1, Chosen)
		),
		vn__ensure_assignment(Chosen, Vn,
			Vn_tables0, Vn_tables, Templocs1, Templocs, Instrs)
	;
		Vn_tables = Vn_tables0,
		Templocs = Templocs0,
		Instrs = []
	).

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

	% Fixup the code sequences flushed above. Insert any missing
	% stack pointer increments and decrements, and put assignments to
	% hp back into their proper form.

:- pred vn__insert_incr_sp(int, list(instruction), list(instruction)).
:- mode vn__insert_incr_sp(in, in, out) is det.

vn__insert_incr_sp(N, Instrs0, Instrs) :-
	Instrs = [incr_sp(N) - "vn flush" | Instrs0].

:- pred vn__insert_decr_sp(int, list(instruction), list(instruction)).
:- mode vn__insert_decr_sp(in, in, out) is det.

vn__insert_decr_sp(N, Instrs0, Instrs) :-
	list__reverse(Instrs0, RevInstrs0),
	(
		RevInstrs0 = [],
		Instrs = [decr_sp(N) - "vn flush"]
	;
		RevInstrs0 = [Last | Rest],
		Last = Ulast - _,
		( Ulast = call(_, _, _) ->
			RevInstrs = [Last, decr_sp(N) - "vn flush" | Rest]
		; Ulast = call_closure(_, _, _) ->
			RevInstrs = [Last, decr_sp(N) - "vn flush" | Rest]
		; Ulast = goto(_) ->
			RevInstrs = [Last, decr_sp(N) - "vn flush" | Rest]
		; Ulast = computed_goto(_, _) ->
			RevInstrs = [Last, decr_sp(N) - "vn flush" | Rest]
		;
			RevInstrs = [decr_sp(N) - "vn flush" | RevInstrs0]
		),
		list__reverse(RevInstrs, Instrs)
	).

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

	% If an extended basic block is ended by a label, the main value
	% numbering pass puts a goto to this label at the end of the block
	% instruction it creates for the basic block. This is necessary to
	% maintain the invariant that block instructions cannot fall through,
	% which considerably simplifies the implementation of frameopt.
	% However, it also slows down the code, so after frameopt we should
	% get rid of this jump. Local peepholing cannot do it because the
	% block boundary prevents it from seeming the goto and the label
	% at the same time.

value_number__post_main([], []).
value_number__post_main([Instr0 | Instrs0], [Instr | Instrs]) :-
	(
		Instr0 = block(TempCount, BlockInstrs) - Comment,
		opt_util__skip_comments_livevals(Instrs0, Instrs1),
		Instrs1 = [label(Label) - _ | _],
		list__reverse(BlockInstrs, BlockRevInstrs),
		BlockRevInstrs = [goto(label(Label)) - _ | RevBlockInstrs1]
	->
		list__reverse(RevBlockInstrs1, BlockInstrs1),
		Instr = block(TempCount, BlockInstrs1) - Comment
	;
		Instr = Instr0
	),
	value_number__post_main(Instrs0, Instrs).

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

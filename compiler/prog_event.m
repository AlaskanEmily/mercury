%-----------------------------------------------------------------------------%
% vim: ft=mercury ts=4 sw=4 et
%-----------------------------------------------------------------------------%
% Copyright (C) 2006 The University of Melbourne.
% This file may only be copied under the terms of the GNU General
% Public License - see the file COPYING in the Mercury distribution.
%-----------------------------------------------------------------------------%
%
% File: prog_event.m.
% Author: zs.
%
% This module defines the database of information the compiler has about
% events other than the built-in set of execution tracing events.
%
%-----------------------------------------------------------------------------%

:- module parse_tree.prog_event.
:- interface.

:- import_module parse_tree.error_util.
:- import_module parse_tree.prog_data.

:- import_module io.
:- import_module list.

    % read_event_specs(FileName, EventSpecMap, ErrorSpecs, !IO):
    %
    % Read in a set of event specifications from FileName, and return them
    % in EventSpecMap. Set ErrorSpecs to a list of all the errors discovered
    % during the process.
    %
:- pred read_event_specs(string::in, event_spec_map::out,
    list(error_spec)::out, io::di, io::uo) is det.

    % Return a description of the given event set.
    %
:- func event_set_description(event_spec_map) = string.

    % Given an event name, returns its number.
    %
:- pred event_number(event_spec_map::in, string::in, int::out) is semidet.

    % Given an event name, returns the names of the arguments of the event.
    %
:- pred event_arg_names(event_spec_map::in, string::in, list(string)::out)
    is semidet.

    % Given an event name, returns the types of the arguments of the event.
    %
:- pred event_arg_types(event_spec_map::in, string::in, list(mer_type)::out)
    is semidet.

    % Given an event name, returns the modes of the arguments of the event.
    %
:- pred event_arg_modes(event_spec_map::in, string::in, list(mer_mode)::out)
    is semidet.

%-----------------------------------------------------------------------------%

:- implementation.

:- import_module libs.compiler_util.
:- import_module mdbcomp.prim_data.
:- import_module parse_tree.prog_mode.
:- import_module parse_tree.prog_out.

:- import_module bimap.
:- import_module bool.
:- import_module maybe.
:- import_module pair.
:- import_module map.
:- import_module relation.
:- import_module string.
:- import_module svbimap.
:- import_module svmap.
:- import_module svrelation.
:- import_module term.

read_event_specs(SpecsFileName, EventSpecMap, ErrorSpecs, !IO) :-
    % Currently, we convert the event specification file into a Mercury term
    % by using the yacc parser in the trace directory to create a C data
    % structure to represent its contents, writing out that data structure
    % as a Mercury term to a file (TermFileName), and then reading in the term
    % from that file.
    %
    % This is a clumsy approach, since it requires access to the C code in the
    % trace directory (via the event_spec library) and a temporary file.
    % Using Mercury scanners and parsers generated by mscangen and mparsegen
    % respectively would be a much better and more direct approach, but
    % those tools are not yet mature enough. When they are, we should switch
    % to using them.

    io.make_temp(TermFileName, !IO),
    read_specs_file(SpecsFileName, TermFileName, Problem, !IO),
    ( Problem = "" ->
        io.open_input(TermFileName, TermOpenRes, !IO),
        (
            TermOpenRes = ok(TermStream),
            io.read(TermStream, TermReadRes, !IO),
            (
                TermReadRes = ok(EventSpecsTerm),
                convert_list_to_spec_map(TermFileName, EventSpecsTerm,
                    map.init, EventSpecMap, [], ErrorSpecs)
            ;
                TermReadRes = eof,
                EventSpecMap = map.init,
                Pieces = [words("eof in term specification file"), nl],
                ErrorSpec = error_spec(severity_error,
                    phase_term_to_parse_tree,
                    [error_msg(no, no, 0, [always(Pieces)])]),
                ErrorSpecs = [ErrorSpec]
            ;
                TermReadRes = error(TermReadMsg, LineNumber),
                EventSpecMap = map.init,
                Pieces = [words(TermReadMsg), nl],
                ErrorSpec = error_spec(severity_error,
                    phase_term_to_parse_tree,
                    [simple_msg(context(TermFileName, LineNumber),
                        [always(Pieces)])]),
                ErrorSpecs = [ErrorSpec]
            ),
            io.close_input(TermStream, !IO)
        ;
            TermOpenRes = error(TermOpenError),
            EventSpecMap = map.init,
            Pieces = [words(io.error_message(TermOpenError)), nl],
            ErrorSpec = error_spec(severity_error, phase_term_to_parse_tree,
                [error_msg(no, no, 0, [always(Pieces)])]),
            ErrorSpecs = [ErrorSpec]
        )
    ;
        EventSpecMap = map.init,
        Pieces = [words(Problem), nl],
        ErrorSpec = error_spec(severity_error, phase_term_to_parse_tree,
            [error_msg(no, no, 0, [always(Pieces)])]),
        ErrorSpecs = [ErrorSpec]
    ),
    io.remove_file(TermFileName, _RemoveRes, !IO).

:- pred read_specs_file(string::in, string::in, string::out,
    io::di, io::uo) is det.

:- pragma foreign_decl("C",
"
#include ""mercury_event_spec.h""
#include <stdio.h>
").

:- pragma foreign_proc("C",
    read_specs_file(SpecsFileName::in, TermFileName::in, Problem::out,
    _IO0::di, _IO::uo),
    [will_not_call_mercury, promise_pure, tabled_for_io, thread_safe],
"
    int     spec_fd;
    FILE    *term_fp;

    /*
    ** Using snprint instead of sprintf below would be very slightly safer,
    ** but unfortunately enabling the declaration of snprintf in the system's
    ** header files requires finding the right #defines, and this set of
    ** #defines is very system-dependent. Even having MR_HAVE_SNPRINTF set
    ** is no guarantee that calling snprintf won't lead to a warning from
    ** the C compiler.
    **
    ** There are race conditions between opening the file, stat'ing the file
    ** and reading the contents of the file, but the Unix API doesn't really
    ** allow these race conditions to be resolved.
    */

    spec_fd = open(SpecsFileName, O_RDONLY);
    if (spec_fd < 0) {
        char    buf[4096];

        sprintf(buf, ""could not open %s: %s"",
            SpecsFileName, strerror(errno));
        MR_make_aligned_string_copy(Problem, buf);
    } else {
        struct stat stat_buf;

        if (fstat(spec_fd, &stat_buf) != 0) {
            char    buf[4096];

            sprintf(buf, ""could not stat %s"", SpecsFileName);
            MR_make_aligned_string_copy(Problem, buf);
        } else {
            char        *spec_buf;

            spec_buf = malloc(stat_buf.st_size + 1);
            if (spec_buf == NULL) {
                char    buf[4096];

                sprintf(buf, ""could not allocate memory for a copy of %s"",
                    SpecsFileName);
                MR_make_aligned_string_copy(Problem, buf);
            } else {
                ssize_t num_bytes_read;

                num_bytes_read = read(spec_fd, spec_buf, stat_buf.st_size);
                if (num_bytes_read != stat_buf.st_size) {
                    char    buf[4096];

                    sprintf(buf, ""could not read in %s"", SpecsFileName);
                    MR_make_aligned_string_copy(Problem, buf);
                } else {
                    /* NULL terminate the string we have read in. */
                    spec_buf[num_bytes_read] = '\\0';
                    if (! MR_read_event_specs(spec_buf)) {
                        char    buf[4096];

                        sprintf(buf, ""could not parse %s"", SpecsFileName);
                        MR_make_aligned_string_copy(Problem, buf);
                    } else {
                        term_fp = fopen(TermFileName, ""w"");
                        if (term_fp == NULL) {
                            char    buf[4096];

                            sprintf(buf, ""could not open %s: %s"",
                                TermFileName, strerror(errno));
                            MR_make_aligned_string_copy(Problem, buf);
                        } else {
                            MR_print_event_specs(term_fp);
                            fclose(term_fp);

                            /*
                            ** Our caller tests Problem against the
                            ** empty string, not NULL.
                            */

                            MR_make_aligned_string_copy(Problem, """");
                        }
                    }
                }

                free(spec_buf);
            }
        }

        (void) close(spec_fd);
    }
").

%-----------------------------------------------------------------------------%

:- type event_spec_term
    --->    event_spec_term(
                event_name      :: string,
                event_num       :: int,
                event_linenum   :: int,
                event_attrs     :: list(event_attr_term)
            ).

:- type event_attr_term
    --->    event_attr_term(
                attr_name       :: string,
                attr_type       :: event_attr_type
            ).

:- type event_attr_type
    --->    event_attr_type_ordinary(
                event_attr_type_term
            )
    ;       event_attr_type_synthesized(
                event_attr_type_term,
                event_attr_synth_call
            )
    ;       event_attr_type_function.

:- type event_attr_type_term
    --->    event_attr_type_term(
                string,
                list(event_attr_type_term)
            ).

:- pred convert_list_to_spec_map(string::in, list(event_spec_term)::in,
    event_spec_map::in, event_spec_map::out,
    list(error_spec)::in, list(error_spec)::out) is det.

convert_list_to_spec_map(_, [], !EventSpecMap, !ErrorSpecs).
convert_list_to_spec_map(FileName, [SpecTerm | SpecTerms],
        !EventSpecMap, !ErrorSpecs) :-
    convert_term_to_spec_map(FileName, SpecTerm, !EventSpecMap, !ErrorSpecs),
    convert_list_to_spec_map(FileName, SpecTerms, !EventSpecMap, !ErrorSpecs).

:- pred convert_term_to_spec_map(string::in, event_spec_term::in,
    event_spec_map::in, event_spec_map::out,
    list(error_spec)::in, list(error_spec)::out) is det.

convert_term_to_spec_map(FileName, SpecTerm, !EventSpecMap, !ErrorSpecs) :-
    SpecTerm = event_spec_term(EventName, EventNumber, EventLineNumber,
        AttrTerms),

    % We convert the event_spec_term we have read in to the event_spec_map
    % table entry we need in three stages.
    %
    % Stage 1 is done by build_plain_type_map. This records the types of all
    % of the ordinary and synthesized attributes in AttrTypeMap0, builds up
    % KeyMap, which maps each attribute name to its relation_key in DepRel0,
    % and builds DepRel0, which at the end of stage 1 just contains one key
    % for each attribute with no relationships between them.
    %
    % Stage 2 is done by build_dep_map. This inserts into DepRel all the
    % dependencies of synthesized attributes on the attributes they are
    % synthesized from (including the attribute that provides the function).
    % It also computes the types of the function attributes that are used
    % to synthesize one or more other attributes.
    %
    % Stage 3, implemented by convert_terms_to_attrs, is the final pass.
    % It does the data format conversion, and performs the last checks.

    build_plain_type_map(EventName, FileName, EventLineNumber, AttrTerms,
        map.init, AttrTypeMap0, bimap.init, KeyMap, relation.init, DepRel0,
        !ErrorSpecs),
    build_dep_map(EventName, FileName, EventLineNumber, KeyMap, AttrTerms,
        AttrTypeMap0, AttrTypeMap, DepRel0, DepRel, !ErrorSpecs),
    convert_terms_to_attrs(EventName, FileName, EventLineNumber, AttrTypeMap,
        AttrTerms, [], RevVisAttrs, [], RevAllAttrs, !ErrorSpecs),
    ( relation.tsort(DepRel, _AttrOrder) ->
        % There is an order for computing the synthesized attributes.
        % XXX We should record this order for use by the debugger.
        true
    ;
        Pieces = [words("Circular dependency among"),
            words("the synthesized attributes of event"),
            quote(EventName), suffix("."), nl],
        CircErrorSpec = error_spec(severity_error, phase_term_to_parse_tree,
            [simple_msg(context(FileName, EventLineNumber),
                [always(Pieces)])]),
        !:ErrorSpecs = [CircErrorSpec | !.ErrorSpecs]
    ),
    list.reverse(RevVisAttrs, VisAttrs),
    list.reverse(RevAllAttrs, AllAttrs),
    EventSpec = event_spec(EventNumber, EventLineNumber, VisAttrs, AllAttrs),
    ( map.search(!.EventSpecMap, EventName, OldEventSpec) ->
        OldLineNumber = OldEventSpec ^ event_spec_linenum,
        Pieces1 = [words("Duplicate event specification for event"),
            quote(EventName), suffix("."), nl],
        Pieces2 = [words("The previous event specification is here."), nl],
        DuplErrorSpec = error_spec(severity_error, phase_term_to_parse_tree,
            [simple_msg(context(FileName, EventLineNumber), [always(Pieces1)]),
            simple_msg(context(FileName, OldLineNumber), [always(Pieces2)])]),
        !:ErrorSpecs = [DuplErrorSpec | !.ErrorSpecs]
    ;
        svmap.det_insert(EventName, EventSpec, !EventSpecMap)
    ).

:- type attr_type_map == map(string, mer_type).
:- type attr_dep_rel == relation(string).
:- type attr_key_map == bimap(string, relation_key).

    % See the big comment in convert_term_to_spec_map for the documentation
    % of this predicate.
    %
:- pred build_plain_type_map(string::in, string::in, int::in,
    list(event_attr_term)::in, attr_type_map::in, attr_type_map::out,
    attr_key_map::in, attr_key_map::out, attr_dep_rel::in, attr_dep_rel::out,
    list(error_spec)::in, list(error_spec)::out) is det.

build_plain_type_map(_, _, _, [], !AttrTypeMap, !KeyMap, !DepRel, !ErrorSpecs).
build_plain_type_map(EventName, FileName, LineNumber, [AttrTerm | AttrTerms],
        !AttrTypeMap, !KeyMap, !DepRel, !ErrorSpecs) :-
    AttrTerm = event_attr_term(AttrName, AttrTypeTerm),
    svrelation.add_element(AttrName, AttrKey, !DepRel),
    ( svbimap.insert(AttrName, AttrKey, !KeyMap) ->
        true
    ;
        Pieces = [words("Event"), quote(EventName),
            words("has more than one attribute named"),
            quote(AttrName), suffix("."), nl],
        ErrorSpec = error_spec(severity_error, phase_term_to_parse_tree,
            [simple_msg(context(FileName, LineNumber), [always(Pieces)])]),
        !:ErrorSpecs = [ErrorSpec | !.ErrorSpecs]
    ),
    (
        ( AttrTypeTerm = event_attr_type_ordinary(TypeTerm)
        ; AttrTypeTerm = event_attr_type_synthesized(TypeTerm, _SynthCall)
        ),
        Type = convert_term_to_type(TypeTerm),
        ( map.search(!.AttrTypeMap, AttrName, _OldType) ->
            % The error message has already been generated above.
            true
        ;
            svmap.det_insert(AttrName, Type, !AttrTypeMap)
        )
    ;
        AttrTypeTerm = event_attr_type_function
    ),
    build_plain_type_map(EventName, FileName, LineNumber, AttrTerms,
        !AttrTypeMap, !KeyMap, !DepRel, !ErrorSpecs).

    % See the big comment in convert_term_to_spec_map for the documentation
    % of this predicate.
    %
:- pred build_dep_map(string::in, string::in, int::in,
    attr_key_map::in, list(event_attr_term)::in,
    attr_type_map::in, attr_type_map::out, attr_dep_rel::in, attr_dep_rel::out,
    list(error_spec)::in, list(error_spec)::out) is det.

build_dep_map(_, _, _, _, [], !AttrTypeMap, !DepRel, !ErrorSpecs).
build_dep_map(EventName, FileName, LineNumber, KeyMap,
        [AttrTerm | AttrTerms], !AttrTypeMap, !DepRel, !ErrorSpecs) :-
    AttrTerm = event_attr_term(AttrName, AttrTypeTerm),
    bimap.lookup(KeyMap, AttrName, AttrKey),
    (
        AttrTypeTerm = event_attr_type_synthesized(_TypeTerm, SynthCall),
        SynthCall = event_attr_synth_call(FuncAttrName, ArgAttrs),
        record_arg_dependencies(EventName, FileName, LineNumber, KeyMap,
            AttrName, AttrKey, ArgAttrs, !DepRel, [], AttrErrorSpecs),
        (
            AttrErrorSpecs = [_ | _],
            !:ErrorSpecs = AttrErrorSpecs ++ !.ErrorSpecs
        ;
            AttrErrorSpecs = [],
            map.lookup(!.AttrTypeMap, AttrName, AttrType),
            ArgTypes = list.map(map.lookup(!.AttrTypeMap), ArgAttrs),
            FuncAttrType = higher_order_type(ArgTypes, yes(AttrType),
                purity_pure, lambda_normal),
            ( map.search(!.AttrTypeMap, FuncAttrName, OldFuncAttrType) ->
                ( FuncAttrType = OldFuncAttrType ->
                    % AttrTypeMap already contains the correct info.
                    true
                ;
                    % XXX Maybe we should give the types themselves.
                    Pieces = [words("Attribute"), quote(FuncAttrName),
                        words("is assigned inconsistent types"),
                        words("by synthesized attributes."), nl],
                    ErrorSpec = error_spec(severity_error,
                        phase_term_to_parse_tree,
                        [simple_msg(context(FileName, LineNumber),
                            [always(Pieces)])]),
                    !:ErrorSpecs = [ErrorSpec | !.ErrorSpecs]
                )
            ;
                svmap.det_insert(FuncAttrName, FuncAttrType, !AttrTypeMap)
            )
        )
    ;
        AttrTypeTerm = event_attr_type_ordinary(_TypeTerm)
    ;
        AttrTypeTerm = event_attr_type_function
    ),
    build_dep_map(EventName, FileName, LineNumber, KeyMap, AttrTerms,
        !AttrTypeMap, !DepRel, !ErrorSpecs).

:- pred record_arg_dependencies(string::in, string::in, int::in,
    attr_key_map::in, string::in, relation_key::in,
    list(string)::in, attr_dep_rel::in, attr_dep_rel::out,
    list(error_spec)::in, list(error_spec)::out) is det.

record_arg_dependencies(_, _, _, _, _, _, [], !DepRel, !ErrorSpecs).
record_arg_dependencies(EventName, FileName, LineNumber, KeyMap,
        FunctionAttrName, FunctionAttrKey, [AttrName | AttrNames],
        !DepRel, !ErrorSpecs) :-
    ( bimap.search(KeyMap, AttrName, AttrKey) ->
        svrelation.add(FunctionAttrKey, AttrKey, !DepRel)
    ;
        Pieces = [words("Attribute"), quote(FunctionAttrName),
            words("of event"), quote(EventName),
            words("uses nonexistent attribute"), quote(AttrName),
            words("in its synthesis."), nl],
        ErrorSpec = error_spec(severity_error, phase_term_to_parse_tree,
            [simple_msg(context(FileName, LineNumber), [always(Pieces)])]),
        !:ErrorSpecs = [ErrorSpec | !.ErrorSpecs]
    ),
    record_arg_dependencies(EventName, FileName, LineNumber, KeyMap,
        FunctionAttrName, FunctionAttrKey, AttrNames, !DepRel, !ErrorSpecs).

    % See the big comment in convert_term_to_spec_map for the documentation
    % of this predicate.
    %
:- pred convert_terms_to_attrs(string::in, string::in, int::in,
    attr_type_map::in, list(event_attr_term)::in,
    list(event_attribute)::in, list(event_attribute)::out,
    list(event_attribute)::in, list(event_attribute)::out,
    list(error_spec)::in, list(error_spec)::out) is det.

convert_terms_to_attrs(_, _, _, _, [], !RevVisAttrs, !RevAllAttrs,
        !ErrorSpecs).
convert_terms_to_attrs(EventName, FileName, LineNumber, AttrTypeMap,
        [AttrTerm | AttrTerms], !RevVisAttrs, !RevAllAttrs, !ErrorSpecs) :-
    AttrTerm = event_attr_term(AttrName, AttrTypeTerm),
    (
        AttrTypeTerm = event_attr_type_ordinary(_),
        map.lookup(AttrTypeMap, AttrName, AttrType),
        EventAttr = event_attribute(AttrName, AttrType, in_mode, no),
        !:RevVisAttrs = [EventAttr | !.RevVisAttrs],
        !:RevAllAttrs = [EventAttr | !.RevAllAttrs]
    ;
        AttrTypeTerm = event_attr_type_synthesized(_, SynthCall),
        map.lookup(AttrTypeMap, AttrName, AttrType),
        EventAttr = event_attribute(AttrName, AttrType, in_mode,
            yes(SynthCall)),
        !:RevAllAttrs = [EventAttr | !.RevAllAttrs]
    ;
        AttrTypeTerm = event_attr_type_function,
        ( map.search(AttrTypeMap, AttrName, AttrType) ->
            EventAttr = event_attribute(AttrName, AttrType, in_mode, no),
            !:RevVisAttrs = [EventAttr | !.RevVisAttrs],
            !:RevAllAttrs = [EventAttr | !.RevAllAttrs]
        ;
            Pieces = [words("Event"), quote(EventName),
                words("does not use the function attribute"),
                quote(AttrName), suffix("."), nl],
            ErrorSpec = error_spec(severity_error, phase_term_to_parse_tree,
                [simple_msg(context(FileName, LineNumber), [always(Pieces)])]),
            !:ErrorSpecs = [ErrorSpec | !.ErrorSpecs]
        )
    ),
    convert_terms_to_attrs(EventName, FileName, LineNumber, AttrTypeMap,
        AttrTerms, !RevVisAttrs, !RevAllAttrs, !ErrorSpecs).

:- func convert_term_to_type(event_attr_type_term) = mer_type.

convert_term_to_type(Term) = Type :-
    Term = event_attr_type_term(Name, Args),
    (
        Args = [],
        builtin_type_to_string(BuiltinType, Name)
    ->
        Type = builtin_type(BuiltinType)
    ;
        SymName = string_to_sym_name(Name),
        ArgTypes = list.map(convert_term_to_type, Args),
        Type = defined_type(SymName, ArgTypes, kind_star)
    ).

%-----------------------------------------------------------------------------%

event_set_description(EventSpecMap) = Desc :-
    map.to_assoc_list(EventSpecMap, EventSpecList),
    list.sort(compare_event_specs_by_num, EventSpecList, SortedEventSpecList),
    DescStrings = list.map(describe_event_spec, SortedEventSpecList),
    string.append_list(DescStrings, Desc).

:- pred compare_event_specs_by_num(
    pair(string, event_spec)::in, pair(string, event_spec)::in,
    comparison_result::out) is det.

compare_event_specs_by_num(_NameA - SpecA, _NameB - SpecB, Result) :-
    compare(Result, SpecA ^ event_spec_num, SpecB ^ event_spec_num).

:- func describe_event_spec(pair(string, event_spec)) = string.

describe_event_spec(Name - Spec) = Desc :-
    Spec = event_spec(_EventNumber, _EventLineNumber, _VisAttrs, AllAttrs),
    AttrDescs = string.join_list(",\n",
        list.map(describe_event_attr, AllAttrs)),
    Desc = "event " ++ Name ++ "(" ++ AttrDescs ++ ")".

:- func describe_event_attr(event_attribute) = string.

describe_event_attr(Attr) = Desc :-
    Attr = event_attribute(Name, Type, _Mode, MaybeSynthCall),
    TypeDesc = describe_attr_type(Type),
    (
        MaybeSynthCall = no,
        SynthCallDesc = ""
    ;
        MaybeSynthCall = yes(SynthCall),
        SynthCall = event_attr_synth_call(FuncAttrName, ArgAttrNames),
        ArgAttrDesc = string.join_list(", ", ArgAttrNames),
        SynthCallDesc = "synthesized by " ++
            FuncAttrName ++ "(" ++ ArgAttrDesc ++ ")"
    ),
    Desc = Name ++ ": " ++ TypeDesc ++ SynthCallDesc.

:- func describe_attr_type(mer_type) = string.

describe_attr_type(Type) = Desc :-
    (
        Type = defined_type(SymName, ArgTypes, Kind),
        expect(unify(Kind, kind_star), this_file,
            "describe_attr_type: not kind_star"),
        ArgTypeDescs = string.join_list(", ",
            list.map(describe_attr_type, ArgTypes)),
        Desc = sym_name_to_string(SymName) ++ "(" ++ ArgTypeDescs ++ ")"
    ;
        Type = builtin_type(BuiltinType),
        builtin_type_to_string(BuiltinType, Desc)
    ;
        Type = higher_order_type(_, _, _, _),
        Desc = "function"
    ;
        ( Type = type_variable(_, _)
        ; Type = tuple_type(_, _)
        ; Type = apply_n_type(_, _, _)
        ; Type = kinded_type(_, _)
        ),
        unexpected(this_file,
            "describe_attr_type: type not constructed by prog_event")
    ).

%-----------------------------------------------------------------------------%

event_number(EventSpecMap, EventName, EventNumber) :-
    map.search(EventSpecMap, EventName, EventSpec),
    EventNumber = EventSpec ^ event_spec_num.

event_arg_names(EventSpecMap, EventName, ArgNames) :-
    map.search(EventSpecMap, EventName, EventSpec),
    ArgInfos = EventSpec ^ event_spec_visible_attrs,
    ArgNames = list.map(project_event_arg_name, ArgInfos).

event_arg_types(EventSpecMap, EventName, ArgTypes) :-
    map.search(EventSpecMap, EventName, EventSpec),
    ArgInfos = EventSpec ^ event_spec_visible_attrs,
    ArgTypes = list.map(project_event_arg_type, ArgInfos).

event_arg_modes(EventSpecMap, EventName, ArgModes) :-
    map.search(EventSpecMap, EventName, EventSpec),
    ArgInfos = EventSpec ^ event_spec_visible_attrs,
    ArgModes = list.map(project_event_arg_mode, ArgInfos).

:- func project_event_arg_name(event_attribute) = string.

project_event_arg_name(Attribute) = Attribute ^ attr_name.

:- func project_event_arg_type(event_attribute) = mer_type.

project_event_arg_type(Attribute) = Attribute ^ attr_type.

:- func project_event_arg_mode(event_attribute) = mer_mode.

project_event_arg_mode(Attribute) = Attribute ^ attr_mode.

%-----------------------------------------------------------------------------%

:- func this_file = string.

this_file = "event_spec.m".

%-----------------------------------------------------------------------------%

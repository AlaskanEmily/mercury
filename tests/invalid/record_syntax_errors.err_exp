record_syntax_errors.m:023: Error: mode declaration for function `record_syntax_errors:field8/1'
record_syntax_errors.m:023:   without preceding `func' declaration.
record_syntax_errors.m:028: In DCG field update goal:
record_syntax_errors.m:028:   error: expected field name at term `Field'.
record_syntax_errors.m:031: Error: expected `Field =^ field1 ^ ... ^ fieldN'
record_syntax_errors.m:031:   or `^ field1 ^ ... ^ fieldN := Field'.
record_syntax_errors.m:031:   in DCG field access goal.
record_syntax_errors.m:048: Error: clause for predicate `record_syntax_errors:term_type_error/1'
record_syntax_errors.m:048:   without preceding `pred' declaration.
record_syntax_errors.m:054: In declaration of
record_syntax_errors.m:054:   function `record_syntax_errors:field4/1':
record_syntax_errors.m:054:   error: a field access function for an exported
record_syntax_errors.m:054:   field must also be exported.
record_syntax_errors.m:057: Error: clause for automatically generated field
record_syntax_errors.m:057:   access function `record_syntax_errors:field4/1'.
record_syntax_errors.m:057:   Clauses for field access functions are
record_syntax_errors.m:057:   automatically generated by the compiler. To
record_syntax_errors.m:057:   supply your own definition for a field access
record_syntax_errors.m:057:   function, for example to check the input to a
record_syntax_errors.m:057:   field update, give the field of the constructor a
record_syntax_errors.m:057:   different name.
record_syntax_errors.m:014: Error: no clauses for
record_syntax_errors.m:014:   predicate `record_syntax_errors:dcg_syntax/2'.
record_syntax_errors.m:016: Error: no clauses for
record_syntax_errors.m:016:   predicate `record_syntax_errors:dcg_syntax_2/2'.
record_syntax_errors.m:042: In clause for predicate `record_syntax_errors:construct_exist_cons/1':
record_syntax_errors.m:042:   error: invalid field update `field2:=/2':
record_syntax_errors.m:005:   existentially quantified type variable `T' occurs
record_syntax_errors.m:005:   in the types of field `field2' and some other field
record_syntax_errors.m:005:   in definition of constructor `record_syntax_errors:exist_cons/3 '.
record_syntax_errors.m:046: In clause for predicate `record_syntax_errors:arg_type_error/1':
record_syntax_errors.m:046:   in argument 2 of functor `field6:=/2':
record_syntax_errors.m:046:   in argument 2 of functor `field7:=/2':
record_syntax_errors.m:046:   type error in unification of argument
record_syntax_errors.m:046:   and constant `"invalid value"'.
record_syntax_errors.m:046:   argument has type `int',
record_syntax_errors.m:046:   constant `"invalid value"' has type `string'.
	The partial type assignment was:
	HeadVar__1 :: (record_syntax_errors:cons)
	Cons :: (record_syntax_errors:cons)
	Cons0 :: (record_syntax_errors:cons)
	V_4 :: int
	V_5 :: (record_syntax_errors:cons2)
	V_6 :: (record_syntax_errors:cons2)
	V_7 :: int
	V_8 :: int
	V_9 :: (record_syntax_errors:cons2)
	V_10 :: int
	V_11 :: int

record_syntax_errors.m:050: In clause for predicate `record_syntax_errors:term_type_error/1':
record_syntax_errors.m:050:   in argument 2 of functor `field6:=/2':
record_syntax_errors.m:050:   in unification of argument
record_syntax_errors.m:050:   and term `'field4:='(V_5, V_4)':
record_syntax_errors.m:050:   type error in argument(s) of functor `field4:=/2'.
record_syntax_errors.m:050:   Argument 1 has type `(record_syntax_errors:cons2)',
record_syntax_errors.m:050:   expected type was `(record_syntax_errors:cons)'.
record_syntax_errors.m:023: Inferred :- func field8((record_syntax_errors:cons2)) = int.

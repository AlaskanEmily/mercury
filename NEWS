NEWS for Mercury release 0.6
----------------------------

* We now specialize calls to higher-order predicates within the same module
  in the case when the higher-order arguments have known values.
  This optimization is enabled by the `--optimize-higher-order' option.
  (XXX Unfortunately, this optimization has some bugs, so it is not
  enabled by default.)

* We now specialize calls to predicates within the same module which have
  unused arguments.  This often happens for polymorphic predicates, since
  the compiler introduces type_info arguments which are often unused.
  This optimization is enabled by the `--optimize-unused-args' option.
  (XXX Unfortunately, this optimization has some bugs, so it is not
  enabled by default.)

* There's a new option `--optimize-dead-proc' option to eliminate unused
  procedures within a module.  This is useful even if the original source
  code didn't contain any unused procedures, since inlining and specialization
  can mean that the original version of a procedure is no longer used.

* There's a new option `--split-c-files' which causes the compiler to put
  each C function in its own C file, so that the linker can link in only
  what is used, and a new Mmake target `foo.split' for
  building a version of `foo' compiled with `--split-c-files'.
  (`--split-c-files' has much the same effect as `--optimize-dead-proc',
  except that it works globally, not just within a module.)
  On platforms for which we don't support shared libraries, installing
  a split version of the Mercury library fixes the problem of dumb Unix
  linkers dragging in nearly the entire library even if most of it is
  unused, and so reduces the size of a hello world program from >400k
  to around 120k.

* The getopt library is now more flexible. It can handle command line switches
  (such as -O2) that affect the values of many options, and it can handle
  long options that specify a value after an equal sign, in the GNU style
  (e.g. --optimization-level=2).

* We have renamed the varset__lookup predicates to varset__search in order to
  conform to our general naming convention.

* We have removed (the undocumented) list__map_maybe/3.

* We have added a few new predicates using higher order facilities:
	list__map/3, list__filter/3, list__filter/4, list__foldl/4,
	list__foldr/4, list__sort/4 and list__merge/4 in list.m
	and maybe_pred/3 in std_util.m.
	See the library reference manual for details.

* There are quite a few changes to the graph module. The interface has been
  made more consistent with the rest of the library. The predicate
  graph__lookup_node/3 has been replaced by two predicates: graph__search_node/3
  which is nondet and returns all the nodes with matching data, and
  graph__find_matching_nodes/3 which is det and returns all the nodes with
  matching data.

* The code generator generates special code for dense switches in which all
  the output variables are constant terms. Instead of generating a dense jump
  table, it now generates an set of arrays of answers (one array for each output
  variable). For predicates that convert between enumerations and integers,
  etc, this is a significant improvement.

* Various other minor improvements:

  - You can now use `-O <n>' to select an optimization level between 0 and 5.

  - You can now use `--optimize-space' to select optimization for space, instead
    of optimization for time (which is the default).

  - The code generator now emits better code for constructing deeply nested
    terms.

  - The value numbering optimization now processes even code sequences
    containing several heap allocations.

  - The `--pred-value-number' option now works. If it is given, and
    value numbering notices that a value is available from a location
    that is faster to access than the one from which another code
    sequence retrieves the value, this other code sequence will be
    reoptimized taking this into account.


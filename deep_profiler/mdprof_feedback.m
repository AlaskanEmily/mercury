%-----------------------------------------------------------------------------%
% vim: ft=mercury ts=4 sw=4 et
%-----------------------------------------------------------------------------%
% Copyright (C) 2006-2008 The University of Melbourne.
% This file may only be copied under the terms of the GNU General
% Public License - see the file COPYING in the Mercury distribution.
%-----------------------------------------------------------------------------%
%
% File: mdprof_feedback.m.
% Author: tannier, pbone.
%
% This module contains the code for writing to a file the CSSs whose CSDs' 
% mean/median call sequence counts (own and desc) exceed the given threshold.
% 
% The generated file will then be used by the compiler for implicit parallelism.
%
%-----------------------------------------------------------------------------%

:- module mdprof_feedback.
:- interface.

:- import_module io.

%-----------------------------------------------------------------------------%

:- pred main(io::di, io::uo) is det.

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

:- implementation.

:- import_module conf.
:- import_module dump.
:- import_module mdbcomp.
:- import_module mdbcomp.feedback.
:- import_module mdbcomp.program_representation.
:- import_module measurements.
:- import_module profile.
:- import_module startup.

:- import_module array.
:- import_module bool.
:- import_module char.
:- import_module getopt.
:- import_module int.
:- import_module library.
:- import_module list.
:- import_module map.
:- import_module maybe.
:- import_module require.
:- import_module string.

%-----------------------------------------------------------------------------%

main(!IO) :-
    io.progname_base("mdprof_feedback", ProgName, !IO),
    io.command_line_arguments(Args0, !IO),
    getopt.process_options(option_ops_multi(short, long, defaults),
        Args0, Args, MaybeOptions),
    (
        MaybeOptions = ok(Options),
        lookup_bool_option(Options, help, Help),
        lookup_bool_option(Options, version, Version),
        lookup_string_option(Options, program_name, ProfileProgName0),
        ProfileProgName = string.strip(ProfileProgName0),
        ( Version = yes ->
            write_version_message(ProgName, !IO)
        ; 
            ( Help = yes
            ; ProfileProgName = "" )
        ->
            write_help_message(ProgName, !IO)
        ; 
            ( Args = [Input, Output] ->
                lookup_string_option(Options, measure, Measure),
                ( construct_measure(Measure, MeasureType) ->
                    lookup_int_option(Options, threshold, Threshold),
                    lookup_bool_option(Options, verbose, Verbose),
                    lookup_accumulating_option(Options, dump_stages,
                        DumpStages),
                    lookup_accumulating_option(Options, dump_options,
                        DumpArrayOptionStrs),
                    dump_array_options_to_dump_options(DumpArrayOptionStrs,
                        DumpOptions),
                    read_deep_file(Input, Verbose, DumpStages, DumpOptions,
                        MaybeProfile, !IO),
                    (
                        MaybeProfile = ok(Deep),
                        compute_css_list_above_threshold(0, Deep, Threshold, 
                            MeasureType, [], CSSListAboveThreshold),
                        generate_feedback_file(CSSListAboveThreshold, Deep,
                            ProfileProgName, MeasureType, Threshold, Output,
                            !IO)
                    ;
                        MaybeProfile = error(Error),
                        io.stderr_stream(Stderr, !IO),
                        io.set_exit_status(1, !IO),
                        io.format(Stderr, "%s: error reading deep file: %s\n",
                            [s(ProgName), s(Error)], !IO)
                    )   
                ;
                    io.set_exit_status(1, !IO),
                    write_help_message(ProgName, !IO)
                )
            ;
                io.set_exit_status(1, !IO),
                write_help_message(ProgName, !IO)
            )
        )
    ;
        MaybeOptions = error(Msg),
        io.stderr_stream(Stderr, !IO),
        io.set_exit_status(1, !IO),
        io.format(Stderr, "%s: error parsing options: %s\n",
            [s(ProgName), s(Msg)], !IO)
    ).

:- pred write_help_message(string::in, io::di, io::uo) is det.

write_help_message(ProgName, !IO) :- 
    Message0 = [
        "Usage: %s --program-name <ProgName> [<options>] <input> <output>",
        "    <input> must name a deep profiling data file.",
        "    <output> is the file generated by this program.",
        "    You may specify the following options:",
        "    --help      Generate this help message.",
        "    --version   Report the program's version number.",
        "    --verbose   Generate progress messages.",
        "    --threshold <value>",
        "                Set the threshold to <value>.",
        "    --measure mean|median",
        "                mean : Write to <output> the call sites",
        "                static whose call sites dynamic's mean",
        "                call sequence counts exceed the given",
        "                threshold (default option).",
        "                median : Write to <output> the call sites",
        "                static whose call sites dynamic's median",
        "                call sequence counts exceed the given",
        "                threshold.",
        "    --program-name <name>",
        "                The name of the program that generated the",
        "                profiling data.  This is stored in the",
        "                feedback file"],
    string.join_list("\n", Message0) = Message,
    io.format(Message, [s(ProgName)], !IO).

:- pred write_version_message(string::in, io::di, io::uo) is det.

write_version_message(ProgName, !IO) :-
    library.version(Version),
    io.write_string(ProgName, !IO),
    io.write_string(": Mercury deep profiler", !IO),
    io.nl(!IO),
    io.write_string(Version, !IO),
    io.nl(!IO).

%-----------------------------------------------------------------------------%

    % Read a deep profiling data file.
    % 
:- pred read_deep_file(string::in, bool::in,
    list(string)::in, dump_options::in,
    maybe_error(deep)::out, io::di, io::uo) is det.

read_deep_file(Input, Verbose, DumpStages, DumpOptions, MaybeProfile, !IO) :-
    server_name_port(Machine, !IO),
    script_name(ScriptName, !IO),
    (
        Verbose = yes,
        io.stdout_stream(Stdout, !IO),
        MaybeOutput = yes(Stdout)
    ;
        Verbose = no,
        MaybeOutput = no
    ),
    read_and_startup(Machine, ScriptName, [Input], no, MaybeOutput,
        DumpStages, DumpOptions, MaybeProfile, !IO).

    % Determine those CSSs whose CSDs' average/median call sequence counts 
    % exceed the given threshold.
    % 
:- pred compute_css_list_above_threshold(int::in, deep::in, int::in, 
    stat_measure::in, list(call_site_static)::in, 
    list(call_site_static)::out) is det.

compute_css_list_above_threshold(Index, Deep, Threshold, Measure,
        !CSSAcc) :-
    array.size(Deep ^ call_site_statics, Size),
    ( Index = Size ->
        true
    ;
        CallSiteCall = array.lookup(Deep ^ call_site_calls, Index),
        CSDListList = map.values(CallSiteCall),
        CSDList = list.condense(CSDListList),
        list.length(CSDList, NumCSD),
        ( NumCSD = 0 ->
            % The CSS doesn't have any CSDs.
            Callseqs = 0
        ;
            ( 
                Measure = stat_mean,
                list.foldr(sum_callseqs_csd_ptr(Deep), CSDList,
                    0, SumCallseqs),
                % NOTE: we have checked that NumCSD is not zero above.
                Callseqs = SumCallseqs // NumCSD
            ;
                Measure = stat_median,
                list.sort(compare_csd_ptr(Deep), CSDList, CSDListSorted),
                IndexMedian = NumCSD // 2,
                list.index0_det(CSDListSorted, IndexMedian, MedianPtr),
                sum_callseqs_csd_ptr(Deep, MedianPtr, 0, Callseqs)
            )
        ),
        ( Callseqs >= Threshold ->
            CSS = array.lookup(Deep ^ call_site_statics, Index),
            list.append(!.CSSAcc, [CSS], !:CSSAcc),
            compute_css_list_above_threshold(Index + 1, Deep, Threshold, 
                Measure, !CSSAcc)
        ;
            compute_css_list_above_threshold(Index + 1, Deep, Threshold, 
                Measure, !CSSAcc)
        ) 
    ).

    % Add the call sequence counts (own and desc) of CSDPtr to the accumulator.
    % 
:- pred sum_callseqs_csd_ptr(deep::in, call_site_dynamic_ptr::in,
    int::in, int::out) is det.

sum_callseqs_csd_ptr(Deep, CSDPtr, !Sum) :-
    lookup_call_site_dynamics(Deep ^ call_site_dynamics, CSDPtr, CSD),
    lookup_csd_desc(Deep ^ csd_desc, CSDPtr, IPO),
    !:Sum = !.Sum + callseqs(CSD ^ csd_own_prof) + inherit_callseqs(IPO).

    % Compare two CSD pointers on the basis of their call sequence counts 
    % (own and desc).
    % 
:- pred compare_csd_ptr(deep::in, call_site_dynamic_ptr::in, 
    call_site_dynamic_ptr::in, comparison_result::out) is det.

compare_csd_ptr(Deep, CSDPtrA, CSDPtrB, Result) :-
    sum_callseqs_csd_ptr(Deep, CSDPtrA, 0, SumA),
    sum_callseqs_csd_ptr(Deep, CSDPtrB, 0, SumB),
    compare(Result, SumA, SumB).

    % Generate a profiling feedback file that contains the CSSs whose CSDs' 
    % mean/median call sequence counts (own and desc) exceed the given 
    % threshold. 
    % 
:- pred generate_feedback_file(list(call_site_static)::in, deep::in, string::in,
    stat_measure::in, int::in, string::in, io::di, io::uo) is det.

generate_feedback_file(CSSList, Deep, ProgName, StatMeasure, Threshold, Output,
    !IO) :-
    some [!Feedback]
    (
        feedback.read_or_create(Output, !:Feedback, !IO),
        map(css_to_call(Deep), CSSList, Calls), 
        FeedbackData = feedback_data_calls_above_threshold_sorted(Threshold,
            StatMeasure, Calls),
        FeedbackType = feedback_type_calls_above_threshold_sorted, 
        put_feedback_data(FeedbackType, FeedbackData, !Feedback),
        write_feedback_file(Output, ProgName, !.Feedback, WriteResult, !IO)
    ),
    (
        WriteResult = ok
    ;
        ( WriteResult = open_error(Error)
        ; WriteResult = write_error(Error) ),
        io.error_message(Error, ErrorMessage),
        io.format("%s: %s\n", [s(Output), s(ErrorMessage)], !IO),
        io.set_exit_status(1, !IO)
    ).

    % Write to the output the list of CSSs.     
    % 
:- pred css_to_call(deep::in, call_site_static::in, call_site::out) is det.
   
css_to_call(Deep, CSS, Call) :-
    % Get the caller.
    lookup_proc_statics(Deep ^ proc_statics, CSS ^ css_container, CallerPS),
    Caller = CallerPS ^ ps_id,    

    % Get the slot number.
    Slot = CSS ^ css_slot_num,
    
    % Get the Callee and Call Type.
    (
        CSS ^ css_kind = normal_call_and_callee(PSPtr, _),
        lookup_proc_statics(Deep ^ proc_statics, PSPtr, CalleePS),
        CallTypeAndCallee = plain_call(CalleePS ^ ps_id)
    ;
        CSS ^ css_kind = special_call_and_no_callee,
        CallTypeAndCallee = special_call
    ;
        CSS ^ css_kind = higher_order_call_and_no_callee,
        CallTypeAndCallee = higher_order_call
    ;
        CSS ^ css_kind = method_call_and_no_callee,
        CallTypeAndCallee = method_call
    ;
        CSS ^ css_kind = callback_and_no_callee,
        CallTypeAndCallee = callback_call
    ),
   
    % Build the call datastructure.
    Call = call_site(Caller, Slot, CallTypeAndCallee).

%-----------------------------------------------------------------------------%

:- type option
    --->    threshold
    ;       help
    ;       verbose
    ;       version
    ;       measure
    ;       program_name
    ;       dump_stages
    ;       dump_options.

:- type option_table == option_table(option).

:- pred short(char::in, option::out) is semidet.

short('V',  verbose).
short('t',  threshold).
short('h',  help).
short('v',  version).
short('m',  measure).
short('p',  program_name).
short('d',  dump_stages).
short('D',  dump_options).

:- pred long(string::in, option::out) is semidet.

long("threshold",           threshold).
long("help",                help).
long("verbose",             verbose).
long("version",             version).
long("measure",             measure).
long("program-name",        program_name).
long("dump-stages",         dump_stages).
long("dump-options",        dump_options).

:- pred defaults(option::out, option_data::out) is multi.

defaults(threshold,         int(100000)).
defaults(help,              bool(no)).
defaults(verbose,           bool(no)).
defaults(version,           bool(no)).
defaults(measure,           string("mean")).
defaults(program_name,      string("")).
defaults(dump_stages,       accumulating([])).
defaults(dump_options,      accumulating([])).

:- pred construct_measure(string::in, stat_measure::out) is semidet.

construct_measure("mean",       stat_mean).
construct_measure("median",     stat_median).

%-----------------------------------------------------------------------------%
:- end_module mdprof_feedback.
%-----------------------------------------------------------------------------%

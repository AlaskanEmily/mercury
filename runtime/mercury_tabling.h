/*
** Copyright (C) 1997-1998 The University of Melbourne.
** This file may only be copied under the terms of the GNU Library General
** Public License - see the file COPYING.LIB in the Mercury distribution.
*/

/*
** mercury_tabling.h - definitions of some basic macros used by the tabling
** code generated by the Mercury compiler and by the Mercury runtime.
*/

#ifndef	MERCURY_TABLING_H
#define	MERCURY_TABLING_H

typedef Word	**TrieNode;
typedef Word	**AnswerBlock;

#include "mercury_table_enum.h"
#include "mercury_table_any.h"
#include "mercury_table_type_info.h"
#include "mercury_table_builtins.h"

#define MR_RAW_TABLE_ANY(Table, TypeInfo, Value)			\
	MR_table_type(Table, (Word *) TypeInfo, Value)

#define MR_RAW_TABLE_TAG(Table, Tag)					\
	MR_int_index_lookup_or_add(Table, 1 << TAGBITS, Tag)

#define MR_RAW_TABLE_ENUM(Table, Range, Value)				\
	MR_int_index_lookup_or_add(Table, Range, Value)

#define MR_RAW_TABLE_WORD(Table, Value)					\
	MR_int_hash_lookup_or_add(Table, (Integer) Value);

#define MR_RAW_TABLE_INT(Table, Value)					\
	MR_int_hash_lookup_or_add(Table, Value);

#define MR_RAW_TABLE_CHAR(Table, Value)					\
	MR_int_hash_lookup_or_add(Table, (Integer) Value);

#define MR_RAW_TABLE_FLOAT(Table, Value)				\
	MR_float_hash_lookup_or_add(Table, Value);

#define MR_RAW_TABLE_STRING(Table, Value)	 			\
	MR_string_hash_lookup_or_add(Table, (String) Value);

#define MR_RAW_TABLE_TYPE_INFO(Table, Type)				\
	MR_type_info_lookup_or_add(Table, (Word *) Type)

#ifdef	MR_TABLE_DEBUG

#define	MR_DEBUG_NEW_TABLE_ANY(table, table0, type_info, value)		\
	do {								\
		(table) = (Word) MR_RAW_TABLE_ANY((Word **) (table0),	\
					(type_info), (value));		\
		if (MR_tabledebug) {					\
			printf("TABLE %p: any %x type %p => %p\n",	\
				(Word **) (table0), (value), 		\
				(Word **) (type_info), (Word **) (table));\
		}							\
	} while (0)
#define	MR_DEBUG_TABLE_ANY(table, type_info, value)			\
	do {								\
		TrieNode prev_table = (table);				\
		(table) = (Word **) MR_RAW_TABLE_ANY((table), 		\
					(type_info), (value));		\
		if (MR_tabledebug) {					\
			printf("TABLE %p: any %x type %p => %p\n",	\
				(table), (value), (type_info),		\
				prev_table);				\
		}							\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_TAG(table, table0, value)			\
	do {								\
		(table) = (Word) MR_RAW_TABLE_TAG((Word **) (table0),	\
					(value));			\
		if (MR_tabledebug) {					\
			printf("TABLE %p: tag %d => %p\n", 		\
				(Word **) (table0), (value), 		\
				(Word **) (table))			\
		}							\
	} while (0)
#define	MR_DEBUG_TABLE_TAG(table, value)				\
	do {								\
		TrieNode prev_table = (table);				\
		(table) = (Word **) MR_RAW_TABLE_TAG((table), (value));	\
		if (MR_tabledebug) {					\
			printf("TABLE %p: tag %d => %p\n", (table), 	\
				(value), prev_table);			\
		}							\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_ENUM(table, table0, count, value)		\
	do {								\
		(table) = (Word) MR_RAW_TABLE_ENUM((Word **) (table0),	\
					(count), (value));		\
		if (MR_tabledebug) {					\
			printf("TABLE %p: enum %d of %d => %p\n", 	\
				(Word **) (table0), (value), (count),	\
				(Word **) (table));			\
		}							\
	} while (0)
#define	MR_DEBUG_TABLE_ENUM(table, count, value)			\
	do {								\
		TrieNode prev_table = (table);				\
		(table) = (Word **) MR_RAW_TABLE_ENUM((table), (count),	\
					(value));			\
		if (MR_tabledebug) {					\
			printf("TABLE %p: enum %d of %d => %p\n", 	\
				(table), (value), (count), prev_table);	\
		}							\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_WORD(table, table0, value)			\
	do {								\
		(table) = (Word) MR_RAW_TABLE_WORD((Word **) (table0),	\
					(value));			\
		if (MR_tabledebug) {					\
			printf("TABLE %p: word %d => %p\n",		\
				(Word **) (table0), (value),		\
				(Word **) (table));			\
		}							\
	} while (0)
#define	MR_DEBUG_TABLE_WORD(table, value)				\
	do {								\
		TrieNode prev_table = (table);				\
		(table) = (Word **) MR_RAW_TABLE_WORD((table), (value));\
		if (MR_tabledebug) {					\
			printf("TABLE %p: word %d => %p\n",		\
				(table), (value), prev_table);		\
		}							\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_INT(table, table0, value)			\
	do {								\
		(table) = (Word) MR_RAW_TABLE_INT((Word **) (table0),	\
					(value));			\
		if (MR_tabledebug) {					\
			printf("TABLE %p: int %d => %p\n",		\
				(Word **) (table0), (value),		\
				(Word **) (table));			\
		}							\
	} while (0)
#define	MR_DEBUG_TABLE_INT(table, value)				\
	do {								\
		TrieNode prev_table = (table);				\
		(table) = (Word **) MR_RAW_TABLE_INT((table), (value));	\
		if (MR_tabledebug) {					\
			printf("TABLE %p: int %d => %p\n",		\
				(table), (value), prev_table);		\
		}							\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_CHAR(table, table0, value)			\
	do {								\
		(table) = (Word) MR_RAW_TABLE_CHAR((Word **) (table0),	\
					(value));			\
		if (MR_tabledebug) {					\
			printf("TABLE %p: char `%c'/%d => %p\n",	\
				(Word **) (table0), (int) (value),	\
				(int) (value), (Word **) (table));	\
		}							\
	} while (0)
#define	MR_DEBUG_TABLE_CHAR(table, value)				\
	do {								\
		TrieNode prev_table = (table);				\
		(table) = (Word **) MR_RAW_TABLE_CHAR((table), (value));\
		if (MR_tabledebug) {					\
			printf("TABLE %p: char `%c'/%d => %p\n",	\
				(table), (int) (value), (int) (value),	\
				prev_table);				\
		}							\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_FLOAT(table, table0, value)			\
	do {								\
		(table) = (Word) MR_RAW_TABLE_FLOAT((Word **) (table0),	\
					(value));			\
		if (MR_tabledebug) {					\
			printf("TABLE %p: float %f => %p\n",		\
				(Word **) (table0), value,		\
				(Word **) (table));			\
		}							\
	} while (0)
#define	MR_DEBUG_TABLE_FLOAT(table, value)				\
	do {								\
		TrieNode prev_table = (table);				\
		(table) = (Word **) MR_RAW_TABLE_FLOAT((table), (value));\
		if (MR_tabledebug) {					\
			printf("TABLE %p: float %f => %p\n",		\
				(table), (double) word_to_float(value),	\
				prev_table);				\
		}							\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_STRING(table, table0, value)			\
	do {								\
		(table) = (Word) MR_RAW_TABLE_STRING((Word **) (table0),\
					(value));			\
		if (MR_tabledebug) {					\
			printf("TABLE %p: string `%s' => %p\n",		\
				(Word **) (table), (char *) (value),	\
				(Word **) (table));			\
		}							\
	} while (0)
#define	MR_DEBUG_TABLE_STRING(table, value)				\
	do {								\
		TrieNode prev_table = (table);				\
		(table) = (Word **) MR_RAW_TABLE_STRING((table), (value));\
		if (MR_tabledebug) {					\
			printf("TABLE %p: string `%s' => %p\n",		\
				(table), (char *) (value), prev_table);	\
		}							\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_TYPEINFO(table, table0, value)		\
	do {								\
		(table) = (Word) MR_RAW_TABLE_TYPE_INFO((Word **) (table0),\
					(value));			\
		if (MR_tabledebug) {					\
			printf("TABLE %p: typeinfo %p => %p\n",		\
				(Word **) (table), (Word **) (value), 	\
				(Word **) (table));			\
		}							\
	} while (0)
#define	MR_DEBUG_TABLE_TYPEINFO(table, value)				\
	do {								\
		TrieNode prev_table = (table);				\
		(table) = (Word **) MR_RAW_TABLE_TYPE_INFO((table), (value));\
		if (MR_tabledebug) {					\
			printf("TABLE %p: typeinfo %p => %p\n",		\
				(table), (value), prev_table);		\
		}							\
	} while (0)

#else	/* not MR_TABLE_DEBUG */

#define	MR_DEBUG_NEW_TABLE_ANY(table, table0, type_info, value)		\
	do {								\
		(table) = (Word) MR_RAW_TABLE_ANY((Word **) (table0),	\
					(type_info), (value));		\
	} while (0)
#define	MR_DEBUG_TABLE_ANY(table, type_info, value)			\
	do {								\
		(table) = (Word **) MR_RAW_TABLE_ANY((table),		\
					(type_info), (value));		\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_TAG(table, table0, value)			\
	do {								\
		(table) = (Word) MR_RAW_TABLE_TAG((Word **) (table0),	\
					(value));			\
	} while (0)
#define	MR_DEBUG_TABLE_TAG(table, value)				\
	do {								\
		(table) = (Word **) MR_RAW_TABLE_TAG((table), (value));	\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_ENUM(table, table0, count, value)		\
	do {								\
		(table) = (Word) MR_RAW_TABLE_ENUM((Word **) (table0),	\
					(count), (value));		\
	} while (0)
#define	MR_DEBUG_TABLE_ENUM(table, count, value)			\
	do {								\
		(table) = (Word **) MR_RAW_TABLE_ENUM((table), (count),	\
					(value));			\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_WORD(table, table0, value)			\
	do {								\
		(table) = (Word) MR_RAW_TABLE_WORD((Word **) (table0),	\
					(value));			\
	} while (0)
#define	MR_DEBUG_TABLE_WORD(table, value)				\
	do {								\
		(table) = (Word **) MR_RAW_TABLE_WORD((table), (value));\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_INT(table, table0, value)			\
	do {								\
		(table) = (Word) MR_RAW_TABLE_INT((Word **) (table0),	\
					(value));			\
	} while (0)
#define	MR_DEBUG_TABLE_INT(table, value)				\
	do {								\
		(table) = (Word **) MR_RAW_TABLE_INT((table), (value));	\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_CHAR(table, table0, value)			\
	do {								\
		(table) = (Word) MR_RAW_TABLE_CHAR((Word **) (table0),	\
					(value));			\
	} while (0)
#define	MR_DEBUG_TABLE_CHAR(table, value)				\
	do {								\
		(table) = (Word **) MR_RAW_TABLE_CHAR((table), (value));\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_FLOAT(table, table0, value)			\
	do {								\
		(table) = (Word) MR_RAW_TABLE_FLOAT((Word **) (table0),	\
					(value));			\
	} while (0)
#define	MR_DEBUG_TABLE_FLOAT(table, value)				\
	do {								\
		(table) = (Word **) MR_RAW_TABLE_FLOAT((table), (value));\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_STRING(table, table0, value)			\
	do {								\
		(table) = (Word) MR_RAW_TABLE_STRING((Word **) (table0),\
					(value));			\
	} while (0)
#define	MR_DEBUG_TABLE_STRING(table, value)				\
	do {								\
		(table) = (Word **) MR_RAW_TABLE_STRING((table), (value));\
	} while (0)

#define	MR_DEBUG_NEW_TABLE_TYPEINFO(table, table0, value)		\
	do {								\
		(table) = (Word) MR_RAW_TABLE_TYPE_INFO((Word **) (table0),\
					(value));			\
	} while (0)
#define	MR_DEBUG_TABLE_TYPEINFO(table, value)				\
	do {								\
		(table) = (Word **) MR_RAW_TABLE_TYPE_INFO((table), (value));\
	} while (0)

#endif	/* MR_TABLE_DEBUG */

/***********************************************************************/

#define MR_TABLE_CREATE_ANSWER_BLOCK(ABlock, Elements)	 		\
	do {								\
		*((AnswerBlock) ABlock) = 				\
			(Word *) table_allocate(sizeof(Word)*Elements);	\
	} while(0)

#define MR_TABLE_GET_ANSWER(Offset, ABlock)				\
	(* ((AnswerBlock) ABlock))[Offset]

#ifdef CONSERVATIVE_GC

  #define MR_TABLE_SAVE_ANSWER(Offset, ABlock, Value, TypeInfo)		\
	do {								\
		(* ((AnswerBlock) ABlock))[Offset] = Value;		\
	} while(0)

#else /* not CONSERVATIVE_GC */

  #define MR_TABLE_SAVE_ANSWER(Offset, ABlock, Value, TypeInfo)		\
	do {								\
		save_transient_registers();				\
		{ Word local_val = Value;				\
		(* ((AnswerBlock) ABlock))[Offset] = 			\
			deep_copy(&local_val, (Word *) (Word) &TypeInfo,\
				NULL, NULL);				\
		}							\
		restore_transient_registers();				\
	} while(0)

#endif /* CONSERVATIVE_GC */

#ifdef CONSERVATIVE_GC

  #define table_allocate(size)						\
	GC_MALLOC(size)

  #define table_reallocate(pointer, size)				\
	GC_REALLOC(pointer, size)

  #define table_free(pointer)						\
	GC_FREE(pointer)

  #define MR_table_list_cons(h, t) list_cons((h), (t))

#else /* not CONSERVATIVE_GC */

  #define table_allocate(Size)						\
	(fatal_error("Sorry, not implemented: tabling in non-GC grades"), \
	(void *) NULL)
  #define table_reallocate(Pointer, Size)				\
	(fatal_error("Sorry, not implemented: tabling in non-GC grades"), \
	(void *) NULL)
  #define table_free(Pointer)						\
	fatal_error("Sorry, not implemented: tabling in non-GC grades")

  #define MR_table_list_cons(h, t)					\
	(fatal_error("Sorry, not implemented: tabling in non-GC grades"), \
	(Word) 0)

#endif /* CONSERVATIVE_GC */

#define table_copy_mem(Dest, Source, Size)				\
	memcpy(Dest, Source, Size)

#endif /* not MERCURY_TABLING_H */

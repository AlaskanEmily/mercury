\input texinfo
@setfilename mercury_ref.info
@settitle The Mercury Language Reference Manual

@c @ignore
@ifinfo
@format
START-INFO-DIR-ENTRY
* Mercury: (mercury_ref).        The Mercury Language Reference Manual
END-INFO-DIR-ENTRY
@end format
@end ifinfo
@c @end ignore

@c @smallbook
@c @cropmarks
@c @finalout
@setchapternewpage off
@ifinfo
This file documents the Mercury programming language.

Copyright (C) 1995 University of Melbourne.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through Tex and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
@end ifinfo

@titlepage
@c @finalout
@title The Mercury Language Reference Manual
@subtitle ALPHA TEST version - March, 1995
@author Fergus Henderson
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1995 University of Melbourne.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
@end titlepage
@page
@c ---------------------------------------------------------------------------

@node Top,,, (DIR)
@ifinfo
@chapter Mercury Language Reference Manual - ALPHA TEST version, March 1995
@end ifinfo
@menu
* Introduction::      A brief introduction to Mercury
* Syntax::            Mercury's syntax is similar to ISO Prolog
* Types::             Mercury has a strong parametric polymorphic type system
* Modes::             Modes allow you to specify the direction of data flow
* Determinism::       Determinism declarations let you specify that a predicate
		      should never fail or should never succeed more than once
* Modules::           Modules allow you to divide a program into smaller parts
* Semantics::         An informal semantics for Mercury programs
@end menu

@node Introduction, Syntax,, Top
@chapter Introduction

Mercury is a new general-purpose programming language, designed
and implemented by a small group of researchers at the University
of Melbourne, Australia.  Mercury is based on the paradigm of
pure declarative logic programming, and was designed to be
useful for the development of large and robust ``real-world'' applications.
It improves on existing logic programming languages by providing
increased productivity, reliability and efficiency, and by avoiding the
need for non-logical program constructs.

Mercury has strong type, mode and determinism checking at compile
time.  In addition to improving reliability, this static checking
improves productivity during development and maintenance by detecting
errors early in the software life-cycle.  The information provided by
the programmers' declarations is very useful documentation that is
guaranteed to be correct, and which is also extremely useful to the
compiler for generating efficient code.

To facilitate programming-in-the-large, to allow separate compilation,
and to support encapsulation, Mercury has a simple module system.
Mercury's standard library has a variety of pre-defined modules
for common programming tasks.

@node Syntax, Types, Introduction, Top
@chapter Syntax

@menu
* Syntax Overview::
* Tokens::
* Terms::
* Items::
* Declarations::
* Facts::
* Rules::
* Goals::
* DCG-rules::
* DCG-goals::
* Implicit quantification::
* Elimination of double negation::
@end menu

@node Syntax Overview, Tokens,, Syntax

Mercury's syntax is similar to the syntax of (pure) Prolog, with some
additional declarations for types, modes, determinism, and the module system.
A Mercury program consists of a set of modules.  Each module is a file
containing a sequence of items (declarations and clauses).  Each item
is a term followed by a period.  Each term is composed of a sequence
of tokens, and each token is composed of a sequence of characters.
Like Prolog, Mercury has the Definite Clause Grammar (DCG) notation
for clauses.

@node Tokens, Terms, Syntax Overview, Syntax
@section Tokens

Tokens in Mercury are exactly the same as in ISO Prolog.
@c XXX need to document this properly!

@node Terms, Items, Tokens, Syntax
@section Terms

Terms in Mercury are exactly the same as in ISO Prolog, with one
exception: double-quoted strings are atomic in Mercury,
they are not abbreviations for lists of character codes.
@c XXX need to document this properly!

@node Items, Declarations, Terms, Syntax
@section Items

Each item in a Mercury module is either a declaration or a clause.
If the top-level functor of the term is @samp{:-/1}, the item is a
declaration, otherwise it is a clause.  If the top-level functor of the
term is @samp{:-/2}, the item is a rule.  If the top-level functor is
@samp{-->/2}, the item is a DCG rule.  Otherwise, the item is a fact.

@node Declarations, Facts, Items, Syntax
@section Declarations

The allowed declarations are:

@example
:- type
:- pred
:- inst
:- mode
:- module
:- interface
:- implementation
:- import_module
:- external
:- end_module
@end example

The @samp{type} and @samp{pred} declarations are used for the type system,
the @samp{inst} and @samp{mode} declarations are for the mode system,
and the remainder are for the module system.  They are described in
more detail in their respective chapters.

(Note that for historical reasons, the current implementation allows
@samp{when/2} declarations, but ignores them.)

@node Facts, Rules, Declarations, Syntax
@section Facts

A fact is an item of the form @samp{@var{Head}}, where the top-level
functor of @var{Head} is not @code{:-/1}, @code{:-/2}, or @code{-->/2}.
The @var{Head} term must not be a variable.  The top-level functor
of the @var{Head} determines which predicate the clause belongs to;
the predicate must have been declared in a previous @samp{pred}
declaration in this module.  A fact is equivalent to a rule
@samp{@var{Head} :- true}.

@node Rules, Goals, Facts, Syntax
@section Rules

A rule is an item of the form @samp{@var{Head} :- @var{Body}}.
The @var{Head} term must not be a variable.  The top-level functor
of the @var{Head} determines which predicate the clause belongs to;
the predicate must have been declared in a previous @samp{pred}
declaration in this module.  The @var{Body} must be a valid goal.

@node Goals, DCG-rules, Rules, Syntax
@section Goals

A goal is a term of one of the following forms:

@table @code
@item some @var{Vars} @var{Goal}
An existential quantification.  @var{Vars} must be a list of variables.
@var{Goal} must be a valid goal.

@item all @var{Vars} @var{Goal}
A universal quantification.  @var{Vars} must be a list of variables.
@var{Goal} must be a valid goal.
This is an abbreviation for @samp{not (some @var{Vars} not @var{Goal})}.

@item @var{Goal1}, @var{Goal2}
A conjunction.  @var{Goal1} and @var{Goal2} must be valid goals.

@item @var{Goal1} ; @var{Goal2}
A disjunction.  @var{Goal1} and @var{Goal2} must be valid goals.
@var{Goal1} must not be of the form @samp{Goal1a -> Goal1b}.
(If it is, then the goal is an if-then-else, not a disjunction.)

@item true
The empty conjunction.  Always succeeds.

@item fail
The empty disjunction.  Always fails.

@item not @var{Goal}
@itemx \+ @var{Goal}
A negation.  The two different syntaxes have identical semantics.
@var{Goal} must be a valid goal.

@item @var{Goal1} => @var{Goal2}
An implication.  This is an abbrevation for
@samp{not (@var{Goal1}, not @var{Goal2})}.

@item @var{Goal1} <= @var{Goal2}
A reverse implication.  This is an abbrevation for
@samp{not (@var{Goal2}, not @var{Goal1})}.

@item @var{Goal1} <=> @var{Goal2}
A logical equivalence.  This is an abbrevation for
@samp{(@var{Goal1} => @var{Goal2}), (@var{Goal1} <= @var{Goal2}}.

@item if @var{CondGoal} then @var{ThenGoal} else @var{ElseGoal}
@itemx @var{CondGoal} -> @var{ThenGoal} ; @var{ElseGoal}
An if-then-else.  The two different syntaxes have identical semantics.
@var{CondGoal}, @var{ThenGoal}, and @var{ElseGoal} must be valid goals.
Note that the ``else'' part is @emph{not} optional.

@item @var{Term1} = @var{Term2}
A unification.

@item @var{Term1} \= @var{Term2}
An inequality. 
This is an abbreviation for @samp{not (@var{Term1} = @var{Term2})}.

@item @var{Call}
Any term which does not match any of the above forms must be
a predicate call.  If the term is a variable @var{Var}, it is treated
as if it were @samp{call(@var{Var})}.  Otherwise, the top-level
functor of the term determines the predicate called; the predicate
must be declared in a @code{pred} declaration in the module or in
the interface of an imported module.

@end table

@node DCG-rules, DCG-goals, Goals, Syntax
@section DCG-rules

DCG-rules in Mercury have identical syntax and semantics to
DCG-rules in Prolog.

A DCG-rule is an item of the form @samp{@var{Head} --> @var{Body}}.
The @var{Head} term must not be a variable.  
A DCG-rule is an abbreviation for an ordinary rule with two
additional implicit arguments appended to the arguments of @var{Head}.
These arguments are fresh variables which we shall call
@var{V_in} and @var{V_out}.
The @var{Body} must be a valid DCG-goal, and is an abbreviation for
an ordinary goal.  We shall define a function
@samp{DCG-transform(@var{V_in}, @var{V_out}, @var{DCG-goal})} which
specifies how DCG goals are transformed into ordinary goals.

@node DCG-goals, Implicit quantification, DCG-rules, Syntax
@section DCG-goals

A DCG-goal is a term of one of the following forms:

@table @code
@item some @var{Vars} @var{DCG-goal}
A DCG existential quantification.  @var{Vars} must be a list of variables.
@var{DCG-goal} must be a valid DCG-goal.

Semantics:
@example
transform(V_in, V_out, some Vars DCG_goal) = 
some Vars transform(V_in, V_out, DCG_goal)
@end example

@item all @var{Vars} @var{DCG-goal}
A DCG universal quantification.  @var{Vars} must be a list of variables.
@var{DCG-goal} must be a valid DCG-goal.

Semantics:
@example
transform(V_in, V_out, all Vars DCG_goal) = 
all Vars transform(V_in, V_out, DCG_goal)
@end example

@item @var{DCG-goal1}, @var{DCG-goal2}
A DCG sequence.  Intuitively, this means ``parse DCG-goal1 and then
parse DCG-goal2'' or ``do DCG-goal1 and then do DCG-goal2''.  (Note
that the only way this construct actually forces the desired sequencing
is by the modes of the implicit DCG arguments.) @var{DCG-goal1} and
@var{DCG-goal2} must be valid DCG-goals.

Semantics:
@example
transform(V_in, V_out, (DCG-goal1, DCG-goal2)) =
transform(V_in, V_new, DCG_goal1), transform(V_new, V_out, DCG_goal2)
@end example
where V_new is a fresh variable.

@item @var{DCG-goal1} ; @var{DCG-goal2}
A disjunction.  @var{DCG-goal1} and @var{DCG-goal2} must be valid goals.
@var{DCG-goal1} must not be of the form @samp{DCG-goal1a -> DCG-goal1b}.
(If it is, then the goal is an if-then-else, not a disjunction.)

Semantics:
@example
transform(V_in, V_out, (DCG_goal1 ; DCG_goal2)) =
transform(V_in, V_out, DCG_goal1) ; transform(V_in, V_out, DCG_goal2)
@end example

@item @{ @var{Goal} @}
A brace-enclosed ordinary goal.  @var{Goal} must be a valid goal.

Semantics:
@example
transform(V_in, V_out, @{ Goal @}) = (Goal, V_out = V_in)
@end example

@itemx [@var{Term}, ...]
A DCG input match.  Unifies the implicit DCG input variable V_in, which
must have type @samp{list(_)}, with a list whose initial elements are
the terms specified and whose tail is the implicit DCG output variable
V_out.

Semantics:
@example
transform(V_in, V_out, [Term1, ...]) = (V_in = [Term, ... | V_Out])
@end example

@item []
The null DCG goal (an empty DCG input match).
Equivalent to @samp{@{ true @}}.

Semantics:
@example
transform(V_in, V_out, []) = (V_out = V_in)
@end example

@item not @var{DCG-goal}
@itemx \+ @var{DCG-goal}
A DCG negation.  The two different syntaxes have identical semantics.
@var{Goal} must be a valid goal.

Semantics:
@example
transform(V_in, V_out, not DCG_goal) =
(not transform(V_in, V_new, DCG_goal), V_out = Vin)
@end example
where V_new is a fresh variable.

@item if @var{CondGoal} then @var{ThenGoal} else @var{ElseGoal}
@itemx @var{CondGoal} -> @var{ThenGoal} ; @var{ElseGoal}
A DCG if-then-else.  The two different syntaxes have identical semantics.
@var{CondGoal}, @var{ThenGoal}, and @var{ElseGoal} must be valid DCG-goals.

Semantics:
@example
transform(V_in, V_out, if CondGoal then ThenGoal else ElseGoal) =
if transform(V_in, V_cond, CondGoal) then
	transform(V_cond, V_out, ThenGoal)
else
        transform(V_in, V_out, ElseGoal)
@end example

@item =(@var{Term})
A DCG unification.  Unifies @var{Term} with the implicit DCG argument.

Semantics:
@example
transform(V_in, V_out, =(Term)) = (Term = V_in, V_out = Vin)
@end example

@item @var{DCG-call}
Any term which does not match any of the above forms must be
a DCG predicate call.  If the term is a variable @var{Var}, it is treated
as if it were @samp{call(@var{Var})}.  Then, the two implicit DCG
arguments are appended to the specified arguments.

Semantics:
@example
transform(V_in, V_out, p(A1, ..., AN)) = p(A1, ..., AN, V_in, V_Out)
@end example

@end table

@node Implicit quantification, Elimination of double negation, DCG-goals, Syntax
@section Implicit quantification

The rule for implicit quantification in Mercury is not the same
as the usual one in mathematical logic.  In Mercury variables
that do not occur in the head of a clause
are implicitly extentially quantified around their closest
enclosing scope (in a sense to be made precise in the following
paragraphs).  This allows most existential quantifiers to be omitted,
and leads to more concise code.

An occurence of a variable is @dfn{in a negated context} if it is
inside a negation, inside a universal quantification, in the condition
of an if-then-else, or in an inequality.

Two goals are @dfn{parallel} if they are different disjuncts
of the same disjunction, or if one is the ``else'' part of an
if-then-else and the other goal is either the ``then'' part
or the condition of the if-then-else.

If a variable occurs in a negated context
and does not occur outside of that negated context
other than in parallel goals (and in the case of a variable in the
condition of an if-then-else, other than in the ``then'' part of the
if-then-else), then that variable is implicitly existentially
quantified inside the negation.

@node Elimination of double negation,, Implicit quantification, Syntax
@section Elimination of double negation

The treatment of inequality, universal quantification, implication, and
logical equivalence as abbreviations can cause the introduction of
double negations which could make otherwise well-formed code
mode-incorrect.  To avoid this problem, the language specifies that
double negations are removed after syntax analysis, before mode
analysis is performed.

@node Types, Modes, Syntax, Top
@chapter Types

The type system is based on a polymorphic many-sorted logic.

Certain special types are builtin, or are defined in the Mercury library:

@table @asis
@item Primitive types: @code{char}, @code{int}, @code{float}, @code{string}.
There is a special syntax for constants of type @code{int}, @code{float},
and @code{string}.  (For @code{char}, the standard syntax suffices.)

@item Predicate types: @code{pred}, @code{pred(T)}, @code{pred(T1, T2)}, @dots{}
These higher-order predicate types are used to pass predicates around.
We're still working on the details of how higher-order predicates will work
in Mercury --- so don't use these yet.

@item The universal type: @code{univ}.
The type @code{univ} is defined in the standard library module @code{std_util},
along with the predicates @code{type_to_univ/2} and @code{univ_to_type/2}.
With those predicates, any type can be converted to the universal type
and back again.  The universal type is useful for situations where you need
heterogeneous collections.

@item The ``state-of-the-world'' type: @code{io__state}.
The type @code{io__state} is define in the standard library module
@code{io}, and represents the state of the world.  Predicates which
perform I/O are passed the old state of the world and produce a new
state of the world.  In this way, we can give a declarative semantics to
code that performs I/O.

@end table

New types can be introduced with @samp{:- type} declarations.
There are several categories of derived types:

@itemize
@item
Discriminated unions: these encompass both enumeration and
record types in other languages.  A derived type is defined
using @samp{:- type @var{type} ---> @var{body}}. 
(Note there are @emph{three} dashes in that arrow.  It should
not be confused with the two-dash arrow used for DCGs or the
one-dash arrow used for if-then-else.)
If the @var{type} term is a functor of arity zero, it names
a monomorphic type.  Otherwise, it names a polymorphic type;
the arguments of the functor must be distinct type variables.
The @var{body} term is as
sequence of constructor definitions separated by semi-colons.
Each constructor definition is a functor whose arguments (if any) are types.
Type definitions must be @dfn{transparent}: all type variables
occuring in the @var{body} must also occur in the @var{type}.

Here are some examples:

@example
        :- type fruit
                --->    apple
                ;       orange
                ;       banana
                ;       pear.

        :- type strange
                --->    foo(int)
                ;       bar(string).

        :- type employee
                --->    employee(
                               string,               % name
                               int,                  % age
                               string                % department
                        ).

        :- type tree
                --->    empty
                ;       leaf(int)
                ;       branch(tree, tree).

        :- type list(T)
                --->    []
                ;       [T | list(T)].

        :- type pair(T1, T2)
                --->    T1 - T2.
@end example

If the body of a discriminated union type definition contains a term whose
top-level functor is @code{';'/2}, the semi-colon is normally assumed to be a
separator.  This makes it difficult to define a type whose constructors
include @code{';'/2}.  To allow this, curly braces can be used to quote
the semi-colon.  It is then also necessary to quote curly braces.
The following example illustrates this:

@example
        :- type tricky
                --->    @{ int ; int @}
                ;       @{ @{ int @} @}.
@end example

@item
Equivalence types: these are type abbreviations.  They are defined
using `==' as follows.  They may be polymorphic.

@example
        :- type money == int.
        :- type assoc_list(KeyType, ValueType)
                == list(pair(KeyType, ValueType)).
@end example

Like discriminated union type definitions, equivalence type definitions must
be transparent.

@item
Abstract types: these are types whose implementation is hidden.
The type declarations

@example
        :- type t1.
        :- type t2(T1, T2).
@end example

@noindent
declare types @code{t1/0} and @code{t/2} to be abstract types.
Such declarations are only useful in the interface section of a module.
This means that the type names will be exported, but the constructors
(functors) for these types will not be exported.

@end itemize

Constructors may be overloaded amoung different types:
there may be any number of constructors with a given name and arity,
so long as they all have different types.
However, there must be only one constructor with a given name, arity, and type.
(There is no particularly good reason for this restriction; it might be
dropped sometime in the future.)
Note that excessive overloading of constructors can slow down type checking
and can make the program confusing for human readers, so overloading
should not be over-used.

The argument types of each predicate must be explicitly declared
with a @samp{:- pred} declaration.  These declarations may be
polymorphic.  For example:

@example
	:- pred list__member(T, list(T)).
@end example

Predicates may not be overloaded: there must only be one predicate
with a given name and arity in each program.
(This restriction will hopefully be relaxed in the future.)

The compiler infers the types of variables and overloaded
constructors.  A @dfn{type assignment} is an assignment of a type to
each variables and constructor in a clause.  A type assignment is
@dfn{valid} if it satisfies the following conditions.  Each constructor
in a clause must have been declared in at least one type declaration.
The type assigned to each constructor must match one of the type
declarations for that constructor, and the types assigned to the arguments
of that constructor must match the argument types specified in that
type declaration.  The type assigned to each predicate
argument much match the type specified in the @samp{:- pred}
declaration for that predicate.  The type assigned to each head
argument in a clause must exactly match the type specified in the
corresponding @samp{:- pred} declaration.
(Here ``match'' means to be an instance of, i.e. to be identical to for some
substitution of the type parameters, and ``exactly match'' means
to be identical up to renaming of type parameters.)

One type assignment @var{A} is said to be @dfn{more general} than
another type assignment @var{B} if there is a binding of the type
parameters in A that makes it identical (up to renaming of
parameters) to B.  If there is more than one valid type assignment,
the compiler must choose the most general one.
If there are two valid type assignments which are not identical up to
renaming and neither of which is more general than the other, then there
is a type ambiguity, and compiler must report an error.
A clause is @dfn{type-correct} if there is a unique (up to renaming)
most general valid type assignment.  Every clause in a Mercury program
must be type-correct.

@node Modes, Determinism, Types, Top
@chapter Modes

The @dfn{mode} of a predicate is a mapping
from the initial state of instantiation of the arguments of the predicate
to their final state of instantiation.
To describe states of instantiation,
we use information provided by the type system.
Types can be viewed as regular trees with two kinds of nodes:
or-nodes representing types
and and-nodes representing constructors.
The children of an or-node are the constructors
that can be used to construct terms of that type;
the children of an and-node are the types
of the arguments of the constructors.
We attach mode information to the or-nodes of type trees.

An @dfn{instantiatedness tree} is an assignment
of an @dfn{instantiatedness} --- either @dfn{free} or @dfn{bound} ---
to each or-node of a type tree,
with the constraint that all descendants of a free node must be free.

A term is @dfn{approximated by} an instantiatedness tree
if for every node in the instantiatedness tree,

@itemize
@item
if the node is ``free'',
then the corresponding node in the term (if any)
is a free variable that does not share with any other variable
(we call such variables @dfn{distinct});

@item
if the node is ``bound'',
then the corresponding node in the term (if any)
is a function symbol.

@end itemize

When an instantiatedness tree tells us that a variable is bound,
there may be several alternative function symbols to which it could be
bound.
The instantiatedness tree does not tell us which of these it
is bound to; instead for each possible function symbol it tells us
exactly which arguments of the function symbol will be free and which
will be bound.  The same principle applies recursively to
these bound arguments.

Mercury's mode system allows users to declare names for instantiatedness
trees using declarations such as

@example
:- inst listskel ---> bound( [] ; [free | listskel] ).
@end example

This instantiatedness tree describes lists
whose skeleton is known but whose elements are distinct variables.
As such, it approximates the term @code{[A,B]}
but not the term @code{[H|T]} (only part of the skeleton is known),
the term @code{[A,2]} (not all elements are variables),
or the term @code{[A,A]} (the elements are not distinct variables).

As a shorthand, the mode system provides @samp{free} and @samp{ground}
as names for instantiatedness trees
all of whose nodes are free and bound respectively.
The shape of these trees is determined by
the type of the variable to which they apply.

As execution proceeds, variables may become more instantiated.
A @dfn{mode mapping} is a mapping
from an initial instantiatedness tree to a final instantiatedness tree,
with the constraint that no node of the type tree
is transformed from bound to free.
Mercury allows the user to specify mode mappings directly
by expressions such as @code{inst1 -> inst2},
or to give them a name using declarations such as

@example
:- mode m :: inst1 -> inst2.
@end example

Two standard shorthand modes are provided,
corresponding to the standard notions of inputs and outputs:

@example
:- mode in :: ground -> ground.
:- mode out :: free -> ground.
@end example

These two modes are enough for most predicates.
Nevertheless, Mercury's mode system is sufficiently
expressive to handle more complex data-flow patterns, including those
involving partially instantiated data structures.  
[NOTE: The current implementation does not handle partially
instantiatied data yet!]

For example, consider an
interface to a database that associates data with keys, and provides
read and write access to the items it stores.  To represent accesses to
the database over a network, you would need declarations such as

@example
:- type	operation
        --->    lookup(key, data)
        ;       set(key, data).
:- inst request --->
	bound(  lookup(ground, free)
        ;       set(ground, ground)
        ).
:- mode create_request :: free -> request.
:- mode satisfy_request :: request -> ground.
@end example

A @dfn{predicate mode declaration}
assigns a mode mapping to each argument of a predicate.
For example, given the mode names defined by

@example
:- mode out_listskel ::
   free -> listskel.
:- mode in_listskel ::
   listskel -> listskel.
@end example

the (type and) mode declarations of the predicates length and append
are as follows:

@example
:- pred length(list(T), int).
:- mode length(in_listskel, out).
:- mode length(out_listskel, in).

:- pred append(list(T), list(T),
	   list(T)).
:- mode append(in, in, out).
:- mode append(out, out, in).
@end example

If a predicate has only one mode, the @samp{pred} and @samp{mode}
declaration can be combined:

@example
:- pred append(list(T)::in, list(T)::in, list(T)::out).
@end example

A predicate mode declaration is an assertion by the programmer
that for all possible argument terms for the predicate
that are approximated by the initial instantiatedness trees
of the mode declaration and all of whose free variables are distinct,
if the predicate succeeds then
the resulting binding of those argument terms
will in turn be approximated
by the final instantiatedness trees of the mode declaration.
We refer to such assertions as @dfn{mode declaration constraints}.
These assertions are checked by the compiler,
which rejects programs if it cannot prove
that their mode declaration constraints are satisfied.

@ignore
Note that for every mode of a predicate
in which a node is @dfn{produced} (mapped from free to bound)
there is another mode for that predicate
in which the node is @dfn{consumed} (mapped from bound to bound),
and for every mode in which a node is ignored (mapped from free to free)
there is another mode in which the node is mapped from bound to bound.
Such modes are called @dfn{implied modes}.
@end ignore

The @dfn{mode set} for a predicate
is the set of mode declarations for the predicate
plus all their implied modes.
A mode set is an assertion by the programmer
that the predicate should only be called with argument terms
that are approximated by the initial instantiatedness trees
of one of the mode declarations in the set
(i.e. the specified modes and the modes they imply
are the only allowed modes for this predicate).
We refer to the assertion associated with a mode set
as the @dfn{mode set constraint};
these are also checked by the compiler.

A predicate p is @dfn{well-moded
with respect to a given mode declaration}
if given that the predicates called by p
all satisfy their mode declaration constraints,
there exists an ordering of the literals in the definition of p
such that

@itemize
@item
p satisfies its mode declaration constraint, and
@item
p satisfies the mode set constraint of all of the predicates it calls
@end itemize

We say that a predicate is well-moded
if it is well-moded with respect to
all the mode declarations in its mode set,
and we say that a program is well-moded
if all its predicates are well-moded.

The mode analysis algorithm checks one mode of one predicate at a time.
It abstractly interprets the definition of the predicate,
keeping track of the instantiatedness of each variable,
and selecting a mode for each call and unification in the definition.
To ensure that
the mode set constraints of called predicates are satisfied,
the compiler may reorder the elements of conjunctions;
it reports an error if no satisfactory order exists.
Finally it checks that
the resulting instantiatedness of the predicate's arguments
is the same as the one given by the predicate's mode declaration.

The mode analysis algorithm annotates each call with the mode used.

@node Determinism, Modules, Modes, Top
@chapter Determinism

@subsection Determinism categories

For each mode of a predicate, we categorise that mode according to
whether it can succeed more than once, and whether or not it can
fail.

@itemize
@item
If all calls to a particular mode of a predicate
have no more than one solution, and they do not fail,
then that mode of the predicate is @dfn{deterministic}
(@code{det}).

@item
If all calls to a particular mode of a predicate have no more than one
solution but may fail, then that mode of the predicate is
@dfn{semideterministic} (@code{semidet}).

@item
If all calls to a particular mode of a predicate do not fail, but may
have more than one solution, then that mode of the predicate is
@dfn{multideterministic} (@code{multidet}).
[@strong{Warning}: the current implementation treats @code{multidet}
as an alias for @code{nondet}.  We will implement @code{multidet} properly
sometime in the near future.]

@item
If some calls to a particular mode of a predicate
have no solution but other calls may have more than one solution,
then that mode of the predicate is @dfn{nondeterministic} (@code{nondet}).
@end itemize

It's also necessary to consider the case where predicates neither
fail nor succeed, such as when they loop forever, or when they 
lead to a run-time error.

@itemize
@item
If all calls to a particular mode of a predicate neither fail nor
succeed, then that mode of the predicate is @dfn{erroneous}.

@item
If all calls to a particular mode of a predicate never succeed,
but may fail, that mode of the predicate is @dfn{failure}.

@end itemize

To summarize:

@example
                Maximum number of solutions
Can fail?       0               1               > 1
no              erroneous       det             multidet
yes             failure         semidet         nondet
@end example

The determinism of each mode of a predicate is indicated by
an annotation on the mode declaration.  For example:

@example
:- pred append(list(T), list(T), list(T)).
:- mode append(in, in, out) is det.
:- mode append(out, out, in) is multidet.
:- mode append(in, in, in) is semidet.
@end example

If the mode of the predicate is given in the @code{:- pred} declaration
rather than in a separate @code{:- mode} declaration,
then the determinism annotation goes on the @code{:- pred} declaration.
In particular, this is necessary if the predicate does not have any
argument variables.  For example:

@example
:- pred loop(int::in) is erroneous.
loop(X) :- loop(X).

:- pred p is det.
p.

:- pred q is failure.
q :- fail.
@end example

@subsection Determinism checking and inference.

The determinism categories form a lattice, as specified by
the following ordering:

@example
             erroneous
              /     \
          failure   det
             \     /   \
             semidet    multidet
                  \     /
                   nondet
@end example

@center erroneous > failure

@center erroneous > det

@center failure > semidet

@center det > semidet

@center semidet > nondet

@center det > multidet

@center multidet > nondet

The determinism of goals is inferred from the determinism
of their component parts, according to the rules below.
The inferred determinism of a procedure is just the inferred
determinism of the procedure's body.

For procedures that are local to a module, the determinism annotations
may be omitted; in that case, their determinism will be inferred.
(To be precise, the determinism of procedures without a determinism
annotation is defined as the least fixpoint of the transformation
which, given an initial assignment of determism to such procedures,
applies those rules to infer a new such assignment.)

For procedures that are exported from their containing module,
it is an error to omit the determinism annotation.

If a determinism annotation is supplied for a predicate,
the declared determinism is compared against the inferred determinism.
If the declared determinism is greater than or not comparable to the
inferred determinism (in the partial ordering above), it is an error.
If the declared determinism is less than the inferred determinism,
it is not an error, but the implementation may issue a warning.

The determinism category of each goal is inferred according to the
following rules.  However, if the inferred category was @code{nondet}
or @code{multidet} but the goal does not have any output variables,
the inferred category is replaced with @code{semidet} or @code{det}
respectively; the compiler will implicitly prune away any duplicate
solutions.

@table @asis
@item Calls
The determinism category of a call is the determinism of the particular
mode of the called predicate (as determined by mode analysis).

@item Unifications
The determinism of a unification is either @code{det}, @code{semidet},
or @code{failure}, depending on its mode.

@item Conjunctions
The determinism of the empty conjunction (the goal @samp{true})
is @code{det}.

The determinism of @samp{(@var{A}, @var{B})} is defined as
follows.  If the determinism of @var{A} is @code{erroneous} or
@code{failure}, then the determinism of the conjunction is also
@code{erroneous} or @code{failure}, respectively.  Otherwise
the determinism of the conjunction is the minimum (meet) of the
determinism of the conjuncts.
@comment XXX meet? should that be join?

@item Disjunctions
The determinism of the empty disjunction (the goal @samp{fail})
is @code{failure}.

The determinism of a non-empty disjunction is defined in terms of
its @dfn{local determinism} and the determinism of the disjuncts.

The local determinism of a disjunction is @code{nondet} unless the
compiler can detect that the disjunction is actually a switch and
hence @dfn{index} the disjunction.
Precisely describing the rules for detecting switches is somewhat tricky,
and I won't attempt to do so, but they are
reasonable easy to understand in practice.
The compiler can index on any input variable to a disjunction
(not just the first head variable).  It can also index on more than
one variable, since after indexing on the first one, switch detection is
applied to all sub-disjunctions.  The current implementation does
not do the common sub-expression hoisting that is necessary for
deep indexing (indexing on a sub-term, not just on the top-level
functor), but you can do the common-subexpression hoisting yourself.
For example, it cannot detect that the following two clauses

@example
        :- mode p(in).
        p(f(a)) :-
                ...
        p(f(b)) :- 
                ..
@end example

@noindent
are disjoint, but it can index them if you write the code as

@example
        p(f(X)) :-
                ( X = a, ...
                ; X = b, ...
                ).
@end example

The local determinism of a switch is @code{det} if the different
cases of the switch cover all the possible alternatives for the
input variable; otherwise, it is @code{semidet}.

If the disjunction is not a switch, but one of the disjuncts is
@code{det} or @code{erroneous} or some subset of the disjuncts form a
@code{det} or @code{erroneous} switch, then the determinism of the
disjunction is @code{multidet}.

@item If-then-else

If the determinism of the condition of the if-then-else is
@code{erroneous} or @code{failure}, the determinism of the if-then-else
is @code{erroneous}.  If the condition is @code{det}, the determinism
of the if-then-else is the same as the determinism of the @samp{then}
part.  If the condition is @code{semidet}, the determinism  of the
if-then-else is the join (minimum) of the determinism of the
``then'' part and the ``else'' part.

@item Negations

If the determinism of the negated goal is @code{erroneous},
then the determinism of the negation is @code{erroneous}.
If the determinism of the negated goal is @code{det},
the determinism of the negation is @code{failure}.
Otherwise, the determinism of the negation is @code{semidet}.

@end table

Note that ``perfect'' determinism inference is an undecideable
problem, because it requires solving the halting problem.
(For instance, in the following example

@example
:- pred p is det.
p :-
        something_complicated,
        fail.
@end example

@noindent
@samp{p/0} can fail only if @samp{something_complicated} halts.)
Sometimes, the rules specified by the Mercury language for determinism
inference will infer a determinism that is not as precise as you would like.
However, it is generally easy to overcome such problems.  The way to do
this is to replace the compiler's static checking with some manual run-time
checking.  For example, if you know that a particular goal should never fail,
but the compiler infers that goal to be @code{semidet}, you can check
at runtime that the goal does succeed, and if it fails, call the library
predicate @samp{error/1}.

@example
        :- pred p is det.
        p :-
                ( goal_that_should_never_fail ->
                        true
                ;
                        error("goal_that_should_never_fail failed!")
                ).
@end example

@noindent
The predicate @code{error/1} has determininsm @code{erroneous}, which means
the compiler knows that it will never succeed or fail, so the inferred
determinism for the body of @code{p/1} is @code{det}.
(Note that checking assumptions like this is good coding style anyway.
The small amount of up-front work that Mercury requires is paid back in
reduced debugging time.)

@node Modules, Semantics, Determinism, Top
@chapter Modules

The mercury module system is simple and straightforward. 
Each module must start with a @code{module} declaration,
specifying the name of the module. 
An @code{interface} declaration specifies
the start of the module's interface section:
this section contains declarations for the types, function symbols,
instantiation states, modes, and predicates exported by this module.
Mercury provides support for abstract data types,
since the definition of a type may be kept hidden,
with only the type name being exported.  
An @code{implementation} declaration specifies
the start of the module's implementation section. 
Any entities declared in this section are local to the module
and cannot be used by other modules.
The implementation section must of course contain definitions
for all abstract data types and predicates exported by the module,
as well for all local types and predicates.
The module may optionally end with an @code{end_module} declaration.

If a module wishes to make use of entities exported by other modules,
then it must explicitly import those modules
using one or more @code{import_module} declarations.
These declarations may occur
either in the interface or the implementation section.

One module most export a predicate @samp{main}, which
must be declared as either

@example
:- pred main(io__state::di, io__state::uo) is det.
@end example

@noindent
or

@example
:- pred main(io__state::di, io__state::uo) is multidet.
@end example

@noindent
(or any declaration equivalent to one of the two above).

For example, here is the definition of a simple module for managing queues:

@example
:- module queue.
:- interface.

% Declare an abstract data type.

:- type queue(T).

% Declare some predicates which
% operate on the abstract data type.

:- pred empty_queue(queue(T)).
:- mode empty_queue(out) is det.
:- mode empty_queue(in) is semidet.

:- pred put(queue(T), T, queue(T)).
:- mode put(in, in, out) is det.

:- pred get(queue(T), T, queue(T)).
:- mode get(in, out, out) is semidet.

:- implementation.

% Queues are implemented as lists.
% We need the `list' module for the
% declaration of the type list(T),
% with its constructors '[]'/0
% and '.'/2, and for the declaration
% of the predicate append/3.

:- import_module list.

% Define the queue ADT.

:- type queue(T) == list(T).

% Declare the exported predicates.

empty_queue([]).

put(Queue0, Elem, Queue) :-
         append(Queue0, [Elem], Queue).

get([Elem | Queue], Elem, Queue).

:- end_module queue.

@end example

Mercury has a standard library which includes modules for
lists, stacks, queues, priority queues, sets, bags (multi-sets),
maps (dictionaries), random number generation, input/output
and filename and directory handling.

@node Semantics,, Modules, Top
@chapter Semantics

A legal Mercury program is one that complies with the syntax,
type, mode, determism, and module system rules specified in
earlier chapters.  If a program does not comply with those rules,
the compiler must report an error.

For each legal Mercury program, there is an associated predicate calculus
theory whose language is specified by the type declarations in the program
and whose axioms are the completion of all predicates in the program
plus the usual equality axioms.  The declarative semantics of a legal Mercury
program is specified by this theory.  Mercury implementations must be
sound: the answers they compute must be true in every model of the theory.

Execution of a legal Mercury program begins with the predicate @samp{main}.

@contents
@bye

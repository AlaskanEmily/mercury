#-----------------------------------------------------------------------------#

THIS_DIR = debugger/declarative

#-----------------------------------------------------------------------------#

DECLARATIVE_PROGS=		\
	aadebug			\
	app			\
	args			\
	backtrack		\
	big			\
	browse_arg		\
	comp_gen		\
	deep_warning		\
	dependency		\
	dependency2		\
	family			\
	filter			\
	func_call		\
	gcf			\
	higher_order		\
	ho2			\
	if_then_else		\
	input_term_dep		\
	ite_2			\
	lpe_example		\
	neg_conj		\
	negation		\
	oracle_db		\
	output_term_dep		\
	pd			\
	propositional		\
	queens			\
	shallow			\
	small			\
	solutions		\
	special_term_dep	\
	tabled_read_decl	\
	throw

# The following should not be run in `debug' grades.
#
# XXX 'catch' test case does not work properly in debug grades, due to some
# unknown bug.  The result of this bug is that the declarative debugger
# gives a warning about missed events and refuses to start.  Since the
# previous behaviour was to throw a software error, this is not really
# a regression, but we would still like to find the bug and fix it.
#
NONDEBUG_DECLARATIVE_PROGS=	\
	catch			\
	untraced_subgoal

NONWORKING_DECLARATIVE_PROGS=	\

ifneq "$(findstring .debug,$(GRADE))" ""
    PROGS_2=$(DECLARATIVE_PROGS)
    SOLUTIONS_INP=solutions.inp2
else
    PROGS_2=$(DECLARATIVE_PROGS) $(NONDEBUG_DECLARATIVE_PROGS)
    SOLUTIONS_INP=solutions.inp
endif

# Debugging does not work in MLDS (hl*) and deep profiling (profdeep) grades.
# Base grades `jump' and `fast' cannot be used with
# stack layouts (which are required for tracing).
# Currently, declarative debugging does not work in `rt' grades.
# Also, declarative debugging only works in `.gc' grades.

ifeq "$(findstring hl,$(GRADE))$(findstring profdeep,$(GRADE))" ""
    ifneq "$(findstring .gc,$(GRADE))" ""
        ifneq "$(findstring rt,$(GRADE))" ""
	    PROGS=
        else
            ifneq "$(findstring asm_,$(GRADE))" ""
                PROGS=$(PROGS_2)
            else
                ifneq "$(findstring jump,$(GRADE))" ""
                    PROGS=
                else
                    ifneq "$(findstring fast,$(GRADE))" ""
                        PROGS=
                    else
                        PROGS=$(PROGS_2)
                    endif
                endif
            endif
        endif
    else
        PROGS=
    endif
else
    PROGS=
endif

SUBDIRS=
TESTS=$(PROGS)
TESTS_DIR=../..
include $(TESTS_DIR)/Mmake.common

MCFLAGS += --trace decl
MLFLAGS += --trace

# Module-specific options should go in Mercury.options so they
# can be found by `mmc --make'.
include Mercury.options

%.runtest: %.res ;

#-----------------------------------------------------------------------------#

aadebug.out: aadebug aadebug.inp
	$(MDB) ./aadebug < aadebug.inp > aadebug.out 2>&1

app.out: app app.inp
	$(MDB) ./app < app.inp > app.out 2>&1

args.out: args args.inp
	$(MDB) ./args < args.inp > args.out 2>&1

backtrack.out: backtrack backtrack.inp
	$(MDB) ./backtrack < backtrack.inp > backtrack.out 2>&1

big.out: big big.inp
	$(MDB) ./big < big.inp > big.out 2>&1

browse_arg.out: browse_arg browse_arg.inp
	$(MDB) ./browse_arg < browse_arg.inp > browse_arg.out 2>&1

catch.out: catch catch.inp
	$(MDB) ./catch < catch.inp > catch.out 2>&1

comp_gen.out: comp_gen comp_gen.inp
	$(MDB) ./comp_gen < comp_gen.inp > comp_gen.out 2>&1

deep_warning.out: deep_warning deep_warning.inp
	$(MDB) ./deep_warning < deep_warning.inp > deep_warning.out 2>&1

dependency.out: dependency dependency.inp
	$(MDB) ./dependency < dependency.inp > dependency.out 2>&1

dependency2.out: dependency2 dependency2.inp
	$(MDB) ./dependency2 < dependency2.inp > dependency2.out 2>&1

family.out: family family.inp
	$(MDB) ./family < family.inp > family.out 2>&1

filter.out: filter filter.inp
	$(MDB) ./filter < filter.inp > filter.out 2>&1

func_call.out: func_call func_call.inp
	$(MDB) ./func_call < func_call.inp > func_call.out 2>&1

gcf.out: gcf gcf.inp
	$(MDB) ./gcf < gcf.inp > gcf.out 2>&1

higher_order.out: higher_order higher_order.inp
	$(MDB) ./higher_order < higher_order.inp > higher_order.out 2>&1

ho2.out: ho2 ho2.inp
	$(MDB) ./ho2 < ho2.inp > ho2.out 2>&1

if_then_else.out: if_then_else if_then_else.inp
	$(MDB) ./if_then_else < if_then_else.inp > if_then_else.out 2>&1

input_term_dep.out: input_term_dep input_term_dep.inp
	$(MDB) ./input_term_dep < input_term_dep.inp > input_term_dep.out 2>&1

ite_2.out: ite_2 ite_2.inp
	$(MDB) ./ite_2 < ite_2.inp > ite_2.out 2>&1

lpe_example.out: lpe_example lpe_example.inp
	$(MDB) ./lpe_example < lpe_example.inp > lpe_example.out 2>&1

neg_conj.out: neg_conj neg_conj.inp
	$(MDB) ./neg_conj < neg_conj.inp > neg_conj.out 2>&1

negation.out: negation negation.inp
	$(MDB) ./negation < negation.inp > negation.out 2>&1

oracle_db.out: oracle_db oracle_db.inp
	$(MDB) ./oracle_db < oracle_db.inp > oracle_db.out 2>&1

output_term_dep.out: output_term_dep output_term_dep.inp
	$(MDB) ./output_term_dep < output_term_dep.inp	\
			> output_term_dep.out 2>&1

pd.out: pd pd.inp
	$(MDB) ./pd < pd.inp > pd.out 2>&1

propositional.out: propositional propositional.inp
	$(MDB) ./propositional < propositional.inp > propositional.out 2>&1

queens.out: queens queens.inp
	$(MDB) ./queens < queens.inp > queens.out 2>&1

shallow.out: shallow shallow.inp
	$(MDB) ./shallow < shallow.inp > shallow.out 2>&1

small.out: small small.inp
	$(MDB) ./small < small.inp > small.out 2>&1

solutions.out: solutions $(SOLUTIONS_INP)
	$(MDB) ./solutions < $(SOLUTIONS_INP) > solutions.out 2>&1

special_term_dep.out: special_term_dep special_term_dep.inp
	$(MDB) ./special_term_dep < special_term_dep.inp \
			> special_term_dep.out 2>&1

tabled_read_decl.out: tabled_read_decl tabled_read_decl.inp
	$(MDB) ./tabled_read_decl < tabled_read_decl.inp \
			> tabled_read_decl.out 2>&1

# We need to pipe the output through sed to avoid hard-coding dependencies on
# particular line numbers in the standard library source code.
throw.out: throw throw.inp
	$(MDB) ./throw < throw.inp 2>&1 | \
		sed -e 's/exception.m:[0-9]*/exception.m:NNNN/g' | \
		sed -e '/EXCP/s/).*/)/' > throw.out 2>&1

untraced_subgoal.out: untraced_subgoal untraced_subgoal.inp
	$(MDB) ./untraced_subgoal < untraced_subgoal.inp \
			> untraced_subgoal.out 2>&1

#-----------------------------------------------------------------------------#

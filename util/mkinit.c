#include	<stdio.h>
#include	<stdlib.h>
#include	<unistd.h>
#include	<string.h>
#include	<ctype.h>

#define	isokchar(c)	(isalnum(c) || c == '_')

#define	MAXCALLS	40
#define	MAXLINE		256

static const char header1[] = 
	"/*\n"
	"** This code automatically generated by mkinit - do not edit.\n"
	"**\n"
	"** Input files:\n"
	"**\n"
	;

static const char header2[] = 
	"*/\n"
	"\n"
	"#include <stddef.h>\n"
	"#include \"init.h\"\n"
	"\n"
	"/*\n"
	"** Work around a bug in the Solaris 2.X (X<=4) linker;\n"
	"** on these machines, init_gc must be statically linked.\n"
	"*/\n"
	"\n"
	"#ifdef CONSERVATIVE_GC\n"
	"void init_gc(void)\n"
	"{\n"
	"\tGC_INIT();\n"
	"}\n"
	"#endif\n"
	"\n"
	;

static	void usage(void);
static	int getline(FILE *file, char *line, int line_max);

int main(int argc, char **argv)
{
	const char	*default_entry = "mercury__io__run_0_0";
	const char	*init_str;
	const char	*endinit_str;
	char	line[MAXLINE];
	int	c;
	int	i;
	int	j;
	int	filenum;
	int	calls;
	int	maxcalls = MAXCALLS;
	int	maxmodule;
	int	init_strlen;
	int	endinit_strlen;
	FILE	*cfile;

	while ((c = getopt(argc, argv, "c:w:")) != EOF)
	{
		switch (c)
		{

	case 'c':	if (sscanf(optarg, "%d", &maxcalls) != 1)
				usage();
			break;

	case 'w':	default_entry = optarg;
			break;

	default:	usage();

		}
	}

	fputs(header1, stdout);

	for (filenum = optind; filenum < argc; filenum++)
	{
		fputs("** ", stdout);
		fputs(argv[filenum], stdout);
		putc('\n', stdout);
	}

	fputs(header2, stdout);

	init_str = "INIT ";
	init_strlen = strlen(init_str);
	endinit_str = "ENDINIT ";
	endinit_strlen = strlen(init_str);

	maxmodule = 0;
	calls = 0;
	fputs("static void init_modules_0(void)\n", stdout);
	fputs("{\n", stdout);

	for (filenum = optind; filenum < argc; filenum++)
	{
		cfile = fopen(argv[filenum], "r");
		if (cfile == (FILE *) NULL)
		{
			perror(argv[filenum]);
			exit(1);
		}

		while (getline(cfile, line, MAXLINE) > 0)
		{
			if (strncmp(line, init_str, init_strlen) == 0)
			{
				if (calls >= maxcalls)
				{
					fputs("}\n\n", stdout);

					maxmodule++;
					calls = 0;
					printf("static void init_modules_%d(void)\n", maxmodule);
					fputs("{\n", stdout);
				}

				calls++;

				for (j = init_strlen; isokchar(line[j]); j++)
					;

				line[j] = '\0';

				fputs("\t{ extern void ", stdout);
				fputs(line+init_strlen, stdout);
				fputs("(void);", stdout);

				putc('\t', stdout);
				fputs(line+init_strlen, stdout);
				fputs("(); }\n", stdout);
			}

			if (strncmp(line, endinit_str, endinit_strlen) == 0)
				break;
		}

		fclose(cfile);
	}

	fputs("}\n\n", stdout);

	fputs("/*\n", stdout);
	fputs("** Initialize default_entry statically if possible.\n", stdout);
	fputs("*/\n\n", stdout);
	printf("Declare_entry(%s);\n\n", default_entry);
	fputs("#if defined(USE_GCC_NONLOCAL_GOTOS) && !defined(USE_ASM_LABELS)\n", stdout);
	fputs("Code\t*default_entry;\n", stdout);
	fputs("#else\n", stdout);
	printf("Code\t*default_entry = ENTRY(%s);\n", default_entry);
	fputs("#endif\n\n", stdout);

	fputs("void init_modules(void)\n", stdout);
	fputs("{\n", stdout);
	for (i = 0; i <= maxmodule; i++)
		printf("\tinit_modules_%d();\n", i);

	printf("\n\tdefault_entry = ENTRY(%s);\n", default_entry);
	fputs("}\n", stdout);

	exit(0);
}

static void usage(void)
{
	fprintf(stderr, "Usage: mkinit [-c maxcalls] [-w entry]\n");
	exit(1);
}

static int getline(FILE *file, char *line, int line_max)
{
	int	c, i, lim;

	i = 0;
	lim = line_max-2;
	while ((c = getc(file)) != EOF && c != '\n')
		if (i < lim)
			line[i++] = c;
	
	if (c == '\n' || i > 0)
		line[i++] = '\n';

	line[i] = '\0';
	return i;
}

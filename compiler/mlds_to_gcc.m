%-----------------------------------------------------------------------------%
% Copyright (C) 1999-2000 The University of Melbourne.
% This file may only be copied under the terms of the GNU General
% Public License - see the file COPYING in the Mercury distribution.
%-----------------------------------------------------------------------------%

% mlds_to_gcc - Convert MLDS to the GCC back-end representation.
% Main author: fjh.

% Note that this does not compile to GNU C -- instead it
% actually generates GCC's internal "Tree" representation.

% DONE:
%	- parameter declarations
%	- local variable declarations
%	- most simple types
%	- most operators
%	- assignment
%	- if-then-else
%	- labels & goto
%	- switches
%	- tag operations
%	- output mode arguments
%	- contexts (line numbers)

% TODO:
% 	Lots. Currently this is mostly just a stub, copied from mlds_to_c.m.
%	- complicated types
%	- rest of the builtin operators
%	- while and do/while loops
%	- support --high-level-data
%	- higher-order
%	- tuples
%	- RTTI
%	- --static-ground-terms
%	- C interface
%	etc.

%-----------------------------------------------------------------------------%

:- module mlds_to_gcc.
:- interface.

:- import_module mlds.
:- use_module io.

:- pred mlds_to_gcc__compile_to_asm(mlds__mlds, io__state, io__state).
:- mode mlds_to_gcc__compile_to_asm(in, di, uo) is det.

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

:- implementation.

:- use_module gcc.

% XXX some of these imports might be unused

:- import_module ml_util.
:- import_module llds.		% XXX needed for C interface types
:- import_module llds_out.	% XXX needed for llds_out__name_mangle,
				% llds_out__sym_name_mangle,
				% llds_out__make_base_typeclass_info_name,
				% output_c_file_intro_and_grade.
:- import_module rtti.		% for rtti__addr_to_string.
:- import_module rtti_to_mlds.	% for mlds_rtti_type_name.
:- import_module hlds_pred.	% for pred_proc_id.
:- import_module ml_code_util.	% for ml_gen_mlds_var_decl, which is used by
				% the code that handles derived classes
:- import_module ml_type_gen.	% for ml_gen_type_name
:- import_module export.	% for export__type_to_type_string
:- import_module globals, options, passes_aux.
:- import_module builtin_ops, c_util, modules.
:- import_module prog_data, prog_out, type_util, error_util.

:- import_module bool, int, string, library, list, map.
:- import_module assoc_list, term, std_util, require.

%-----------------------------------------------------------------------------%

:- type output_type == pred(mlds__type, io__state, io__state).
:- inst output_type = (pred(in, di, uo) is det).

%-----------------------------------------------------------------------------%

	%
	% XXX at some point we should also handle output of any
	%     foreign code (C, Ada, Fortran, etc.) to appropriate files.

mlds_to_gcc__compile_to_asm(MLDS) -->
	{ Indent = 0 },
	{ MLDS = mlds(ModuleName, ForeignCode, _Imports, Defns) },
	mlds_output_c_defns(MLDS_ModuleName, Indent, ForeignCode), io__nl,
	%
	% We need to generate
	%	#1. definitions of the types,
	% 	#2. forward-declarations of the non-types
	%	#3. definitions of all the non-types
	%	#4. initialization functions
	% in that order. 
	% #2 is needed to allow #3 to contain forward references,
	% which can arise for e.g. mutually recursive procedures.
	% #1 is needed since #2 may refer to the types.
	%
	% Note that we don't forward-declare the types here; the
	% forward declarations that we need for types used in function
	% prototypes are generated by mlds_output_type_forward_decls.
	% See the comment in mlds_output_decl.
	% 
	{ list__filter(defn_is_type, Defns, TypeDefns, NonTypeDefns) },
	{ MLDS_ModuleName = mercury_module_name_to_mlds(ModuleName) },
	gen_defns(MLDS_ModuleName, TypeDefns), io__nl,
	% mlds_output_decls(Indent, MLDS_ModuleName, NonTypeDefns), io__nl,
	gen_defns(MLDS_ModuleName, NonTypeDefns), io__nl,
	mlds_output_init_fn_defns(MLDS_ModuleName), io__nl.


	% XXX not yet:
/****
	{ list__filter(defn_is_function, NonTypeDefns, FuncDefns) },
	{ list__filter(defn_is_type_ctor_info, NonTypeDefns,
		TypeCtorInfoDefns) },
	mlds_output_init_fn_defns(MLDS_ModuleName, FuncDefns,
	 	TypeCtorInfoDefns), io__nl,
	mlds_output_grade_var, io__nl.
*****/

	%
	% Output a reference to the mangled grade name for the grade
	% that the C file gets compiled with.  This ensures that
	% we don't try to link objects files compiled in different
	% grades.
	%
:- pred mlds_output_grade_var(io__state::di, io__state::uo) is det.
mlds_output_grade_var -->
	io__write_string(
		"/* ensure everything is compiled with the same grade */\n"),
	io__write_string(
		"static const void *const MR_grade = &MR_GRADE_VAR;\n").

%-----------------------------------------------------------------------------%

	%
	% Maybe output the function `mercury__<modulename>__init()'.
	% The body of the function consists of calls
	% MR_init_entry(<function>) for each function defined in the
	% module.
	%
:- pred mlds_output_init_fn_decls(mlds_module_name::in,
		io__state::di, io__state::uo) is det.

mlds_output_init_fn_decls(ModuleName) -->
	output_init_fn_name(ModuleName, ""),
	io__write_string(";\n"),
	output_init_fn_name(ModuleName, "_type_tables"),
	io__write_string(";\n"),
	output_init_fn_name(ModuleName, "_debugger"),
	io__write_string(";\n").

:- pred mlds_output_init_fn_defns(mlds_module_name::in, mlds__defns::in,
		mlds__defns::in, io__state::di, io__state::uo) is det.

mlds_output_init_fn_defns(ModuleName, FuncDefns, TypeCtorInfoDefns) -->
	output_init_fn_name(ModuleName, ""),
	io__write_string("\n{\n"),
	io_get_globals(Globals),
	(
		{ need_to_init_entries(Globals) },
		{ FuncDefns \= [] }
	->
		io__write_strings(["\tstatic bool initialised = FALSE;\n",
				"\tif (initialised) return;\n",
				"\tinitialised = TRUE;\n\n"]),
		mlds_output_calls_to_init_entry(ModuleName, FuncDefns)
	;
		[]
	),
	io__write_string("}\n\n"),

	output_init_fn_name(ModuleName, "_type_tables"),
	io__write_string("\n{\n"),
	(
		{ TypeCtorInfoDefns \= [] }
	->
		io__write_strings(["\tstatic bool initialised = FALSE;\n",
				"\tif (initialised) return;\n",
				"\tinitialised = TRUE;\n\n"]),
		mlds_output_calls_to_register_tci(ModuleName,
			TypeCtorInfoDefns)
	;
		[]
	),
	io__write_string("}\n\n"),

	output_init_fn_name(ModuleName, "_debugger"),
	io__write_string("\n{\n"),
	io__write_string(
	    "\tMR_fatal_error(""debugger initialization in MLDS grade"");\n"),
	io__write_string("}\n").

:- pred output_init_fn_name(mlds_module_name::in, string::in,
		io__state::di, io__state::uo) is det.

output_init_fn_name(ModuleName, Suffix) -->
		% Here we ensure that we only get one "mercury__" at the
		% start of the function name.
	{ prog_out__sym_name_to_string(
			mlds_module_name_to_sym_name(ModuleName), "__", 
			ModuleNameString0) },
	{
		string__prefix(ModuleNameString0, "mercury__")
	->
		ModuleNameString = ModuleNameString0
	;
		string__append("mercury__", ModuleNameString0,
				ModuleNameString)
	},
	io__write_string("void "),
	io__write_string(ModuleNameString),
	io__write_string("__init"),
	io__write_string(Suffix),
	io__write_string("(void)").

:- pred need_to_init_entries(globals::in) is semidet.
need_to_init_entries(Globals) :-
	% We only need to output calls to MR_init_entry() if profiling is
	% enabled.  (It would be OK to output the calls regardless, since
	% they will macro-expand to nothing if profiling is not enabled,
	% but for readability of the generated code we prefer not to.)
	( Option = profile_calls
	; Option = profile_time
	; Option = profile_memory
	),
	globals__lookup_bool_option(Globals, Option, yes).

	% Generate calls to MR_init_entry() for the specified functions.
	%
:- pred mlds_output_calls_to_init_entry(mlds_module_name::in, mlds__defns::in,
		io__state::di, io__state::uo) is det.

mlds_output_calls_to_init_entry(_ModuleName, []) --> [].
mlds_output_calls_to_init_entry(ModuleName, [FuncDefn | FuncDefns]) --> 
	{ FuncDefn = mlds__defn(EntityName, _, _, _) },
	io__write_string("\tMR_init_entry("),
	mlds_output_fully_qualified_name(qual(ModuleName, EntityName)),
	io__write_string(");\n"),
	mlds_output_calls_to_init_entry(ModuleName, FuncDefns).

	% Generate calls to MR_register_type_ctor_info() for the specified
	% type_ctor_infos.
	%
:- pred mlds_output_calls_to_register_tci(mlds_module_name::in, mlds__defns::in,
		io__state::di, io__state::uo) is det.

mlds_output_calls_to_register_tci(_ModuleName, []) --> [].
mlds_output_calls_to_register_tci(ModuleName,
		[TypeCtorInfoDefn | TypeCtorInfoDefns]) --> 
	{ TypeCtorInfoDefn = mlds__defn(EntityName, _, _, _) },
	io__write_string("\tMR_register_type_ctor_info(&"),
	mlds_output_fully_qualified_name(qual(ModuleName, EntityName)),
	io__write_string(");\n"),
	mlds_output_calls_to_register_tci(ModuleName, TypeCtorInfoDefns).

%-----------------------------------------------------------------------------%
%
% Foreign language interface stuff
%

:- pred mlds_output_c_hdr_decls(mlds_module_name, indent, mlds__foreign_code,
		io__state, io__state).
:- mode mlds_output_c_hdr_decls(in, in, in, di, uo) is det.

mlds_output_c_hdr_decls(ModuleName, Indent, ForeignCode) -->
	{ ForeignCode = mlds__foreign_code(RevHeaderCode, _RevBodyCode,
		ExportDefns) },
	{ HeaderCode = list__reverse(RevHeaderCode) },
	io__write_list(HeaderCode, "\n", mlds_output_c_hdr_decl(Indent)),
	io__write_string("\n"),
	io__write_list(ExportDefns, "\n",
			mlds_output_pragma_export_decl(ModuleName, Indent)).

:- pred mlds_output_c_hdr_decl(indent,
	foreign_decl_code, io__state, io__state).
:- mode mlds_output_c_hdr_decl(in, in, di, uo) is det.

mlds_output_c_hdr_decl(_Indent, foreign_decl_code(Lang, Code, Context)) -->
		% only output C code in the C header file.
	( { Lang = c } ->
		mlds_output_context(mlds__make_context(Context)),
		io__write_string(Code)
	;
		{ sorry(this_file, "foreign code other than C") }
	).

:- pred mlds_output_c_decls(indent, mlds__foreign_code,
	io__state, io__state).
:- mode mlds_output_c_decls(in, in, di, uo) is det.

% all of the declarations go in the header file or as c_code
mlds_output_c_decls(_, _) --> [].

:- pred mlds_output_c_defns(mlds_module_name, indent, mlds__foreign_code,
		io__state, io__state).
:- mode mlds_output_c_defns(in, in, in, di, uo) is det.

mlds_output_c_defns(ModuleName, Indent, ForeignCode) -->
	{ ForeignCode = mlds__foreign_code(_RevHeaderCode, RevBodyCode,
		ExportDefns) },
	{ BodyCode = list__reverse(RevBodyCode) },
	io__write_list(BodyCode, "\n", mlds_output_c_defn(Indent)),
	io__write_string("\n"),
	io__write_list(ExportDefns, "\n",
			mlds_output_pragma_export_defn(ModuleName, Indent)).

:- pred mlds_output_c_defn(indent, user_foreign_code,
	io__state, io__state).
:- mode mlds_output_c_defn(in, in, di, uo) is det.

mlds_output_c_defn(_Indent, user_foreign_code(c, Code, Context)) -->
	mlds_output_context(mlds__make_context(Context)),
	io__write_string(Code).
mlds_output_c_defn(_Indent, user_foreign_code(managed_cplusplus, _, _)) -->
	{ sorry(this_file, "foreign code other than C") }.

:- pred mlds_output_pragma_export_decl(mlds_module_name, indent,
		mlds__pragma_export, io__state, io__state).
:- mode mlds_output_pragma_export_decl(in, in, in, di, uo) is det.

mlds_output_pragma_export_decl(ModuleName, Indent, PragmaExport) -->
	mlds_output_pragma_export_func_name(ModuleName, Indent, PragmaExport),
	io__write_string(";").

:- pred mlds_output_pragma_export_defn(mlds_module_name, indent,
		mlds__pragma_export, io__state, io__state).
:- mode mlds_output_pragma_export_defn(in, in, in, di, uo) is det.

mlds_output_pragma_export_defn(ModuleName, Indent, PragmaExport) -->
	{ PragmaExport = ml_pragma_export(_C_name, MLDS_Name, MLDS_Signature,
			Context) },
	mlds_output_pragma_export_func_name(ModuleName, Indent, PragmaExport),
	io__write_string("\n"),
	mlds_indent(Context, Indent),
	io__write_string("{\n"),
	mlds_indent(Context, Indent),
	mlds_output_pragma_export_defn_body(ModuleName, MLDS_Name,
				MLDS_Signature),
	io__write_string("}\n").

:- pred mlds_output_pragma_export_func_name(mlds_module_name, indent,
		mlds__pragma_export, io__state, io__state).
:- mode mlds_output_pragma_export_func_name(in, in, in, di, uo) is det.

mlds_output_pragma_export_func_name(ModuleName, Indent,
		ml_pragma_export(C_name, _MLDS_Name, Signature, Context)) -->
	{ Name = qual(ModuleName, export(C_name)) },
	mlds_indent(Context, Indent),
	% For functions exported using `pragma export',
	% we use the default C calling convention.
	{ CallingConvention = "" },
	mlds_output_func_decl_ho(Indent, Name, Context,
			CallingConvention, Signature,
			mlds_output_pragma_export_type(prefix),
			mlds_output_pragma_export_type(suffix)).

:- type locn ---> prefix ; suffix.
:- pred mlds_output_pragma_export_type(locn, mlds__type, io__state, io__state).
:- mode mlds_output_pragma_export_type(in, in, di, uo) is det.

mlds_output_pragma_export_type(suffix, _Type) --> [].
mlds_output_pragma_export_type(prefix, mercury_type(Type, _)) -->
	{ export__type_to_type_string(Type, String) },
	io__write_string(String).
mlds_output_pragma_export_type(prefix, mlds__cont_type(_)) -->
	io__write_string("MR_Word").
mlds_output_pragma_export_type(prefix, mlds__commit_type) -->
	io__write_string("MR_Word").
mlds_output_pragma_export_type(prefix, mlds__native_bool_type) -->
	io__write_string("MR_Word").
mlds_output_pragma_export_type(prefix, mlds__native_int_type) -->
	io__write_string("MR_Integer").
mlds_output_pragma_export_type(prefix, mlds__native_float_type) -->
	io__write_string("MR_Float").
mlds_output_pragma_export_type(prefix, mlds__native_char_type) -->
	io__write_string("MR_Char").
mlds_output_pragma_export_type(prefix, mlds__class_type(_, _, _)) -->
	io__write_string("MR_Word").
mlds_output_pragma_export_type(prefix, mlds__array_type(_)) -->
	io__write_string("MR_Word").
mlds_output_pragma_export_type(prefix, mlds__ptr_type(Type)) -->
	mlds_output_pragma_export_type(prefix, Type),
	io__write_string(" *").
mlds_output_pragma_export_type(prefix, mlds__func_type(_)) -->
	io__write_string("MR_Word").
mlds_output_pragma_export_type(prefix, mlds__generic_type) -->
	io__write_string("MR_Word").
mlds_output_pragma_export_type(prefix, mlds__generic_env_ptr_type) -->
	io__write_string("MR_Word").
mlds_output_pragma_export_type(prefix, mlds__pseudo_type_info_type) -->
	io__write_string("MR_Word").
mlds_output_pragma_export_type(prefix, mlds__rtti_type(_)) -->
	io__write_string("MR_Word").
	

	%
	% Output the definition body for a pragma export
	%
:- pred mlds_output_pragma_export_defn_body(mlds_module_name,
		mlds__qualified_entity_name, func_params, io__state, io__state).
:- mode mlds_output_pragma_export_defn_body(in, in, in, di, uo) is det.

mlds_output_pragma_export_defn_body(ModuleName, FuncName, Signature) -->
	{ Signature = mlds__func_params(Parameters, RetTypes) },

	( { RetTypes = [] } ->
		io__write_string("\t")
	; { RetTypes = [RetType] } ->
		io__write_string("\treturn ("),
		mlds_output_pragma_export_type(prefix, RetType),
		mlds_output_pragma_export_type(suffix, RetType),
		io__write_string(") ")
	;
		{ error("mlds_output_pragma_export: multiple return types") }
	),

	mlds_output_fully_qualified_name(FuncName),
	io__write_string("("),
	io__write_list(Parameters, ", ",
			mlds_output_name_with_cast(ModuleName)),
	io__write_string(");\n").


	%
	% Write out the arguments to the MLDS function.  Note the last
	% in the list of the arguments is the return value, so it must
	% be "&arg"
	%
:- pred write_func_args(mlds_module_name::in, mlds__arguments::in,
		io__state::di, io__state::uo) is det.

write_func_args(_ModuleName, []) -->
	{ error("write_func_args: empty list") }.
write_func_args(_ModuleName, [_Arg]) -->
	io__write_string("&arg").
write_func_args(ModuleName, [Arg | Args]) -->
	{ Args = [_|_] },
	mlds_output_name_with_cast(ModuleName, Arg),
	io__write_string(", "),
	write_func_args(ModuleName, Args).

	%
	% Output a fully qualified name preceded by a cast.
	%
:- pred mlds_output_name_with_cast(mlds_module_name::in,
		pair(mlds__entity_name, mlds__type)::in,
		io__state::di, io__state::uo) is det.

mlds_output_name_with_cast(ModuleName, Name - Type) -->
	mlds_output_cast(Type),
	mlds_output_fully_qualified_name(qual(ModuleName, Name)).

	%
	% Generates the signature for det functions in the forward mode.
	%
:- func det_func_signature(mlds__func_params) = mlds__func_params.

det_func_signature(mlds__func_params(Args, _RetTypes)) = Params :-
	list__length(Args, NumArgs),
	NumFuncArgs is NumArgs - 1,
	( list__split_list(NumFuncArgs, Args, InputArgs0, [ReturnArg0]) ->
		InputArgs = InputArgs0,
		ReturnArg = ReturnArg0
	;
		error("det_func_signature: function missing return value?")
	),
	(
		ReturnArg = _ReturnArgName - mlds__ptr_type(ReturnArgType0)
	->
		ReturnArgType = ReturnArgType0
	;
		error("det_func_signature: function return type!")
	),
	Params = mlds__func_params(InputArgs, [ReturnArgType]).
	
%-----------------------------------------------------------------------------%
%
% Code to output declarations and definitions
%


:- pred gen_defns(mlds_module_name, mlds__defns,
		io__state, io__state).
:- mode gen_defns(in, in, di, uo) is det.

gen_defns(ModuleName, Defns) -->
	{ OutputDefn = gen_defn(ModuleName) },
	globals__io_lookup_bool_option(gcc_local_labels, GCC_LocalLabels),
	( { GCC_LocalLabels = yes } ->
		%
		% GNU C __label__ declarations must precede
		% ordinary variable declarations.
		%
		{ list__filter(defn_is_commit_type_var, Defns, LabelDecls,
			OtherDefns) },
		list__foldl(OutputDefn, LabelDecls),
		list__foldl(OutputDefn, OtherDefns)
	;
		list__foldl(OutputDefn, Defns)
	).

:- pred build_local_defns(mlds__defns, func_info, mlds_module_name, 
		symbol_table, symbol_table, io__state, io__state).
:- mode build_local_defns(in, in, in, in, out, di, uo) is det.

build_local_defns([], _, _, SymbolTable, SymbolTable) --> [].
build_local_defns([Defn|Defns], FuncInfo, ModuleName, SymbolTable0, SymbolTable) -->
	build_local_defn(Defn, FuncInfo, ModuleName, GCC_Defn),
	% Insert the variable definition into our symbol table.
	% The MLDS code that the MLDS code generator generates should
	% not have any shadowing of parameters or local variables by
	% nested local variables, so we use map__det_insert rather
	% than map__set here.  (Actually nothing in this module depends
	% on it, so this sanity here is perhaps a bit paranoid.)
	{ Defn = mlds__defn(Name, _, _, _) },
	{ SymbolTable1 = map__det_insert(SymbolTable0,
		qual(ModuleName, Name), GCC_Defn) },
	build_local_defns(Defns, FuncInfo, ModuleName, SymbolTable1, SymbolTable).

:- pred gen_defn(mlds_module_name, mlds__defn,
		io__state, io__state).
:- mode gen_defn(in, in, di, uo) is det.

gen_defn(ModuleName, Defn) -->
	{ Defn = mlds__defn(Name, Context, _Flags, DefnBody) },
	% mlds_output_decl_flags(Flags, definition, Name, DefnBody),
	gen_defn_body(qual(ModuleName, Name), Context,
			DefnBody).

:- pred build_local_defn(mlds__defn, func_info, mlds_module_name, gcc__var_decl,
		io__state, io__state).
:- mode build_local_defn(in, in, in, out, di, uo) is det.

build_local_defn(Defn, FuncInfo, ModuleName, GCC_Defn) -->
	{ Defn = mlds__defn(Name, Context, _Flags, DefnBody) },
	% mlds_output_decl_flags(Flags, definition, Name, DefnBody),
	build_local_defn_body(qual(ModuleName, Name), FuncInfo, Context, DefnBody,
		GCC_Defn).

:- pred gen_defn_body(mlds__qualified_entity_name,
		mlds__context, mlds__entity_defn, io__state, io__state).
:- mode gen_defn_body(in, in, in, di, uo) is det.

gen_defn_body(Name, Context, DefnBody) -->
	(
		{ DefnBody = mlds__data(Type, Initializer) },
		mlds_output_data_defn(Name, Type, Initializer)
	;
		{ DefnBody = mlds__function(MaybePredProcId, Signature,
			MaybeBody) },
		mlds_output_maybe(MaybePredProcId, mlds_output_pred_proc_id),
		gen_func(Name, Context, Signature, MaybeBody)
	;
		{ DefnBody = mlds__class(ClassDefn) },
		{ Indent = 0 },
		mlds_output_class(Indent, Name, Context, ClassDefn)
	).

:- pred build_local_defn_body(mlds__qualified_entity_name, func_info,
		mlds__context, mlds__entity_defn, gcc__var_decl,
		io__state, io__state).
:- mode build_local_defn_body(in, in, in, in, out, di, uo) is det.

build_local_defn_body(Name, FuncInfo, Context, DefnBody, GCC_Defn) -->
	(
		{ DefnBody = mlds__data(Type, Initializer) },
		build_local_data_defn(Name, Type, Initializer, FuncInfo, GCC_Defn)
	;
		{ DefnBody = mlds__function(MaybePredProcId, Signature,
			MaybeBody) },
		{ sorry(this_file, "nested function") },
		mlds_output_maybe(MaybePredProcId, mlds_output_pred_proc_id),
		gen_func(Name, Context, Signature, MaybeBody)
	;
		{ DefnBody = mlds__class(ClassDefn) },
		{ sorry(this_file, "nested type") },
		mlds_output_class(0, Name, Context, ClassDefn)
	).

:- pred build_local_data_defn(mlds__qualified_entity_name, mlds__type,
		mlds__initializer, func_info, gcc__var_decl,
		io__state, io__state).
:- mode build_local_data_defn(in, in, in, in, out, di, uo) is det.

build_local_data_defn(Name, Type, Initializer, FuncInfo, GCC_Defn) -->
	build_type(Type, initializer_array_size(Initializer), GCC_Type),
	{ Name = qual(_ModuleName, UnqualName) },
	( { UnqualName = data(var(VarName)) } ->
		gcc__build_local_var_decl(VarName, GCC_Type, GCC_Defn)
	;
		{ sorry(this_file, "build_local_data_defn: non-var") }
	),
	( { Initializer = no_initializer } ->
		[]
	;
		build_initializer(Initializer, Type, FuncInfo, GCC_Expr),
		gcc__gen_assign(gcc__var_expr(GCC_Defn), GCC_Expr)
	).

:- pred build_initializer(mlds__initializer, mlds__type, func_info,
		gcc__expr, io__state, io__state) is det.
:- mode build_initializer(in, in, in, out, di, uo) is det.

build_initializer(Initializer, Type, FuncInfo, GCC_Expr) -->
	(
		{ Initializer = no_initializer },
		{ unexpected(this_file, "no_initializer (build_initializer)") }
	;
		{ Initializer = init_obj(Rval) },
		build_rval(Rval, FuncInfo, GCC_Expr)
	;
		{ Initializer = init_struct(_) },
		{ sorry(this_file, "init_struct") }
	;
		{ Initializer = init_array(InitList) },
		{ Type = mlds__array_type(ElemType0) ->
			ElemType = ElemType0
		;
			% XXX we assume that for everything else,
			% the argument type must be MR_Box
			ElemType = mlds__generic_type
		},
		build_array_initializer(InitList, ElemType, 0, FuncInfo,
			GCC_InitList),
		build_type(Type, initializer_array_size(Initializer), GCC_Type),
		gcc__build_initializer_expr(GCC_InitList, GCC_Type, GCC_Expr)
	).

:- pred build_array_initializer(list(mlds__initializer), mlds__type, int,
		func_info, gcc__init_list, io__state, io__state) is det.
:- mode build_array_initializer(in, in, in, in, out, di, uo) is det.

build_array_initializer([], _, _, _, GCC_InitList) -->
	gcc__empty_init_list(GCC_InitList).
build_array_initializer([Init | Inits], ElemType, Index, FuncInfo,
		GCC_InitList) -->
	build_array_initializer(Inits, ElemType, Index + 1, FuncInfo,
		GCC_InitList0),
	gcc__init_array_elem(Index, GCC_Index),
	build_initializer(Init, ElemType, FuncInfo, GCC_Init),
	gcc__cons_init_list(GCC_Index, GCC_Init, GCC_InitList0, GCC_InitList).

%-----------------------------------------------------------------------------%
%
% Code to output type declarations/definitions
%

:- pred mlds_output_class_decl(indent, mlds__qualified_entity_name,
		mlds__class_defn, io__state, io__state).
:- mode mlds_output_class_decl(in, in, in, di, uo) is det.

mlds_output_class_decl(_Indent, Name, ClassDefn) -->
	( { ClassDefn^kind = mlds__enum } ->
		io__write_string("enum "),
		mlds_output_fully_qualified_name(Name),
		io__write_string("_e")
	;
		io__write_string("struct "),
		mlds_output_fully_qualified_name(Name),
		io__write_string("_s")
	).

:- pred mlds_output_class(indent, mlds__qualified_entity_name, mlds__context,
		mlds__class_defn, io__state, io__state).
:- mode mlds_output_class(in, in, in, in, di, uo) is det.

mlds_output_class(Indent, Name, Context, ClassDefn) -->
	%
	% To avoid name clashes, we need to qualify the names of
	% the member constants with the class name.
	% (In particular, this is needed for enumeration constants
	% and for the nested classes that we generate for constructors
	% of discriminated union types.)
	% Here we compute the appropriate qualifier.
	%
	{ Name = qual(ModuleName, UnqualName) },
	{ UnqualName = type(ClassName, ClassArity) ->
		ClassModuleName = mlds__append_class_qualifier(ModuleName,
			ClassName, ClassArity)
	;
		error("mlds_output_enum_constants")
	},

	%
	% Hoist out static members, since plain old C doesn't support
	% static members in structs (except for enumeration constants).
	%
	% XXX this should be conditional: only when compiling to C,
	% not when compiling to C++
	%
	{ ClassDefn = class_defn(Kind, _Imports, BaseClasses, _Implements,
		AllMembers) },
	( { Kind = mlds__enum } ->
		{ StaticMembers = [] },
		{ StructMembers = AllMembers }
	;
		{ list__filter(is_static_member, AllMembers, StaticMembers,
			NonStaticMembers) },
		{ StructMembers = NonStaticMembers }
	),

	%
	% Convert the base classes into member variables,
	% since plain old C doesn't support base classes.
	%
	% XXX this should be conditional: only when compiling to C,
	% not when compiling to C++
	%
	{ list__map_foldl(mlds_make_base_class(Context),
		BaseClasses, BaseDefns, 1, _) },
	{ list__append(BaseDefns, StructMembers, BasesAndMembers) },

	%
	% Output the class declaration and the class members.
	% We treat enumerations specially.
	%
	mlds_output_class_decl(Indent, Name, ClassDefn),
	io__write_string(" {\n"),
	( { Kind = mlds__enum } ->
		mlds_output_enum_constants(Indent + 1, ClassModuleName,
			BasesAndMembers)
	;
		[]
		% XXX FIXME
		% mlds_output_defns(Indent + 1, ClassModuleName,
		% 	BasesAndMembers)
	),
	mlds_indent(Context, Indent),
	io__write_string("};\n"),
	gen_defns(ClassModuleName, StaticMembers).

:- pred is_static_member(mlds__defn::in) is semidet.

is_static_member(Defn) :-
	Defn = mlds__defn(Name, _, Flags, _),
	(	Name = type(_, _)
	;	per_instance(Flags) = one_copy
	).

	% Convert a base class class_id into a member variable
	% that holds the value of the base class.
	%
:- pred mlds_make_base_class(mlds__context, mlds__class_id, mlds__defn,
		int, int).
:- mode mlds_make_base_class(in, in, out, in, out) is det.

mlds_make_base_class(Context, ClassId, MLDS_Defn, BaseNum0, BaseNum) :-
	BaseName = string__format("base_%d", [i(BaseNum0)]),
	Type = ClassId,
	MLDS_Defn = ml_gen_mlds_var_decl(var(BaseName), Type, Context),
	BaseNum = BaseNum0 + 1.

	% Output the definitions of the enumeration constants
	% for an enumeration type.
	%
:- pred mlds_output_enum_constants(indent, mlds_module_name,
		mlds__defns, io__state, io__state).
:- mode mlds_output_enum_constants(in, in, in, di, uo) is det.

mlds_output_enum_constants(Indent, EnumModuleName, Members) -->
	%
	% Select the enumeration constants from the list of members
	% for this enumeration type, and output them.
	%
	{ EnumConsts = list__filter(is_enum_const, Members) },
	io__write_list(EnumConsts, ",\n",
		mlds_output_enum_constant(Indent, EnumModuleName)),
	io__nl.

	% Test whether one of the members of an mlds__enum class
	% is an enumeration constant.
	%
:- pred is_enum_const(mlds__defn).
:- mode is_enum_const(in) is semidet.

is_enum_const(Defn) :-
	Defn = mlds__defn(_Name, _Context, Flags, _DefnBody),
	constness(Flags) = const.

	% Output the definition of a single enumeration constant.
	%
:- pred mlds_output_enum_constant(indent, mlds_module_name, mlds__defn,
		io__state, io__state).
:- mode mlds_output_enum_constant(in, in, in, di, uo) is det.

mlds_output_enum_constant(Indent, EnumModuleName, Defn) -->
	{ Defn = mlds__defn(Name, Context, _Flags, DefnBody) },
	(
		{ DefnBody = data(Type, Initializer) }
	->
		mlds_indent(Context, Indent),
		mlds_output_fully_qualified_name(qual(EnumModuleName, Name)),
		mlds_output_initializer(Type, Initializer)
	;
		{ error("mlds_output_enum_constant: constant is not data") }
	).

%-----------------------------------------------------------------------------%
%
% Code to output data declarations/definitions
%

:- pred mlds_output_data_decl(mlds__qualified_entity_name, mlds__type,
			initializer_array_size, io__state, io__state).
:- mode mlds_output_data_decl(in, in, in, di, uo) is det.

mlds_output_data_decl(Name, Type, InitializerSize) -->
	mlds_output_data_decl_ho(mlds_output_type_prefix,
			(pred(Tp::in, di, uo) is det -->
				mlds_output_type_suffix(Tp, InitializerSize)),
			Name, Type).

:- pred mlds_output_data_decl_ho(output_type, output_type,
		mlds__qualified_entity_name, mlds__type, io__state, io__state).
:- mode mlds_output_data_decl_ho(in(output_type), in(output_type),
		in, in, di, uo) is det.

mlds_output_data_decl_ho(OutputPrefix, OutputSuffix, Name, Type) -->
	OutputPrefix(Type),
	io__write_char(' '),
	mlds_output_fully_qualified_name(Name),
	OutputSuffix(Type).

:- pred mlds_output_data_defn(mlds__qualified_entity_name, mlds__type,
			mlds__initializer, io__state, io__state).
:- mode mlds_output_data_defn(in, in, in, di, uo) is det.

mlds_output_data_defn(Name, Type, Initializer) -->
	mlds_output_data_decl(Name, Type, initializer_array_size(Initializer)),
	mlds_output_initializer(Type, Initializer),
	io__write_string(";\n").

:- pred mlds_output_maybe(maybe(T), pred(T, io__state, io__state),
		io__state, io__state).
:- mode mlds_output_maybe(in, pred(in, di, uo) is det, di, uo) is det.

mlds_output_maybe(MaybeValue, OutputAction) -->
	( { MaybeValue = yes(Value) } ->
		OutputAction(Value)
	;
		[]
	).

:- pred mlds_output_initializer(mlds__type, mlds__initializer,
		io__state, io__state).
:- mode mlds_output_initializer(in, in, di, uo) is det.

mlds_output_initializer(_Type, Initializer) -->
	( { mlds_needs_initialization(Initializer) = yes } ->
		io__write_string(" = "),
		mlds_output_initializer_body(Initializer)
	;
		[]
	).

:- func mlds_needs_initialization(mlds__initializer) = bool.

mlds_needs_initialization(no_initializer) = no.
mlds_needs_initialization(init_obj(_)) = yes.
mlds_needs_initialization(init_struct([])) = no.
mlds_needs_initialization(init_struct([_|_])) = yes.
mlds_needs_initialization(init_array(_)) = yes.

	% XXX ANSI/ISO C does not allow empty arrays or empty structs;
	% what we do for them here is probably not quite right.
:- pred mlds_output_initializer_body(mlds__initializer, io__state, io__state).
:- mode mlds_output_initializer_body(in, di, uo) is det.

mlds_output_initializer_body(no_initializer) --> [].
mlds_output_initializer_body(init_obj(Rval)) -->
	mlds_output_rval(Rval).
mlds_output_initializer_body(init_struct(FieldInits)) -->
	io__write_string("{\n\t\t"),
	io__write_list(FieldInits, ",\n\t\t", mlds_output_initializer_body),
	io__write_string("}").
mlds_output_initializer_body(init_array(ElementInits)) -->
	io__write_string("{\n\t\t"),
	(
		{ ElementInits = [] }
	->
			% The MS VC++ compiler only generates a symbol, if
			% the array has a known size.
		io__write_string("0")
	;
		io__write_list(ElementInits,
				",\n\t\t", mlds_output_initializer_body)
	),
	io__write_string("}").

%-----------------------------------------------------------------------------%
%
% Code to output function declarations/definitions
%

:- pred mlds_output_pred_proc_id(pred_proc_id, io__state, io__state).
:- mode mlds_output_pred_proc_id(in, di, uo) is det.

mlds_output_pred_proc_id(proc(PredId, ProcId)) -->
	globals__io_lookup_bool_option(auto_comments, AddComments),
	( { AddComments = yes } ->
		io__write_string("/* pred_id: "),
		{ pred_id_to_int(PredId, PredIdNum) },
		io__write_int(PredIdNum),
		io__write_string(", proc_id: "),
		{ proc_id_to_int(ProcId, ProcIdNum) },
		io__write_int(ProcIdNum),
		io__write_string(" */\n")
	;
		[]
	).

:- pred gen_func(qualified_entity_name, mlds__context,
		func_params, maybe(statement), io__state, io__state).
:- mode gen_func(in, in, in, in, di, uo) is det.

gen_func(Name, Context, Signature, MaybeBody) -->
	(
		{ MaybeBody = no }
	;
		{ MaybeBody = yes(Body) },
		make_func_decl_for_defn(Name, Signature, FuncDecl,
			SymbolTable),
		build_label_table(Body, LabelTable),
		{ FuncInfo = func_info(Name, Signature,
			SymbolTable, LabelTable) },
		set_context(Context),
		gcc__start_function(FuncDecl),
		% mlds_maybe_output_time_profile_instr(Context, Name)
		gen_statement(FuncInfo, Body),
		set_context(Context),
		gcc__end_function
	).

:- pred build_label_table(mlds__statement::in, label_table::out,
		io__state::di, io__state::uo) is det.
build_label_table(Statement, LabelTable) -->
	{ solutions(statement_contains_label(Statement), Labels) },
	list__map_foldl(gcc__build_label, Labels, GCC_LabelDecls),
	{ map__from_corresponding_lists(Labels, GCC_LabelDecls,
		LabelTable) }.

:- pred statement_contains_label(mlds__statement::in, mlds__label::out)
	is nondet.
statement_contains_label(Statement, Label) :-
	statement_contains_statement(Statement, SubStatement),
	SubStatement = mlds__statement(label(Label), _).

	% XXX we should lookup the existing definition, if there is one,
	% rather than always making a new one
:- pred make_func_decl(mlds__qualified_entity_name::in,
		mlds__func_signature::in, gcc__func_decl::out,
		io__state::di, io__state::uo) is det.
make_func_decl(Name, Signature, GCC_FuncDecl) -->
	{ Signature = func_signature(Arguments, ReturnTypes) },
	get_return_type(ReturnTypes, RetType),
	{ get_qualified_func_name(Name, _ModuleName, FuncName, AsmFuncName) },
	build_param_types(Arguments, GCC_Types, GCC_ParamTypes),
	build_dummy_param_decls(GCC_Types, GCC_ParamDecls),
	gcc__build_function_decl(FuncName, AsmFuncName,
		RetType, GCC_ParamTypes, GCC_ParamDecls, GCC_FuncDecl).

:- pred build_dummy_param_decls(list(gcc__type), gcc__param_decls,
		io__state, io__state).
:- mode build_dummy_param_decls(in, out, di, uo) is det.

build_dummy_param_decls([], gcc__empty_param_decls) --> [].
build_dummy_param_decls([Type | Types],
		gcc__cons_param_decls(ParamDecl, ParamDecls)) -->
	gcc__build_param_decl("<unnamed param>", Type, ParamDecl),
	build_dummy_param_decls(Types, ParamDecls).

	% Like make_func_decl, except that it fills in the
	% function parameters properly
:- pred make_func_decl_for_defn(mlds__qualified_entity_name::in,
		mlds__func_params::in, gcc__func_decl::out,
		symbol_table::out, io__state::di, io__state::uo) is det.
make_func_decl_for_defn(Name, Parameters, FuncDecl, SymbolTable) -->
	{ Parameters = func_params(Arguments, ReturnTypes) },
	get_return_type(ReturnTypes, RetType),
	{ get_qualified_func_name(Name, ModuleName, FuncName, AsmFuncName) },
	build_param_types_and_decls(Arguments, ModuleName,
		ParamTypes, ParamDecls, SymbolTable),
	gcc__build_function_decl(FuncName, AsmFuncName,
		RetType, ParamTypes, ParamDecls, FuncDecl).

:- pred get_return_type(list(mlds__type)::in, gcc__type::out,
		io__state::di, io__state::uo) is det.
get_return_type(List, GCC_Type) -->
	( { List = [] } ->
		{ GCC_Type = gcc__void_type_node }
	; { List = [Type] } ->
		build_type(Type, GCC_Type)
	;
		{ error(this_file ++ ": multiple return types") }
	).

	% get_func_name(Name, ModuleName, FuncName, AsmFuncName):
	% Get the module name and the function name.
	% `FuncName' is the name used for generating debug symbols,
	% whereas `AsmFuncName' is what we actually spit out in the
	% assembler file.
:- pred get_qualified_func_name(mlds__qualified_entity_name::in, 
		mlds_module_name::out, string::out, string::out) is det.
get_qualified_func_name(Name, ModuleName, FuncName, AsmFuncName) :-
	Name = qual(ModuleName, EntityName),
	get_func_name(EntityName, FuncName, AsmFuncName0),
	maybe_add_module_qualifier(Name, AsmFuncName0, AsmFuncName).

	% get_func_name(Name, FuncName, AsmFuncName):
	% Get the function name (without any module qualifier).
	% `FuncName' is the name used for generating debug symbols,
	% whereas `AsmFuncName' is what we actually spit out in the
	% assembler file.
:- pred get_func_name(mlds__entity_name::in, 
		string::out, string::out) is det.
get_func_name(FunctionName, FuncName, AsmFuncName) :-
	( FunctionName = function(PredLabel, ProcId, MaybeSeqNum, _PredId) ->
		%
		% Generate the AsmFuncName
		% This needs to be fully name mangled to ensure that it
		% is unique.
		%
		% XXX we should consider not appending the modenum and seqnum
		%     if they are not needed.
		%
		get_pred_label_name(PredLabel, AsmFuncName0),
		proc_id_to_int(ProcId, ProcIdNum),
		( MaybeSeqNum = yes(SeqNum) ->
			AsmFuncName = string__format("%s_%d_%d",
				[s(AsmFuncName0), i(ProcIdNum), i(SeqNum)])
		;
			AsmFuncName = string__format("%s_%d",
				[s(AsmFuncName0), i(ProcIdNum)])
		),
		%
		% Generate the FuncName.
		% This is for human consumption, and does not
		% necessarily need to be unique.
		%
		(
			PredLabel = pred(_PorF, _ModuleName, PredName, _Arity),
		  	FuncName = PredName
		;
			PredLabel = special_pred(SpecialPredName, _ModuleName,
				TypeName, _Arity),
			FuncName = SpecialPredName ++ TypeName
		)
	;
		error("get_func_name: non-function")
	).

	% XXX same as mlds_output_pred_label in mlds_to_c,
	% except that it returns a string.
:- pred get_pred_label_name(mlds__pred_label, string).
:- mode get_pred_label_name(in, out) is det.

get_pred_label_name(pred(PredOrFunc, MaybeDefiningModule, Name, Arity),
		LabelName) :-
	( PredOrFunc = predicate, Suffix = "p"
	; PredOrFunc = function, Suffix = "f"
	),
	llds_out__name_mangle(Name, MangledName),
	string__format("%s_%d_%s", [s(MangledName), i(Arity), s(Suffix)],
		LabelName0),
	( MaybeDefiningModule = yes(DefiningModule) ->
		LabelName = LabelName0 ++ "_in__" ++
			get_module_name(DefiningModule)
	;
		LabelName = LabelName0
	).
get_pred_label_name(special_pred(PredName, MaybeTypeModule,
		TypeName, TypeArity), LabelName) :-
	llds_out__name_mangle(PredName, MangledPredName),
	llds_out__name_mangle(TypeName, MangledTypeName),
	TypeNameString = string__format("%s_%d",
		[s(MangledTypeName), i(TypeArity)]),
	( MaybeTypeModule = yes(TypeModule) ->
		TypeNameList = [get_module_name(TypeModule),
			"__", TypeNameString]
	;
		TypeNameList = [TypeNameString]
	),
	LabelName = string__append_list([MangledPredName, "__" | TypeNameList]).

:- func get_module_name(module_name) = string.
get_module_name(ModuleName) = MangledModuleName :-
	llds_out__sym_name_mangle(ModuleName, MangledModuleName).

:- pred build_param_types(mlds__arg_types::in, list(gcc__type)::out,
		gcc__param_types::out, io__state::di, io__state::uo) is det.

build_param_types([], [], gcc__empty_param_types) --> [].
build_param_types([ArgType | ArgTypes], [GCC_Type | GCC_Types], ParamTypes) -->
	build_param_types(ArgTypes, GCC_Types, ParamTypes0),
	build_type(ArgType, GCC_Type),
	{ ParamTypes = gcc__cons_param_types(GCC_Type, ParamTypes0) }.

:- pred build_param_types_and_decls(mlds__arguments::in, mlds_module_name::in,
		gcc__param_types::out, gcc__param_decls::out,
		symbol_table::out, io__state::di, io__state::uo) is det.

build_param_types_and_decls([], _, gcc__empty_param_types, gcc__empty_param_decls,
		SymbolTable) -->
	{ map__init(SymbolTable) }.
build_param_types_and_decls([Arg|Args], ModuleName, ParamTypes, ParamDecls,
		SymbolTable) -->
	build_param_types_and_decls(Args, ModuleName, ParamTypes0, ParamDecls0,
		SymbolTable0),
	{ Arg = ArgName - Type },
	build_type(Type, GCC_Type),
	( { ArgName = data(var(ArgVarName)) } ->
		% XXX is it OK to throw away the module qualifier
		% on the parameter name here?  (I think it is.)
		gcc__build_param_decl(ArgVarName, GCC_Type, ParamDecl),
		{ SymbolTable = map__det_insert(SymbolTable0,
			qual(ModuleName, ArgName), ParamDecl) }
	;
		{ error("build_param_types_and_decls: invalid param name") }
	),
	{ ParamTypes = gcc__cons_param_types(GCC_Type, ParamTypes0) },
	{ ParamDecls = gcc__cons_param_decls(ParamDecl, ParamDecls0) }.

:- pred build_type(mlds__type, gcc__type, io__state, io__state).
:- mode build_type(in, out, di, uo) is det.

build_type(Type, GCC_Type) -->
	build_type(Type, no_size, GCC_Type).

:- pred build_type(mlds__type, initializer_array_size, gcc__type, io__state, io__state).
:- mode build_type(in, in, out, di, uo) is det.

build_type(mercury_type(Type, TypeCategory), _, GCC_Type) -->
	build_mercury_type(Type, TypeCategory, GCC_Type).
build_type(mlds__native_int_type, _, gcc__integer_type_node) --> [].
build_type(mlds__native_float_type, _, gcc__double_type_node) --> [].
build_type(mlds__native_bool_type, _, gcc__boolean_type_node) --> [].
build_type(mlds__native_char_type, _, gcc__char_type_node)  --> [].
build_type(mlds__class_type(Name, Arity, ClassKind), _, GCC_Type) -->
	( { ClassKind = mlds__enum } ->
		%
		% XXX following comment is wrong for gcc back-end
		%
		% We can't just use the enumeration type,
		% since the enumeration type's definition
		% is not guaranteed to be in scope at this point.
		% (Fixing that would be somewhat complicated; it would
		% require writing enum definitions to a separate header file.)
		% Also the enumeration might not be word-sized,
		% which would cause problems for e.g. `std_util:arg/2'.
		% So we just use `MR_Integer'.
		%
		{ GCC_Type = 'MR_Integer' }
	;
		% For struct types it's OK to output an incomplete type,
		% since don't use these types directly, we only
		% use pointers to them.
		{ Name = qual(ModuleName, TypeName) },
		{ EntityName = qual(ModuleName, type(TypeName, Arity)) },
		{ UnqualAsmName = build_name(type(TypeName, Arity)) },
		{ maybe_add_module_qualifier(EntityName, UnqualAsmName,
			AsmName) },
		% XXX FIXME
		{ GCC_Type = 'MR_Word' },
		io__write_string("class_type "),
		io__write_string(AsmName),
		io__nl
	).
build_type(mlds__ptr_type(Type), _, GCC_PtrType) -->
	build_type(Type, GCC_Type),
	gcc__build_pointer_type(GCC_Type, GCC_PtrType).
build_type(mlds__array_type(Type), ArraySize, GCC_ArrayType) -->
	build_type(Type, GCC_Type),
	{ ArraySize = no_size, Size = 0
	; ArraySize = array_size(Size) 
	},
	gcc__build_array_type(GCC_Type, Size, GCC_ArrayType).
build_type(mlds__func_type(_FuncParams), _, _) -->
	{ sorry(this_file, "func_type") }.
build_type(mlds__generic_type, _, 'MR_Box') --> [].
build_type(mlds__generic_env_ptr_type, _, gcc__ptr_type_node) --> [].
build_type(mlds__pseudo_type_info_type, _, _) -->
	{ sorry(this_file, "pseudo_type_info") }.
	% io__write_string("MR_PseudoTypeInfo").
build_type(mlds__cont_type(ArgTypes), _, _) -->
	{ sorry(this_file, "cont_type") },
	( { ArgTypes = [] } ->
		globals__io_lookup_bool_option(gcc_nested_functions,
			GCC_NestedFuncs),
		( { GCC_NestedFuncs = yes } ->
			io__write_string("MR_NestedCont")
		;
			io__write_string("MR_Cont")
		)
	;
		% This case only happens for --nondet-copy-out
		io__write_string("void MR_CALL (*")
	).
build_type(mlds__commit_type, _, _) -->
	{ sorry(this_file, "commit_type") },
	globals__io_lookup_bool_option(gcc_local_labels, GCC_LocalLabels),
	( { GCC_LocalLabels = yes } ->
		io__write_string("__label__")
	;
		io__write_string("jmp_buf")
	).
build_type(mlds__rtti_type(RttiName), _, _) -->
	{ sorry(this_file, "rtti_type") },
	io__write_string("MR_"),
	io__write_string(mlds_rtti_type_name(RttiName)).



:- pred mlds_output_func_decl(indent, qualified_entity_name, mlds__context,
		func_params, io__state, io__state).
:- mode mlds_output_func_decl(in, in, in, in, di, uo) is det.

mlds_output_func_decl(Indent, QualifiedName, Context, Signature) -->
	{ CallingConvention = "MR_CALL " },
	mlds_output_func_decl_ho(Indent, QualifiedName, Context, 
			CallingConvention, Signature,
			mlds_output_type_prefix, mlds_output_type_suffix).

:- pred mlds_output_func_decl_ho(indent, qualified_entity_name, mlds__context,
		string, func_params, output_type, output_type,
		io__state, io__state).
:- mode mlds_output_func_decl_ho(in, in, in, in, in, in(output_type),
		in(output_type), di, uo) is det.

mlds_output_func_decl_ho(Indent, QualifiedName, Context,
		CallingConvention, Signature, OutputPrefix, OutputSuffix) -->
	{ Signature = mlds__func_params(Parameters, RetTypes) },
	( { RetTypes = [] } ->
		io__write_string("void")
	; { RetTypes = [RetType] } ->
		OutputPrefix(RetType)
	;
		io__write_string("\n#error multiple return types\n")
		% { error("mlds_output_func: multiple return types") }
	),
	io__write_char(' '),
	io__write_string(CallingConvention),
	mlds_output_fully_qualified_name(QualifiedName),
	{ QualifiedName = qual(ModuleName, _) },
	mlds_output_params(OutputPrefix, OutputSuffix,
			Indent, ModuleName, Context, Parameters),
	( { RetTypes = [RetType2] } ->
		OutputSuffix(RetType2)
	;
		[]
	).

:- pred mlds_output_params(output_type, output_type,
		indent, mlds_module_name, mlds__context,
		mlds__arguments, io__state, io__state).
:- mode mlds_output_params(in(output_type), in(output_type),
		in, in, in, in, di, uo) is det.

mlds_output_params(OutputPrefix, OutputSuffix, Indent, ModuleName,
		Context, Parameters) -->
	io__write_char('('),
	( { Parameters = [] } ->
		io__write_string("void")
	;
		io__nl,
		io__write_list(Parameters, ",\n",
			mlds_output_param(OutputPrefix, OutputSuffix,
				Indent + 1, ModuleName, Context))
	),
	io__write_char(')').

:- pred mlds_output_param(output_type, output_type,
		indent, mlds_module_name, mlds__context,
		pair(mlds__entity_name, mlds__type), io__state, io__state).
:- mode mlds_output_param(in(output_type), in(output_type),
		in, in, in, in, di, uo) is det.


mlds_output_param(OutputPrefix, OutputSuffix, Indent,
		ModuleName, Context, Name - Type) -->
	mlds_indent(Context, Indent),
	mlds_output_data_decl_ho(OutputPrefix, OutputSuffix,
			qual(ModuleName, Name), Type).

:- pred mlds_output_func_type_prefix(func_params, io__state, io__state).
:- mode mlds_output_func_type_prefix(in, di, uo) is det.

mlds_output_func_type_prefix(Params) -->
	{ Params = mlds__func_params(_Parameters, RetTypes) },
	( { RetTypes = [] } ->
		io__write_string("void")
	; { RetTypes = [RetType] } ->
		mlds_output_type(RetType)
	;
		{ error("mlds_output_func_type_prefix: multiple return types") }
	),
	% Note that mlds__func_type actually corresponds to a
	% function _pointer_ type in C.  This is necessary because
	% function types in C are not first class.
	io__write_string(" MR_CALL (*").

:- pred mlds_output_func_type_suffix(func_params, io__state, io__state).
:- mode mlds_output_func_type_suffix(in, di, uo) is det.

mlds_output_func_type_suffix(Params) -->
	{ Params = mlds__func_params(Parameters, _RetTypes) },
	io__write_string(")"),
	mlds_output_param_types(Parameters).

:- pred mlds_output_param_types(mlds__arguments, io__state, io__state).
:- mode mlds_output_param_types(in, di, uo) is det.

mlds_output_param_types(Parameters) -->
	io__write_char('('),
	( { Parameters = [] } ->
		io__write_string("void")
	;
		io__write_list(Parameters, ", ", mlds_output_param_type)
	),
	io__write_char(')').

:- pred mlds_output_param_type(pair(mlds__entity_name, mlds__type),
		io__state, io__state).
:- mode mlds_output_param_type(in, di, uo) is det.

mlds_output_param_type(_Name - Type) -->
	mlds_output_type(Type).

%-----------------------------------------------------------------------------%
%
% Code to output names of various entities
%

:- pred maybe_add_module_qualifier(mlds__qualified_entity_name::in,
		string::in, string::out) is det.
maybe_add_module_qualifier(QualifiedName, AsmName0, AsmName) :-
	QualifiedName = qual(ModuleName, Name),
	(
		(
			%
			% don't module-qualify main/2
			%
			Name = function(PredLabel, _, _, _),
			PredLabel = pred(predicate, no, "main", 2)
		;
			%
			% don't module-qualify base_typeclass_infos
			%
			% We don't want to include the module name as part
			% of the name if it is a base_typeclass_info, since
			% we _want_ to cause a link error for overlapping
			% instance decls, even if they are in a different
			% module
			%
			Name = data(base_typeclass_info(_, _))
		;
			% We don't module qualify pragma export names.
			Name = export(_)
		)
	->
		AsmName = AsmName0
	;
		ModuleSymName = mlds_module_name_to_sym_name(ModuleName),
		AsmName = string__format("%s__%s",
			[s(get_module_name(ModuleSymName)), s(AsmName0)])
	).

:- pred mlds_output_fully_qualified_name(mlds__qualified_entity_name,
		io__state, io__state).
:- mode mlds_output_fully_qualified_name(in, di, uo) is det.

mlds_output_fully_qualified_name(QualifiedName) -->
	{ QualifiedName = qual(_ModuleName, Name) },
	(
		(
			%
			% don't module-qualify main/2
			%
			{ Name = function(PredLabel, _, _, _) },
			{ PredLabel = pred(predicate, no, "main", 2) }
		;
			%
			% don't module-qualify base_typeclass_infos
			%
			% We don't want to include the module name as part
			% of the name if it is a base_typeclass_info, since
			% we _want_ to cause a link error for overlapping
			% instance decls, even if they are in a different
			% module
			%
			{ Name = data(base_typeclass_info(_, _)) }
		;
			% We don't module qualify pragma export names.
			{ Name = export(_) }
		)
	->
		mlds_output_name(Name)
	;
		mlds_output_fully_qualified(QualifiedName, mlds_output_name)
	).

:- pred mlds_output_fully_qualified_proc_label(mlds__qualified_proc_label,
		io__state, io__state).
:- mode mlds_output_fully_qualified_proc_label(in, di, uo) is det.

mlds_output_fully_qualified_proc_label(QualifiedName) -->
	(
		%
		% don't module-qualify main/2
		%
		{ QualifiedName = qual(_ModuleName, Name) },
		{ Name = PredLabel - _ProcId },
		{ PredLabel = pred(predicate, no, "main", 2) }
	->
		mlds_output_proc_label(Name)
	;
		mlds_output_fully_qualified(QualifiedName,
			mlds_output_proc_label)
	).

:- pred mlds_output_fully_qualified(mlds__fully_qualified_name(T),
		pred(T, io__state, io__state), io__state, io__state).
:- mode mlds_output_fully_qualified(in, pred(in, di, uo) is det,
		di, uo) is det.

mlds_output_fully_qualified(qual(ModuleName, Name), OutputFunc) -->
	{ SymName = mlds_module_name_to_sym_name(ModuleName) },
	{ llds_out__sym_name_mangle(SymName, MangledModuleName) },
	io__write_string(MangledModuleName),
	io__write_string("__"),
	OutputFunc(Name).

:- pred mlds_output_module_name(mercury_module_name, io__state, io__state).
:- mode mlds_output_module_name(in, di, uo) is det.

mlds_output_module_name(ModuleName) -->
	{ llds_out__sym_name_mangle(ModuleName, MangledModuleName) },
	io__write_string(MangledModuleName).

:- pred mlds_output_name(mlds__entity_name, io__state, io__state).
:- mode mlds_output_name(in, di, uo) is det.

% XXX we should avoid appending the arity, modenum, and seqnum
%     if they are not needed.

mlds_output_name(type(Name, Arity)) -->
	{ llds_out__name_mangle(Name, MangledName) },
	io__format("%s_%d", [s(MangledName), i(Arity)]).
mlds_output_name(data(DataName)) -->
	mlds_output_data_name(DataName).
mlds_output_name(function(PredLabel, ProcId, MaybeSeqNum, _PredId)) -->
	mlds_output_pred_label(PredLabel),
	{ proc_id_to_int(ProcId, ModeNum) },
	io__format("_%d", [i(ModeNum)]),
	( { MaybeSeqNum = yes(SeqNum) } ->
		io__format("_%d", [i(SeqNum)])
	;
		[]
	).
mlds_output_name(export(Name)) -->
	io__write_string(Name).

:- func build_name(mlds__entity_name) = string.

build_name(type(Name, Arity)) = TypeName :-
	llds_out__name_mangle(Name, MangledName),
	TypeName = string__format("%s_%d", [s(MangledName), i(Arity)]).
build_name(data(DataName)) = build_data_name(DataName).
build_name(EntityName) = AsmFuncName :-
	EntityName = function(_, _, _, _),
	get_func_name(EntityName, _FuncName, AsmFuncName).
build_name(export(Name)) = Name.

:- pred mlds_output_pred_label(mlds__pred_label, io__state, io__state).
:- mode mlds_output_pred_label(in, di, uo) is det.

mlds_output_pred_label(pred(PredOrFunc, MaybeDefiningModule, Name, Arity)) -->
	( { PredOrFunc = predicate, Suffix = "p" }
	; { PredOrFunc = function, Suffix = "f" }
	),
	{ llds_out__name_mangle(Name, MangledName) },
	io__format("%s_%d_%s", [s(MangledName), i(Arity), s(Suffix)]),
	( { MaybeDefiningModule = yes(DefiningModule) } ->
		io__write_string("_in__"),
		mlds_output_module_name(DefiningModule)
	;
		[]
	).
mlds_output_pred_label(special_pred(PredName, MaybeTypeModule,
		TypeName, TypeArity)) -->
	{ llds_out__name_mangle(PredName, MangledPredName) },
	{ llds_out__name_mangle(TypeName, MangledTypeName) },
	io__write_string(MangledPredName),
	io__write_string("__"),
	( { MaybeTypeModule = yes(TypeModule) } ->
		mlds_output_module_name(TypeModule),
		io__write_string("__")
	;
		[]
	),
	io__write_string(MangledTypeName),
	io__write_string("_"),
	io__write_int(TypeArity).

:- func build_data_name(mlds__data_name) = string.

build_data_name(var(Name)) = MangledName :-
	llds_out__name_mangle(Name, MangledName).
build_data_name(common(Num)) =
	string__format("common_%d", [i(Num)]).
build_data_name(rtti(RttiTypeId, RttiName)) = RttiAddrName :-
	rtti__addr_to_string(RttiTypeId, RttiName, RttiAddrName).
build_data_name(base_typeclass_info(ClassId, InstanceStr)) = Name :-
	llds_out__make_base_typeclass_info_name(ClassId, InstanceStr,
		Name).
build_data_name(module_layout) = _ :-
	sorry(this_file, "module_layout").
build_data_name(proc_layout(_ProcLabel)) = _ :-
	sorry(this_file, "proc_layout").
build_data_name(internal_layout(_ProcLabel, _FuncSeqNum)) = _ :-
	sorry(this_file, "internal_layout").
build_data_name(tabling_pointer(ProcLabel)) = TablingPointerName :-
	% convert the proc_label into an entity_name, 
	% so we can use get_func_name below
	ProcLabel = PredLabel - ProcId,
	MaybeSeqNum = no,
	invalid_pred_id(InvalidPredId),
	Name = function(PredLabel, ProcId, MaybeSeqNum, InvalidPredId),
	get_func_name(Name, _FuncName, AsmFuncName),
	TablingPointerName = string__append("table_for_", AsmFuncName).

:- pred mlds_output_data_name(mlds__data_name, io__state, io__state).
:- mode mlds_output_data_name(in, di, uo) is det.

mlds_output_data_name(var(Name)) -->
	mlds_output_mangled_name(Name).
mlds_output_data_name(common(Num)) -->
	io__write_string("common_"),
	io__write_int(Num).
mlds_output_data_name(rtti(RttiTypeId, RttiName)) -->
	{ rtti__addr_to_string(RttiTypeId, RttiName, RttiAddrName) },
	io__write_string(RttiAddrName).
mlds_output_data_name(base_typeclass_info(ClassId, InstanceStr)) -->
	{ llds_out__make_base_typeclass_info_name(ClassId, InstanceStr,
		Name) },
	io__write_string(Name).
mlds_output_data_name(module_layout) -->
	{ error("mlds_to_c.m: NYI: module_layout") }.
mlds_output_data_name(proc_layout(_ProcLabel)) -->
	{ error("mlds_to_c.m: NYI: proc_layout") }.
mlds_output_data_name(internal_layout(_ProcLabel, _FuncSeqNum)) -->
	{ error("mlds_to_c.m: NYI: internal_layout") }.
mlds_output_data_name(tabling_pointer(ProcLabel)) -->
	io__write_string("table_for_"),
	mlds_output_proc_label(ProcLabel).

%-----------------------------------------------------------------------------%
%
% Code to output types
%

%
% Because of the joys of C syntax, the code for outputting
% types needs to be split into two parts; first the prefix,
% i.e. the part of the type name that goes before the variable
% name in a variable declaration, and then the suffix, i.e.
% the part which goes after the variable name, e.g. the "[]"
% for array types.
%

:- pred mlds_output_type(mlds__type, io__state, io__state).
:- mode mlds_output_type(in, di, uo) is det.

mlds_output_type(Type) -->
	mlds_output_type_prefix(Type),
	mlds_output_type_suffix(Type).

:- pred mlds_output_type_prefix(mlds__type, io__state, io__state).
:- mode mlds_output_type_prefix(in, di, uo) is det.

mlds_output_type_prefix(mercury_type(Type, TypeCategory)) -->
	mlds_output_mercury_type_prefix(Type, TypeCategory).
mlds_output_type_prefix(mlds__native_int_type)   --> io__write_string("int").
mlds_output_type_prefix(mlds__native_float_type) --> io__write_string("float").
mlds_output_type_prefix(mlds__native_bool_type)  --> io__write_string("bool").
mlds_output_type_prefix(mlds__native_char_type)  --> io__write_string("char").
mlds_output_type_prefix(mlds__class_type(Name, Arity, ClassKind)) -->
	( { ClassKind = mlds__enum } ->
		%
		% We can't just use the enumeration type,
		% since the enumeration type's definition
		% is not guaranteed to be in scope at this point.
		% (Fixing that would be somewhat complicated; it would
		% require writing enum definitions to a separate header file.)
		% Also the enumeration might not be word-sized,
		% which would cause problems for e.g. `std_util:arg/2'.
		% So we just use `MR_Integer', and output the
		% actual enumeration type as a comment.
		%
		io__write_string("MR_Integer /* actually `enum "),
		mlds_output_fully_qualified(Name, mlds_output_mangled_name),
		io__format("_%d_e", [i(Arity)]),
		io__write_string("' */")
	;
		% For struct types it's OK to output an incomplete type,
		% since don't use these types directly, we only
		% use pointers to them.
		io__write_string("struct "),
		mlds_output_fully_qualified(Name, mlds_output_mangled_name),
		io__format("_%d_s", [i(Arity)])
	).
mlds_output_type_prefix(mlds__ptr_type(Type)) -->
	mlds_output_type(Type),
	io__write_string(" *").
mlds_output_type_prefix(mlds__array_type(Type)) -->
	% Here we just output the element type.
	% The "[]" goes in the type suffix.
	mlds_output_type(Type).
mlds_output_type_prefix(mlds__func_type(FuncParams)) -->
	mlds_output_func_type_prefix(FuncParams).
mlds_output_type_prefix(mlds__generic_type) -->
	io__write_string("MR_Box").
mlds_output_type_prefix(mlds__generic_env_ptr_type) -->
	io__write_string("void *").
mlds_output_type_prefix(mlds__pseudo_type_info_type) -->
	io__write_string("MR_PseudoTypeInfo").
mlds_output_type_prefix(mlds__cont_type(ArgTypes)) -->
	( { ArgTypes = [] } ->
		globals__io_lookup_bool_option(gcc_nested_functions,
			GCC_NestedFuncs),
		( { GCC_NestedFuncs = yes } ->
			io__write_string("MR_NestedCont")
		;
			io__write_string("MR_Cont")
		)
	;
		% This case only happens for --nondet-copy-out
		io__write_string("void MR_CALL (*")
	).
mlds_output_type_prefix(mlds__commit_type) -->
	globals__io_lookup_bool_option(gcc_local_labels, GCC_LocalLabels),
	( { GCC_LocalLabels = yes } ->
		io__write_string("__label__")
	;
		io__write_string("jmp_buf")
	).
mlds_output_type_prefix(mlds__rtti_type(RttiName)) -->
	io__write_string("MR_"),
	io__write_string(mlds_rtti_type_name(RttiName)).

:- pred build_mercury_type(mercury_type, builtin_type, gcc__type,
		io__state, io__state).
:- mode build_mercury_type(in, in, out, di, uo) is det.

build_mercury_type(_Type, TypeCategory, GCC_Type) -->
	(
		{ TypeCategory = char_type },
		{ GCC_Type = 'MR_Char' }
	;
		{ TypeCategory = int_type },
		{ GCC_Type = 'MR_Integer' }
	;
		{ TypeCategory = str_type },
		{ GCC_Type = 'MR_String' }
	;
		{ TypeCategory = float_type },
		{ GCC_Type = 'MR_Float' }
	;
		{ TypeCategory = polymorphic_type },
		{ GCC_Type = 'MR_Box' }
	;
		{ TypeCategory = tuple_type },
		% tuples are always (pointers to)
		% arrays of polymorphic terms
		gcc__build_pointer_type('MR_Box', MR_Tuple),
		{ GCC_Type = MR_Tuple }
	;
		{ TypeCategory = pred_type },
		globals__io_lookup_bool_option(highlevel_data, HighLevelData),
		( { HighLevelData = yes } ->
			{ sorry(this_file, "--high-level-data (pred_type)") }
			% { GCC_Type = 'MR_ClosurePtr' }
		;
			{ GCC_Type = 'MR_Word' }
		)
	;
		{ TypeCategory = enum_type },
		% Note that the MLDS -> C back-end uses 'MR_Word' here,
		% unless --high-level-data is enabled.  But 'MR_Integer'
		% seems better, I think.  It probably doesn't make any real
		% difference either way.
		% XXX for --high-level-data, we should use a real enum type
		{ GCC_Type = 'MR_Integer' }
	;
		{ TypeCategory = user_type },
		globals__io_lookup_bool_option(highlevel_data, HighLevelData),
		( { HighLevelData = yes } ->
			{ sorry(this_file, "--high-level-data (user_type)") }
		;
			{ GCC_Type = 'MR_Word' }
		)
	).

:- pred mlds_output_mercury_type_prefix(mercury_type, builtin_type,
		io__state, io__state).
:- mode mlds_output_mercury_type_prefix(in, in, di, uo) is det.

mlds_output_mercury_type_prefix(Type, TypeCategory) -->
	(
		{ TypeCategory = char_type },
		io__write_string("MR_Char")
	;
		{ TypeCategory = int_type },
		io__write_string("MR_Integer")
	;
		{ TypeCategory = str_type },
		io__write_string("MR_String")
	;
		{ TypeCategory = float_type },
		io__write_string("MR_Float")
	;
		{ TypeCategory = polymorphic_type },
		io__write_string("MR_Box")
	;
		{ TypeCategory = tuple_type },
		io__write_string("MR_Tuple")
	;
		{ TypeCategory = pred_type },
		globals__io_lookup_bool_option(highlevel_data, HighLevelData),
		( { HighLevelData = yes } ->
			io__write_string("MR_ClosurePtr")
		;
			io__write_string("MR_Word")
		)
	;
		{ TypeCategory = enum_type },
		mlds_output_mercury_user_type_prefix(Type, TypeCategory)
	;
		{ TypeCategory = user_type },
		mlds_output_mercury_user_type_prefix(Type, TypeCategory)
	).

:- pred mlds_output_mercury_user_type_prefix(mercury_type, builtin_type,
		io__state, io__state).
:- mode mlds_output_mercury_user_type_prefix(in, in, di, uo) is det.

mlds_output_mercury_user_type_prefix(Type, TypeCategory) -->
	globals__io_lookup_bool_option(highlevel_data, HighLevelData),
	( { HighLevelData = yes } ->
		( { type_to_type_id(Type, TypeId, _ArgsTypes) } ->
			{ ml_gen_type_name(TypeId, ClassName, ClassArity) },
			{ TypeCategory = enum_type ->
				MLDS_Type = mlds__class_type(ClassName,
					ClassArity, mlds__enum)
			;
				MLDS_Type = mlds__ptr_type(mlds__class_type(
					ClassName, ClassArity, mlds__class))
			},
			mlds_output_type_prefix(MLDS_Type)
		;
			{ error("mlds_output_mercury_user_type_prefix") }
		)
	;
		% for the --no-high-level-data case,
		% we just treat everything as `MR_Word'
		io__write_string("MR_Word")
	).

:- pred mlds_output_type_suffix(mlds__type, io__state, io__state).
:- mode mlds_output_type_suffix(in, di, uo) is det.

mlds_output_type_suffix(Type) -->
	mlds_output_type_suffix(Type, no_size).

:- type initializer_array_size
	--->	array_size(int)
	;	no_size.	% either the size is unknown,
				% or the data is not an array

:- func initializer_array_size(mlds__initializer) = initializer_array_size.
initializer_array_size(no_initializer) = no_size.
initializer_array_size(init_obj(_)) = no_size.
initializer_array_size(init_struct(_)) = no_size.
initializer_array_size(init_array(Elems)) = array_size(list__length(Elems)).

:- pred mlds_output_type_suffix(mlds__type, initializer_array_size,
		io__state, io__state).
:- mode mlds_output_type_suffix(in, in, di, uo) is det.


mlds_output_type_suffix(mercury_type(_, _), _) --> [].
mlds_output_type_suffix(mlds__native_int_type, _) --> [].
mlds_output_type_suffix(mlds__native_float_type, _) --> [].
mlds_output_type_suffix(mlds__native_bool_type, _) --> [].
mlds_output_type_suffix(mlds__native_char_type, _) --> [].
mlds_output_type_suffix(mlds__class_type(_, _, _), _) --> [].
mlds_output_type_suffix(mlds__ptr_type(_), _) --> [].
mlds_output_type_suffix(mlds__array_type(_), ArraySize) -->
	mlds_output_array_type_suffix(ArraySize).
mlds_output_type_suffix(mlds__func_type(FuncParams), _) -->
	mlds_output_func_type_suffix(FuncParams).
mlds_output_type_suffix(mlds__generic_type, _) --> [].
mlds_output_type_suffix(mlds__generic_env_ptr_type, _) --> [].
mlds_output_type_suffix(mlds__pseudo_type_info_type, _) --> [].
mlds_output_type_suffix(mlds__cont_type(ArgTypes), _) -->
	( { ArgTypes = [] } ->
		[]
	;
		% This case only happens for --nondet-copy-out
		io__write_string(")("),
		io__write_list(ArgTypes, ", ", mlds_output_type),
		% add the type for the environment parameter, if needed
		globals__io_lookup_bool_option(gcc_nested_functions,
			GCC_NestedFuncs),
		( { GCC_NestedFuncs = no } ->
			io__write_string(", void *")
		;
			[]
		),
		io__write_string(")")
	).
mlds_output_type_suffix(mlds__commit_type, _) --> [].
mlds_output_type_suffix(mlds__rtti_type(RttiName), ArraySize) -->
	( { rtti_name_has_array_type(RttiName) = yes } ->
		mlds_output_array_type_suffix(ArraySize)
	;
		[]
	).

:- pred mlds_output_array_type_suffix(initializer_array_size::in,
		io__state::di, io__state::uo) is det.
mlds_output_array_type_suffix(no_size) -->
	io__write_string("[]").
mlds_output_array_type_suffix(array_size(Size0)) -->
	%
	% ANSI/ISO C forbids arrays of size 0.
	%
	{ int__max(Size0, 1, Size) },
	io__format("[%d]", [i(Size)]).

%-----------------------------------------------------------------------------%
%
% Code to output declaration specifiers
%

:- type decl_or_defn
	--->	forward_decl
	;	definition.

:- pred mlds_output_decl_flags(mlds__decl_flags, decl_or_defn,
		mlds__entity_name, mlds__entity_defn, io__state, io__state).
:- mode mlds_output_decl_flags(in, in, in, in, di, uo) is det.

mlds_output_decl_flags(Flags, DeclOrDefn, Name, DefnBody) -->
	%
	% mlds_output_extern_or_static handles both the
	% `access' and the `per_instance' fields of the mlds__decl_flags.
	% We have to handle them together because C overloads `static'
	% to mean both `private' and `one_copy', rather than having
	% separate keywords for each.  To make it clear which MLDS
	% construct each `static' keyword means, we precede the `static'
	% without (optionally-enabled) comments saying whether it is
	% `private', `one_copy', or both.
	%
	mlds_output_access_comment(access(Flags)),
	mlds_output_per_instance_comment(per_instance(Flags)),
	mlds_output_extern_or_static(access(Flags), per_instance(Flags),
		DeclOrDefn, Name, DefnBody),
	mlds_output_virtuality(virtuality(Flags)),
	mlds_output_finality(finality(Flags)),
	mlds_output_constness(constness(Flags)),
	mlds_output_abstractness(abstractness(Flags)).

:- pred mlds_output_access_comment(access, io__state, io__state).
:- mode mlds_output_access_comment(in, di, uo) is det.

mlds_output_access_comment(Access) -->
	globals__io_lookup_bool_option(auto_comments, Comments),
	( { Comments = yes } ->
		mlds_output_access_comment_2(Access)
	;
		[]
	).

:- pred mlds_output_access_comment_2(access, io__state, io__state).
:- mode mlds_output_access_comment_2(in, di, uo) is det.

mlds_output_access_comment_2(public)    --> [].
mlds_output_access_comment_2(private)   --> io__write_string("/* private: */ ").
mlds_output_access_comment_2(protected) --> io__write_string("/* protected: */ ").
mlds_output_access_comment_2(default)   --> io__write_string("/* default access */ ").

:- pred mlds_output_per_instance_comment(per_instance, io__state, io__state).
:- mode mlds_output_per_instance_comment(in, di, uo) is det.

mlds_output_per_instance_comment(PerInstance) -->
	globals__io_lookup_bool_option(auto_comments, Comments),
	( { Comments = yes } ->
		mlds_output_per_instance_comment_2(PerInstance)
	;
		[]
	).

:- pred mlds_output_per_instance_comment_2(per_instance, io__state, io__state).
:- mode mlds_output_per_instance_comment_2(in, di, uo) is det.

mlds_output_per_instance_comment_2(per_instance) --> [].
mlds_output_per_instance_comment_2(one_copy)     --> io__write_string("/* one_copy */ ").

:- pred mlds_output_extern_or_static(access, per_instance, decl_or_defn,
		mlds__entity_name, mlds__entity_defn, io__state, io__state).
:- mode mlds_output_extern_or_static(in, in, in, in, in, di, uo) is det.

mlds_output_extern_or_static(Access, PerInstance, DeclOrDefn, Name, DefnBody)
		-->
	( 
		{ Access = private ; PerInstance = one_copy },
		{ Name \= type(_, _) },
		% Don't output "static" for functions that don't have a body.
		% This can happen for Mercury procedures declared `:- external'
		{ DefnBody \= mlds__function(_, _, no) }
	->
		io__write_string("static ")
	;
		{ DeclOrDefn = forward_decl },
		{ Name = data(_) }
	->
		io__write_string("extern ")
	;
		[]
	).

:- pred mlds_output_virtuality(virtuality, io__state, io__state).
:- mode mlds_output_virtuality(in, di, uo) is det.

mlds_output_virtuality(virtual)     --> io__write_string("virtual ").
mlds_output_virtuality(non_virtual) --> [].

:- pred mlds_output_finality(finality, io__state, io__state).
:- mode mlds_output_finality(in, di, uo) is det.

mlds_output_finality(final)       --> io__write_string("/* final */ ").
mlds_output_finality(overridable) --> [].

:- pred mlds_output_constness(constness, io__state, io__state).
:- mode mlds_output_constness(in, di, uo) is det.

mlds_output_constness(const)      --> io__write_string("const ").
mlds_output_constness(modifiable) --> [].

:- pred mlds_output_abstractness(abstractness, io__state, io__state).
:- mode mlds_output_abstractness(in, di, uo) is det.

mlds_output_abstractness(abstract) --> io__write_string("/* abstract */ ").
mlds_output_abstractness(concrete) --> [].

%-----------------------------------------------------------------------------%
%
% Code to output statements
%

:- type func_info
	--->	func_info(
			func_name :: mlds__qualified_entity_name,
			func_params :: mlds__func_params,
			symbol_table :: symbol_table,
			label_table :: label_table
		).

% The symbol table records the mapping from MLDS variable names
% to GCC variable declarations.
% We initialize the symbol table with the function parameters,
% and update it whenever we enter a block with local variables.
:- type symbol_table == map(mlds__qualified_entity_name, gcc__var_decl).

% The label table records the mapping from MLDS label names
% to GCC label declaration tree nodes.
% We initialize it using a separate pass over the function body
% before we generate code for the function.
:- type label_table == map(mlds__label, gcc__label).

:- pred gen_statements(func_info, list(mlds__statement),
		io__state, io__state).
:- mode gen_statements(in, in, di, uo) is det.

gen_statements(FuncInfo, Statements) -->
	list__foldl(gen_statement(FuncInfo), Statements).

:- pred mlds_output_statements(indent, func_info, list(mlds__statement),
		io__state, io__state).
:- mode mlds_output_statements(in, in, in, di, uo) is det.

mlds_output_statements(Indent, FuncInfo, Statements) -->
	list__foldl(mlds_output_statement(Indent, FuncInfo), Statements).

:- pred gen_statement(func_info, mlds__statement,
		io__state, io__state).
:- mode gen_statement(in, in, di, uo) is det.

gen_statement(FuncInfo, mlds__statement(Statement, Context)) -->
	gen_context(Context),
	gen_stmt(FuncInfo, Statement, Context).

:- pred gen_stmt(func_info, mlds__stmt, mlds__context,
		io__state, io__state).
:- mode gen_stmt(in, in, in, di, uo) is det.

:- pred mlds_output_statement(indent, func_info, mlds__statement,
		io__state, io__state).
:- mode mlds_output_statement(in, in, in, di, uo) is det.

mlds_output_statement(Indent, FuncInfo, mlds__statement(Statement, Context)) -->
	mlds_output_context(Context),
	mlds_output_stmt(Indent, FuncInfo, Statement, Context).

:- pred mlds_output_stmt(indent, func_info, mlds__stmt, mlds__context,
		io__state, io__state).
:- mode mlds_output_stmt(in, in, in, in, di, uo) is det.

	%
	% sequence
	%
mlds_output_stmt(Indent, FuncInfo, block(Defns, Statements), Context) -->
	mlds_indent(Indent),
	io__write_string("{\n"),
	( { Defns \= [] } ->
		% { FuncName = FuncInfo ^ func_name },
		% { FuncName = qual(ModuleName, _) },
		% gen_defns(Indent + 1, ModuleName, Defns),
		io__write_string("\n")
	;
		[]
	),
	mlds_output_statements(Indent + 1, FuncInfo, Statements),
	mlds_indent(Context, Indent),
	io__write_string("}\n").

	%
	% sequence
	%
gen_stmt(FuncInfo0, block(Defns, Statements), _Context) -->
	{ FuncName = FuncInfo0 ^ func_name },
	{ FuncName = qual(ModuleName, _) },
	{ SymbolTable0 = FuncInfo0 ^ symbol_table },
	build_local_defns(Defns, FuncInfo0, ModuleName, SymbolTable0, SymbolTable),
	{ FuncInfo = FuncInfo0 ^ symbol_table := SymbolTable },
	gen_statements(FuncInfo, Statements).

	%
	% iteration
	%
gen_stmt(FuncInfo, while(Cond, Statement, AtLeastOneIteration), _Context) -->
	gcc__gen_start_loop(Loop),
	build_rval(Cond, FuncInfo, GCC_Cond),
	(
		{ AtLeastOneIteration = yes },
		% generate the test at the end of the loop
		gen_statement(FuncInfo, Statement),
		gcc__gen_exit_loop_if_false(Loop, GCC_Cond)
	;
		{ AtLeastOneIteration = no },
		% generate the test at the start of the loop
		gcc__gen_exit_loop_if_false(Loop, GCC_Cond),
		gen_statement(FuncInfo, Statement)
	),
	gcc__gen_end_loop.

mlds_output_stmt(Indent, FuncInfo, while(Cond, Statement, no), _) -->
	mlds_indent(Indent),
	io__write_string("while ("),
	mlds_output_rval(Cond),
	io__write_string(")\n"),
	mlds_output_statement(Indent + 1, FuncInfo, Statement).
mlds_output_stmt(Indent, FuncInfo, while(Cond, Statement, yes), Context) -->
	mlds_indent(Indent),
	io__write_string("do\n"),
	mlds_output_statement(Indent + 1, FuncInfo, Statement),
	mlds_indent(Context, Indent),
	io__write_string("while ("),
	mlds_output_rval(Cond),
	io__write_string(");\n").

	%
	% selection (see also computed_goto)
	%
gen_stmt(FuncInfo, if_then_else(Cond, Then, MaybeElse), _Context) -->
	build_rval(Cond, FuncInfo, GCC_Cond),
	gcc__gen_start_cond(GCC_Cond),
	gen_statement(FuncInfo, Then),
	(
		{ MaybeElse = no }
	;
		{ MaybeElse = yes(Else) },
		gcc__gen_start_else,
		gen_statement(FuncInfo, Else)
	),
	gcc__gen_end_cond.

mlds_output_stmt(Indent, FuncInfo, if_then_else(Cond, Then0, MaybeElse),
		Context) -->
	%
	% we need to take care to avoid problems caused by the
	% dangling else ambiguity
	%
	{
		%
		% For examples of the form
		%
		%	if (...)
		%		if (...)
		%			...
		%	else
		%		...
		%
		% we need braces around the inner `if', otherwise
		% they wouldn't parse they way we want them to:
		% C would match the `else' with the inner `if'
		% rather than the outer `if'.
		%
		MaybeElse = yes(_),
		Then0 = statement(if_then_else(_, _, no), ThenContext)
	->
		Then = statement(block([], [Then0]), ThenContext)
	;
		%
		% For examples of the form
		%
		%	if (...)
		%		if (...)
		%			...
		%		else
		%			...
		%
		% we don't _need_ braces around the inner `if',
		% since C will match the else with the inner `if',
		% but we add braces anyway, to avoid a warning from gcc.
		%
		MaybeElse = no,
		Then0 = statement(if_then_else(_, _, yes(_)), ThenContext)
	->
		Then = statement(block([], [Then0]), ThenContext)
	;
		Then = Then0
	},

	mlds_indent(Indent),
	io__write_string("if ("),
	mlds_output_rval(Cond),
	io__write_string(")\n"),
	mlds_output_statement(Indent + 1, FuncInfo, Then),
	( { MaybeElse = yes(Else) } ->
		mlds_indent(Context, Indent),
		io__write_string("else\n"),
		mlds_output_statement(Indent + 1, FuncInfo, Else)
	;
		[]
	).
gen_stmt(FuncInfo, switch(Type, Val, _Range, Cases, Default), _) -->
	build_type(Type, GCC_Type),
	build_rval(Val, FuncInfo, GCC_Expr),
	gcc__gen_start_switch(GCC_Expr, GCC_Type),
	gen_cases(FuncInfo, Cases),
	gen_default(FuncInfo, Default),
	gcc__gen_end_switch(GCC_Expr).

:- pred gen_cases(func_info::in, mlds__switch_cases::in,
		io__state::di, io__state::uo) is det.
gen_cases(FuncInfo, Cases) -->
	list__foldl(gen_case(FuncInfo), Cases).

:- pred gen_case(func_info::in, mlds__switch_case::in,
		io__state::di, io__state::uo) is det.
gen_case(FuncInfo, MatchConds - Code) -->
	list__foldl(gen_case_label(FuncInfo), MatchConds),
	gen_statement(FuncInfo, Code),
	gcc__gen_break.

:- pred gen_case_label(func_info::in, mlds__case_match_cond::in,
		io__state::di, io__state::uo) is det.
gen_case_label(FuncInfo, match_value(Val)) -->
	build_rval(Val, FuncInfo, GCC_Val),
	gcc__build_unnamed_label(Label),
	gcc__gen_case_label(GCC_Val, Label).
gen_case_label(FuncInfo, match_range(Min, Max)) -->
	build_rval(Min, FuncInfo, _GCC_Min),
	build_rval(Max, FuncInfo, _GCC_Max),
	gcc__build_unnamed_label(_Label),
	% the following is not yet implemented
	% (would be easy to do, but not needed so far):
	%%% gcc__gen_case_range_label(GCC_Min, GCC_Max, Label).
	{ sorry(this_file, "match_range") }.

:- pred gen_default(func_info::in, mlds__switch_default::in,
		io__state::di, io__state::uo) is det.
gen_default(_, default_do_nothing) --> [].
gen_default(_, default_is_unreachable) --> [].
gen_default(FuncInfo, default_case(Statement)) -->
	gcc__build_unnamed_label(Label),
	gcc__gen_default_case_label(Label),
	gen_statement(FuncInfo, Statement).

mlds_output_stmt(Indent, FuncInfo, switch(_Type, Val, _Range, Cases, Default),
		Context) -->
	mlds_indent(Context, Indent),
	io__write_string("switch ("),
	mlds_output_rval(Val),
	io__write_string(") {\n"),
	list__foldl(mlds_output_switch_case(Indent + 1, FuncInfo, Context),
		Cases),
	mlds_output_switch_default(Indent + 1, FuncInfo, Context, Default),
	mlds_indent(Context, Indent),
	io__write_string("}\n").

	%
	% transfer of control
	%
gen_stmt(FuncInfo, label(LabelName), _) -->
	{ LabelTable = FuncInfo ^ label_table },
	{ GCC_Label = map__lookup(LabelTable, LabelName) },
	gcc__gen_label(GCC_Label).
	
mlds_output_stmt(Indent, _FuncInfo, label(LabelName), _) -->
	%
	% Note: MLDS allows labels at the end of blocks.
	% C doesn't.  Hence we need to insert a semi-colon after the colon
	% to ensure that there is a statement to attach the label to.
	%
	mlds_indent(Indent - 1),
	mlds_output_label_name(LabelName),
	io__write_string(":;\n").

gen_stmt(FuncInfo, goto(LabelName), _) -->
	{ LabelTable = FuncInfo ^ label_table },
	{ GCC_Label = map__lookup(LabelTable, LabelName) },
	gcc__gen_goto(GCC_Label).

mlds_output_stmt(Indent, _FuncInfo, goto(LabelName), _) -->
	mlds_indent(Indent),
	io__write_string("goto "),
	mlds_output_label_name(LabelName),
	io__write_string(";\n").
gen_stmt(_FuncInfo, computed_goto(_Expr, _Labels), _) -->
	{ sorry(this_file, "computed goto") }.
mlds_output_stmt(Indent, _FuncInfo, computed_goto(Expr, Labels), Context) -->
	% XXX for GNU C, we could output potentially more efficient code
	% by using an array of labels; this would tell the compiler that
	% it didn't need to do any range check.
	mlds_indent(Indent),
	io__write_string("switch ("),
	mlds_output_rval(Expr),
	io__write_string(") {\n"),
	{ OutputLabel =
	    (pred(Label::in, Count0::in, Count::out, di, uo) is det -->
		mlds_indent(Context, Indent + 1),
		io__write_string("case "),
		io__write_int(Count0),
		io__write_string(": goto "),
		mlds_output_label_name(Label),
		io__write_string(";\n"),
		{ Count = Count0 + 1 }
	) },
	list__foldl2(OutputLabel, Labels, 0, _FinalCount),
	mlds_indent(Context, Indent + 1),
	io__write_string("default: /*NOTREACHED*/ assert(0);\n"),
	mlds_indent(Context, Indent),
	io__write_string("}\n").

	%
	% function call/return
	%
gen_stmt(FuncInfo, Call, _) -->
	{ Call = call(_Signature, FuncRval, MaybeObject, CallArgs,
		Results, IsTailCall) },
	{ require(unify(MaybeObject, no), this_file ++ ": method call") },
	build_args(CallArgs, FuncInfo, GCC_ArgList),
	build_rval(FuncRval, FuncInfo, GCC_FuncRval),
	{ IsTailCallBool = (IsTailCall = tail_call -> yes ; no) },
	gcc__build_call_expr(GCC_FuncRval, GCC_ArgList, IsTailCallBool,
		GCC_Call),
	( { Results = [ResultLval] } ->
		build_lval(ResultLval, FuncInfo, GCC_ResultExpr),
		gcc__gen_assign(GCC_ResultExpr, GCC_Call)
	; { Results = [] } ->
		gcc__gen_expr_stmt(GCC_Call)
	;
		{ sorry(this_file, "call with multiple outputs") }
	).

mlds_output_stmt(Indent, CallerFuncInfo, Call, Context) -->
	{ Call = call(_Signature, FuncRval, MaybeObject, CallArgs,
		Results, IsTailCall) },
	{ Name = CallerFuncInfo ^ func_name },
	%
	% Optimize general tail calls.
	% We can't really do much here except to insert `return'
	% as an extra hint to the C compiler.
	% XXX these optimizations should be disable-able
	%
	% If Results = [], i.e. the function has `void' return type,
	% then this would result in code that is not legal ANSI C
	% (although it _is_ legal in GNU C and in C++),
	% so for that case, we put the return statement after
	% the call -- see below.  We need to enclose it inside
	% an extra pair of curly braces in case this `call'
	% is e.g. inside an if-then-else.
	%
	mlds_indent(Indent),
	io__write_string("{\n"),

	mlds_maybe_output_call_profile_instr(Context,
			Indent + 1, FuncRval, Name),

	mlds_indent(Context, Indent + 1),

	( { IsTailCall = tail_call, Results \= [] } ->
		io__write_string("return ")
	;
		[]
	),
	( { MaybeObject = yes(Object) } ->
		mlds_output_bracketed_rval(Object),
		io__write_string(".") % XXX should this be "->"?
	;
		[]
	),
	( { Results = [] } ->
		[]
	; { Results = [Lval] } ->
		mlds_output_lval(Lval),
		io__write_string(" = ")
	;
		{ error("mld_output_stmt: multiple return values") }
	),
	mlds_output_bracketed_rval(FuncRval),
	io__write_string("("),
	io__write_list(CallArgs, ", ", mlds_output_rval),
	io__write_string(");\n"),

	( { IsTailCall = tail_call, Results = [] } ->
		mlds_indent(Context, Indent + 1),
		io__write_string("return;\n")
	;
		mlds_maybe_output_time_profile_instr(Context,
				Indent + 1, Name)
	),
	mlds_indent(Indent),
	io__write_string("}\n").

gen_stmt(FuncInfo, return(Results), _) -->
	( { Results = [] } ->
		% XXX NYI
		{ error("gen_stmt: no return value") }
	; { Results = [Rval] } ->
		build_rval(Rval, FuncInfo, Expr),
		gcc__gen_return(Expr)
	;
		{ error("gen_stmt: multiple return values") }
	).

mlds_output_stmt(Indent, _FuncInfo, return(Results), _) -->
	mlds_indent(Indent),
	io__write_string("return"),
	( { Results = [] } ->
		[]
	; { Results = [Rval] } ->
		io__write_char(' '),
		mlds_output_rval(Rval)
	;
		{ error("mlds_output_stmt: multiple return values") }
	),
	io__write_string(";\n").
	
	%
	% commits
	%
gen_stmt(_FuncInfo, do_commit(_Ref), _) -->
	{ sorry(this_file, "do_commit") }.
mlds_output_stmt(Indent, _FuncInfo, do_commit(Ref), _) -->
	mlds_indent(Indent),
	globals__io_lookup_bool_option(gcc_local_labels, GCC_LocalLabels),
	( { GCC_LocalLabels = yes } ->
		% output "goto <Ref>"
		io__write_string("goto "),
		mlds_output_rval(Ref)
	;
		% output "longjmp(<Ref>, 1)"
		io__write_string("longjmp("),
		mlds_output_rval(Ref),
		io__write_string(", 1)")
	),
	io__write_string(";\n").
gen_stmt(_FuncInfo, try_commit(_Ref, _Stmt0, _Handler), _) -->
	{ sorry(this_file, "try_commit") }.
mlds_output_stmt(Indent, FuncInfo, try_commit(Ref, Stmt0, Handler), Context) -->
	globals__io_lookup_bool_option(gcc_local_labels, GCC_LocalLabels),
	(
		{ GCC_LocalLabels = yes },
	
		% Output the following:
		%
		%               <Stmt>
		%               goto <Ref>_done;
		%       <Ref>:
		%               <Handler>
		%       <Ref>_done:
		%               ;

		% Note that <Ref> should be just variable name,
		% not a complicated expression.  If not, the
		% C compiler will catch it.

		mlds_output_statement(Indent, FuncInfo, Stmt0),

		mlds_indent(Context, Indent),
		io__write_string("goto "),
		mlds_output_lval(Ref),
		io__write_string("_done;\n"),

		mlds_indent(Context, Indent - 1),
		mlds_output_lval(Ref),
		io__write_string(":\n"),

		mlds_output_statement(Indent, FuncInfo, Handler),

		mlds_indent(Context, Indent - 1),
		mlds_output_lval(Ref),
		io__write_string("_done:\t;\n")

	;
		{ GCC_LocalLabels = no },

		% Output the following:
		%
		%	if (setjmp(<Ref>) == 0)
		%               <Stmt>
		%       else
		%               <Handler>

		%
		% XXX we need to declare the local variables as volatile,
		% because of the setjmp()!
		%

		%
		% we need to take care to avoid problems caused by the
		% dangling else ambiguity
		%
		{
			Stmt0 = statement(if_then_else(_, _, no), Context)
		->
			Stmt = statement(block([], [Stmt0]), Context)
		;
			Stmt = Stmt0
		},

		mlds_indent(Indent),
		io__write_string("if (setjmp("),
		mlds_output_lval(Ref),
		io__write_string(") == 0)\n"),

		mlds_output_statement(Indent + 1, FuncInfo, Stmt),

		mlds_indent(Context, Indent),
		io__write_string("else\n"),

		mlds_output_statement(Indent + 1, FuncInfo, Handler)
	).

%-----------------------------------------------------------------------------%

%
% Extra code for outputting switch statements
%

:- pred mlds_output_switch_case(indent, func_info, mlds__context,
		mlds__switch_case, io__state, io__state).
:- mode mlds_output_switch_case(in, in, in, in, di, uo) is det.

mlds_output_switch_case(Indent, FuncInfo, Context, Case) -->
	{ Case = (Conds - Statement) },
	list__foldl(mlds_output_case_cond(Indent, Context), Conds),
	mlds_output_statement(Indent + 1, FuncInfo, Statement),
	mlds_indent(Context, Indent + 1),
	io__write_string("break;\n").

:- pred mlds_output_case_cond(indent, mlds__context,
		mlds__case_match_cond, io__state, io__state).
:- mode mlds_output_case_cond(in, in, in, di, uo) is det.

mlds_output_case_cond(Indent, Context, match_value(Val)) -->
	mlds_indent(Context, Indent),
	io__write_string("case "),
	mlds_output_rval(Val),
	io__write_string(":\n").
mlds_output_case_cond(Indent, Context, match_range(Low, High)) -->
	% This uses the GNU C extension `case <Low> ... <High>:'.
	mlds_indent(Context, Indent),
	io__write_string("case "),
	mlds_output_rval(Low),
	io__write_string(" ... "),
	mlds_output_rval(High),
	io__write_string(":\n").

:- pred mlds_output_switch_default(indent, func_info, mlds__context,
		mlds__switch_default, io__state, io__state).
:- mode mlds_output_switch_default(in, in, in, in, di, uo) is det.

mlds_output_switch_default(Indent, _FuncInfo, Context, default_is_unreachable) -->
	mlds_indent(Context, Indent),
	io__write_string("default: /*NOTREACHED*/ assert(0);\n").
mlds_output_switch_default(_Indent, _FuncInfo, _Context, default_do_nothing) --> [].
mlds_output_switch_default(Indent, FuncInfo, Context, default_case(Statement)) -->
	mlds_indent(Context, Indent),
	io__write_string("default:\n"),
	mlds_output_statement(Indent + 1, FuncInfo, Statement).

%-----------------------------------------------------------------------------%

	%
	% If memory profiling is turned on output an instruction to
	% record the heap allocation.
	%
:- pred mlds_maybe_output_heap_profile_instr(mlds__context::in,
		indent::in, list(mlds__rval)::in,
		mlds__qualified_entity_name::in, maybe(ctor_name)::in,
		io__state::di, io__state::uo) is det.

mlds_maybe_output_heap_profile_instr(Context, Indent, Args, FuncName,
		MaybeCtorName) -->
	globals__io_lookup_bool_option(profile_memory, ProfileMem),
	(
		{ ProfileMem = yes }
	->
		mlds_indent(Context, Indent),
		io__write_string("MR_record_allocation("),
		io__write_int(list__length(Args)),
		io__write_string(", "),
		mlds_output_fully_qualified_name(FuncName),
		io__write_string(", """),
		mlds_output_fully_qualified_name(FuncName),
		io__write_string(""", "),
		( { MaybeCtorName = yes(CtorName) } ->
			io__write_char('"'),
			c_util__output_quoted_string(CtorName),
			io__write_char('"')
		;
			io__write_string("NULL")
		),
		io__write_string(");\n")
	;
		[]
	).

	%
	% If call profiling is turned on output an instruction to record
	% an arc in the call profile between the callee and caller.
	%
:- pred mlds_maybe_output_call_profile_instr(mlds__context::in,
		indent::in, mlds__rval::in, mlds__qualified_entity_name::in,
		io__state::di, io__state::uo) is det.

mlds_maybe_output_call_profile_instr(Context, Indent,
		CalleeFuncRval, CallerName) -->
	globals__io_lookup_bool_option(profile_calls, ProfileCalls),
	( { ProfileCalls = yes } ->
		mlds_indent(Context, Indent),
		io__write_string("MR_prof_call_profile("),
		mlds_output_bracketed_rval(CalleeFuncRval),
		io__write_string(", "),
		mlds_output_fully_qualified_name(CallerName),
		io__write_string(");\n")
	;
		[]
	).

	%
	% If time profiling is turned on output an instruction which
	% informs the runtime which procedure we are currently located
	% in.
	%
:- pred mlds_maybe_output_time_profile_instr(mlds__context::in,
		indent::in, mlds__qualified_entity_name::in,
		io__state::di, io__state::uo) is det.

mlds_maybe_output_time_profile_instr(Context, Indent, Name) -->
	globals__io_lookup_bool_option(profile_time, ProfileTime),
	(
		{ ProfileTime = yes }
	->
		mlds_indent(Context, Indent),
		io__write_string("MR_set_prof_current_proc("),
		mlds_output_fully_qualified_name(Name),
		io__write_string(");\n")
	;
		[]
	).

%-----------------------------------------------------------------------------%

	%
	% exception handling
	%

	/* XXX not yet implemented */


	%
	% atomic statements
	%
gen_stmt(FuncInfo, atomic(AtomicStatement), Context) -->
	build_atomic_stmt(FuncInfo, AtomicStatement, Context).
mlds_output_stmt(Indent, FuncInfo, atomic(AtomicStatement), Context) -->
	mlds_output_atomic_stmt(Indent, FuncInfo, AtomicStatement, Context).

:- pred mlds_output_label_name(mlds__label, io__state, io__state).
:- mode mlds_output_label_name(in, di, uo) is det.

mlds_output_label_name(LabelName) -->
	mlds_output_mangled_name(LabelName).

:- pred build_atomic_stmt(func_info,
		mlds__atomic_statement, mlds__context, io__state, io__state).
:- mode build_atomic_stmt(in, in, in, di, uo) is det.

	%
	% comments
	%
build_atomic_stmt(_FuncInfo, comment(Comment), _) -->
	% XXX we should escape any "*/"'s in the Comment.
	%     we should also split the comment into lines and indent
	%     each line appropriately.
	io__write_string("/* "),
	io__write_string(Comment),
	io__write_string(" */\n").

	%
	% assignment
	%
build_atomic_stmt(FuncInfo, assign(Lval, Rval), _) -->
	build_lval(Lval, FuncInfo, GCC_Lval),
	build_rval(Rval, FuncInfo, GCC_Rval),
	gcc__gen_assign(GCC_Lval, GCC_Rval).

	%
	% heap management
	%
build_atomic_stmt(_FuncInfo, delete_object(_Lval), _) -->
	{ sorry(this_file, "delete_object") }.

build_atomic_stmt(FuncInfo, NewObject, Context) -->
	{ NewObject = new_object(Target, MaybeTag, Type, MaybeSize,
		_MaybeCtorName, Args, ArgTypes) },

	% Calculate the size that we're going to allocate

	( { MaybeSize = yes(SizeInBytes0) } ->
		% Rather than generating a reference to a global variable
		% mercury__private_builtin__SIZEOF_WORD, we ignore the
		% word size multiplier, and instead get the word size
		% from the bytes_per_word option.
		% XXX This is kludgy.  We should change new_object
		% so that it has the size in words rather than in bytes.
		(
			{ SizeInBytes0 = binop((*), SizeInWords,
				_SizeOfWord) }
		->
			globals__io_lookup_int_option(bytes_per_word,
				BytesPerWord),
			{ SizeOfWord = const(int_const(BytesPerWord)) },
			{ SizeInBytes = binop((*), SizeInWords, SizeOfWord) }
		;
			{ sorry(this_file, "unexpected size in new_object") },
			{ SizeInBytes0 = SizeInBytes }
		)
		% io__print("SizeInBytes0 = "), io__print(SizeInBytes0), io__nl,
		% io__print("SizeInBytes = "), io__print(SizeInBytes), io__nl,
	;
		{ sorry(this_file, "new_object with unknown size") }
	),

	%
	% Generate `Target = (Type) GC_malloc(SizeInBytes)'.
	%

	% generate `GC_malloc(SizeInBytes)'
	gcc__build_func_addr_expr(gcc__alloc_func_decl, AllocFuncExpr),
	build_args([SizeInBytes], FuncInfo, GCC_ArgList),
	{ IsTailCall = no },
	gcc__build_call_expr(AllocFuncExpr, GCC_ArgList, IsTailCall, GCC_Call),

	% cast the result to (Type)
	build_type(Type, GCC_Type),
	gcc__convert_type(GCC_Call, GCC_Type, GCC_CastCall),

	% add a tag to the pointer, if necessary
	( { MaybeTag = yes(Tag0) } ->
		{ Tag = Tag0 },
		gcc__build_int(Tag, GCC_Tag),
		gcc__build_binop(gcc__plus_expr, GCC_Type,
			GCC_CastCall, GCC_Tag, GCC_TaggedCastCall)
	;
		{ Tag = 0 },
		{ GCC_TaggedCastCall = GCC_CastCall }
	),

	% assign it to Target
	build_lval(Target, FuncInfo, GCC_Target),
	gcc__gen_assign(GCC_Target, GCC_TaggedCastCall),
	
	% initialize the fields
	gen_init_args(Args, ArgTypes, Context, 0, Target, Type, Tag,
		FuncInfo).

build_atomic_stmt(_FuncInfo, mark_hp(_Lval), _) -->
	{ sorry(this_file, "mark_hp") }.

build_atomic_stmt(_FuncInfo, restore_hp(_Rval), _) -->
	{ sorry(this_file, "restore_hp") }.

	%
	% trail management
	%
build_atomic_stmt(_FuncInfo, trail_op(_TrailOp), _) -->
	{ sorry(this_file, "trail_op") }.

	%
	% foreign language interfacing
	%
build_atomic_stmt(_FuncInfo, target_code(TargetLang, Components),
		Context) -->
	{ sorry(this_file, "target_code") },
	( { TargetLang = lang_asm } ->
		list__foldl(
			mlds_output_target_code_component(Context),
			Components)
	;
		{ error("mlds_to_c.m: sorry, target_code only works for lang_asm") }
	).

:- pred mlds_output_atomic_stmt(indent, func_info,
		mlds__atomic_statement, mlds__context, io__state, io__state).
:- mode mlds_output_atomic_stmt(in, in, in, in, di, uo) is det.

	%
	% comments
	%
mlds_output_atomic_stmt(Indent, _FuncInfo, comment(Comment), _) -->
	% XXX we should escape any "*/"'s in the Comment.
	%     we should also split the comment into lines and indent
	%     each line appropriately.
	mlds_indent(Indent),
	io__write_string("/* "),
	io__write_string(Comment),
	io__write_string(" */\n").

	%
	% assignment
	%
mlds_output_atomic_stmt(Indent, _FuncInfo, assign(Lval, Rval), _) -->
	mlds_indent(Indent),
	mlds_output_lval(Lval),
	io__write_string(" = "),
	mlds_output_rval(Rval),
	io__write_string(";\n").

	%
	% heap management
	%
mlds_output_atomic_stmt(_Indent, _FuncInfo, delete_object(_Lval), _) -->
	{ error("mlds_to_c.m: sorry, delete_object not implemented") }.

mlds_output_atomic_stmt(Indent, FuncInfo, NewObject, Context) -->
	{ NewObject = new_object(Target, MaybeTag, Type, MaybeSize,
		MaybeCtorName, Args, ArgTypes) },
	mlds_indent(Indent),
	io__write_string("{\n"),

	{ FuncName = FuncInfo ^ func_name },
	mlds_maybe_output_heap_profile_instr(Context, Indent + 1, Args,
			FuncName, MaybeCtorName),

	mlds_indent(Context, Indent + 1),
	mlds_output_lval(Target),
	io__write_string(" = "),
	( { MaybeTag = yes(Tag0) } ->
		{ Tag = Tag0 },
		mlds_output_cast(Type),
		io__write_string("MR_mkword("),
		mlds_output_tag(Tag),
		io__write_string(", "),
		{ EndMkword = ")" }
	;
		{ Tag = 0 },
		%
		% XXX we shouldn't need the cast here,
		% but currently the type that we include
		% in the call to MR_new_object() is not
		% always correct.
		%
		mlds_output_cast(Type),
		{ EndMkword = "" }
	),
	io__write_string("MR_new_object("),
	mlds_output_type(Type),
	io__write_string(", "),
	( { MaybeSize = yes(Size) } ->
		mlds_output_rval(Size)
	;
		% XXX what should we do here?
		io__write_int(-1)
	),
	io__write_string(", "),
	( { MaybeCtorName = yes(CtorName) } ->
		io__write_char('"'),
		c_util__output_quoted_string(CtorName),
		io__write_char('"')
	;
		io__write_string("NULL")
	),
	io__write_string(")"),
	io__write_string(EndMkword),
	io__write_string(";\n"),
	mlds_output_init_args(Args, ArgTypes, Context, 0, Target, Tag,
		Indent + 1),
	mlds_indent(Context, Indent),
	io__write_string("}\n").

mlds_output_atomic_stmt(Indent, _FuncInfo, mark_hp(Lval), _) -->
	mlds_indent(Indent),
	io__write_string("MR_mark_hp("),
	mlds_output_lval(Lval),
	io__write_string(");\n").

mlds_output_atomic_stmt(Indent, _FuncInfo, restore_hp(Rval), _) -->
	mlds_indent(Indent),
	io__write_string("MR_restore_hp("),
	mlds_output_rval(Rval),
	io__write_string(");\n").

	%
	% trail management
	%
mlds_output_atomic_stmt(_Indent, _FuncInfo, trail_op(_TrailOp), _) -->
	{ error("mlds_to_c.m: sorry, trail_ops not implemented") }.

	%
	% foreign language interfacing
	%
mlds_output_atomic_stmt(_Indent, _FuncInfo, target_code(TargetLang, Components),
		Context) -->
	( { TargetLang = lang_C } ->
		list__foldl(
			mlds_output_target_code_component(Context),
			Components)
	;
		{ error("mlds_to_c.m: sorry, target_code only works for lang_C") }
	).

:- pred mlds_output_target_code_component(mlds__context, target_code_component,
		io__state, io__state).
:- mode mlds_output_target_code_component(in, in, di, uo) is det.

mlds_output_target_code_component(Context,
		user_target_code(CodeString, MaybeUserContext)) -->
	( { MaybeUserContext = yes(UserContext) } ->
		mlds_output_context(mlds__make_context(UserContext))
	;
		mlds_output_context(Context)
	),
	io__write_string(CodeString),
	io__write_string("\n").
mlds_output_target_code_component(Context, raw_target_code(CodeString)) -->
	mlds_output_context(Context),
	io__write_string(CodeString).
mlds_output_target_code_component(Context, target_code_input(Rval)) -->
	mlds_output_context(Context),
	mlds_output_rval(Rval),
	io__write_string("\n").
mlds_output_target_code_component(Context, target_code_output(Lval)) -->
	mlds_output_context(Context),
	mlds_output_lval(Lval),
	io__write_string("\n").
mlds_output_target_code_component(_Context, name(Name)) -->
	% Note: `name(Name)' target_code_components are used to
	% generate the #define for `MR_PROC_LABEL'.
	% The fact that they're used in a #define means that we can't do
	% an mlds_output_context(Context) here, since #line directives
	% aren't allowed inside #defines.
	mlds_output_fully_qualified_name(Name),
	io__write_string("\n").

:- pred gen_init_args(list(mlds__rval), list(mlds__type), mlds__context, int,
		mlds__lval, mlds__type, mlds__tag, func_info,
		io__state, io__state).
:- mode gen_init_args(in, in, in, in, in, in, in, in, di, uo) is det.

gen_init_args([_|_], [], _, _, _, _, _, _) -->
	{ error("gen_init_args: length mismatch") }.
gen_init_args([], [_|_], _, _, _, _, _, _) -->
	{ error("gen_init_args: length mismatch") }.
gen_init_args([], [], _, _, _, _, _, _) --> [].
gen_init_args([Arg | Args], [ArgType | ArgTypes], Context,
		ArgNum, Target, Type, Tag, FuncInfo) -->
	%
	% Currently all fields of new_object instructions are
	% represented as MR_Box, so we need to box them if necessary.
	%
	{ Lval = field(yes(Tag), lval(Target),
		offset(const(int_const(ArgNum))), mlds__generic_type, Type) },
	{ Rval = unop(box(ArgType), Arg) },
	build_lval(Lval, FuncInfo, GCC_Lval),
	build_rval(Rval, FuncInfo, GCC_Rval),
	gcc__gen_assign(GCC_Lval, GCC_Rval),
	gen_init_args(Args, ArgTypes, Context,
			ArgNum + 1, Target, Type, Tag, FuncInfo).

:- pred mlds_output_init_args(list(mlds__rval), list(mlds__type), mlds__context,
		int, mlds__lval, mlds__tag, indent, io__state, io__state).
:- mode mlds_output_init_args(in, in, in, in, in, in, in, di, uo) is det.

mlds_output_init_args([_|_], [], _, _, _, _, _) -->
	{ error("mlds_output_init_args: length mismatch") }.
mlds_output_init_args([], [_|_], _, _, _, _, _) -->
	{ error("mlds_output_init_args: length mismatch") }.
mlds_output_init_args([], [], _, _, _, _, _) --> [].
mlds_output_init_args([Arg|Args], [ArgType|ArgTypes], Context,
		ArgNum, Target, Tag, Indent) -->
	%
	% Currently all fields of new_object instructions are
	% represented as MR_Box, so we need to box them if necessary.
	%
	mlds_indent(Context, Indent),
	io__write_string("MR_field("),
	mlds_output_tag(Tag),
	io__write_string(", "),
	mlds_output_lval(Target),
	io__write_string(", "),
	io__write_int(ArgNum),
	io__write_string(") = (MR_Word) "),
	mlds_output_boxed_rval(ArgType, Arg),
	io__write_string(";\n"),
	mlds_output_init_args(Args, ArgTypes, Context,
		ArgNum + 1, Target, Tag, Indent).

%-----------------------------------------------------------------------------%
%
% Code to output expressions
%

:- pred build_lval(mlds__lval, func_info, gcc__expr, io__state, io__state).
:- mode build_lval(in, in, out, di, uo) is det.

build_lval(field(MaybeTag, Rval, offset(OffsetRval),
		FieldType, _ClassType), FuncInfo, GCC_FieldRef) -->
	% sanity check (copied from mlds_to_c.m)
	(
		{ FieldType = mlds__generic_type
		; FieldType = mlds__mercury_type(term__variable(_), _)
		}
	->
		[]
	;
		% The field type for field(_, _, offset(_), _, _) lvals
		% must be something that maps to MR_Box.
		{ error("unexpected field type") }
	),

	% generate the tagged pointer whose field we want to extract
	build_rval(Rval, FuncInfo, GCC_TaggedPointer),

	% subtract or mask out the tag
	( { MaybeTag = yes(Tag) } ->
		gcc__build_int(Tag, GCC_Tag),
		gcc__build_binop(gcc__minus_expr, gcc__ptr_type_node,
			GCC_TaggedPointer, GCC_Tag, GCC_Pointer)
	;
		globals__io_lookup_int_option(num_tag_bits, TagBits),
		gcc__build_int(\ ((1 << TagBits) - 1), GCC_Mask),
		gcc__build_binop(gcc__bit_and_expr, gcc__ptr_type_node,
			GCC_TaggedPointer, GCC_Mask, GCC_Pointer)
	),

	% add the appropriate offset
	build_rval(OffsetRval, FuncInfo, GCC_OffsetInWords),
	globals__io_lookup_int_option(bytes_per_word, BytesPerWord),
	gcc__build_int(BytesPerWord, GCC_BytesPerWord),
	gcc__build_binop(gcc__mult_expr, gcc__integer_type_node,
		GCC_OffsetInWords, GCC_BytesPerWord, GCC_OffsetInBytes),
	gcc__build_binop(gcc__plus_expr, gcc__ptr_type_node,
		GCC_Pointer, GCC_OffsetInBytes, GCC_FieldPointer0),

	% cast the pointer to the right type (XXX is this necessary?)
	build_type(FieldType, GCC_FieldType),
	gcc__build_pointer_type(GCC_FieldType, GCC_FieldPointerType),
	gcc__convert_type(GCC_FieldPointer0, GCC_FieldPointerType,
		GCC_FieldPointer),

	% deference it
	gcc__build_pointer_deref(GCC_FieldPointer, GCC_FieldRef).

build_lval(field(MaybeTag, PtrRval, named_field(FieldName, CtorType),
		_FieldType, _PtrType), _FuncInfo, _Expr) -->
	{ sorry(this_file, "field (named)") },
	% XXX we shouldn't bother with this cast in the case where
	% PtrType == CtorType
	io__write_string("("),
	mlds_output_cast(CtorType),
	( { MaybeTag = yes(0) } ->
		( { PtrRval = mem_addr(Lval) } ->
			mlds_output_lval(Lval),
			io__write_string(").")
		;
			mlds_output_bracketed_rval(PtrRval),
			io__write_string(")->")
		)
	;
		( { MaybeTag = yes(Tag) } ->
			io__write_string("MR_body("),
			mlds_output_rval(PtrRval),
			io__write_string(", "),
			mlds_output_tag(Tag)
		;
			io__write_string("MR_strip_tag("),
			mlds_output_rval(PtrRval)
		),
		io__write_string("))->")
	),
	mlds_output_fully_qualified(FieldName, mlds_output_mangled_name).
build_lval(mem_ref(PointerRval, _Type), FuncInfo, Expr) -->
	build_rval(PointerRval, FuncInfo, PointerExpr),
	gcc__build_pointer_deref(PointerExpr, Expr).
build_lval(var(qual(ModuleName, VarName)), FuncInfo, Expr) -->
	{ SymbolTable = FuncInfo ^ symbol_table },
	{ VarDecl = map__lookup(SymbolTable,
		qual(ModuleName, data(var(VarName)))) },
	{ Expr = gcc__var_expr(VarDecl) }.

:- pred mlds_output_lval(mlds__lval, io__state, io__state).
:- mode mlds_output_lval(in, di, uo) is det.

mlds_output_lval(field(MaybeTag, Rval, offset(OffsetRval),
		FieldType, _ClassType)) -->
	(
		{ FieldType = mlds__generic_type
		; FieldType = mlds__mercury_type(term__variable(_), _)
		}
	->
		% XXX this generated code is ugly;
		% it would be nicer to use a different macro
		% than MR_field(), one which had type `MR_Box'
		% rather than `MR_Word'.
		io__write_string("(* (MR_Box *) &")
	;
		% The field type for field(_, _, offset(_), _, _) lvals
		% must be something that maps to MR_Box.
		{ error("unexpected field type") }
	),
	( { MaybeTag = yes(Tag) } ->
		io__write_string("MR_field("),
		mlds_output_tag(Tag),
		io__write_string(", ")
	;
		io__write_string("MR_mask_field(")
	),
	io__write_string("(MR_Word) "),
	mlds_output_rval(Rval),
	io__write_string(", "),
	mlds_output_rval(OffsetRval),
	io__write_string("))").
mlds_output_lval(field(MaybeTag, PtrRval, named_field(FieldName, CtorType),
		_FieldType, _PtrType)) -->
	% XXX we shouldn't bother with this cast in the case where
	% PtrType == CtorType
	io__write_string("("),
	mlds_output_cast(CtorType),
	( { MaybeTag = yes(0) } ->
		( { PtrRval = mem_addr(Lval) } ->
			mlds_output_lval(Lval),
			io__write_string(").")
		;
			mlds_output_bracketed_rval(PtrRval),
			io__write_string(")->")
		)
	;
		( { MaybeTag = yes(Tag) } ->
			io__write_string("MR_body("),
			mlds_output_rval(PtrRval),
			io__write_string(", "),
			mlds_output_tag(Tag)
		;
			io__write_string("MR_strip_tag("),
			mlds_output_rval(PtrRval)
		),
		io__write_string("))->")
	),
	mlds_output_fully_qualified(FieldName, mlds_output_mangled_name).
mlds_output_lval(mem_ref(Rval, _Type)) -->
	io__write_string("*"),
	mlds_output_bracketed_rval(Rval).
mlds_output_lval(var(VarName)) -->
	mlds_output_var(VarName).

:- pred mlds_output_var(mlds__var, io__state, io__state).
:- mode mlds_output_var(in, di, uo) is det.

mlds_output_var(VarName) -->
	mlds_output_fully_qualified(VarName, mlds_output_mangled_name).

:- pred mlds_output_mangled_name(string, io__state, io__state).
:- mode mlds_output_mangled_name(in, di, uo) is det.

mlds_output_mangled_name(Name) -->
	{ llds_out__name_mangle(Name, MangledName) },
	io__write_string(MangledName).

:- pred mlds_output_bracketed_lval(mlds__lval, io__state, io__state).
:- mode mlds_output_bracketed_lval(in, di, uo) is det.

mlds_output_bracketed_lval(Lval) -->
	(
		% if it's just a variable name, then we don't need parentheses
		{ Lval = var(_) }
	->
		mlds_output_lval(Lval)
	;
		io__write_char('('),
		mlds_output_lval(Lval),
		io__write_char(')')
	).

:- pred mlds_output_bracketed_rval(mlds__rval, io__state, io__state).
:- mode mlds_output_bracketed_rval(in, di, uo) is det.

mlds_output_bracketed_rval(Rval) -->
	(
		% if it's just a variable name, then we don't need parentheses
		{ Rval = lval(var(_))
		; Rval = const(code_addr_const(_))
		}
	->
		mlds_output_rval(Rval)
	;
		io__write_char('('),
		mlds_output_rval(Rval),
		io__write_char(')')
	).

:- pred build_args(list(mlds__rval), func_info, gcc__arg_list,
		io__state, io__state).
:- mode build_args(in, in, out, di, uo) is det.

build_args([], _FuncInfo, EmptyArgList) -->
	gcc__empty_arg_list(EmptyArgList).
build_args([Arg|Args], FuncInfo, GCC_ArgList) -->
	build_rval(Arg, FuncInfo, GCC_Expr),
	build_args(Args, FuncInfo, GCC_ArgList0),
	gcc__cons_arg_list(GCC_Expr, GCC_ArgList0, GCC_ArgList).

:- pred build_rval(mlds__rval, func_info, gcc__expr, io__state, io__state).
:- mode build_rval(in, in, out, di, uo) is det.

build_rval(lval(Lval), FuncInfo, Expr) -->
	build_lval(Lval, FuncInfo, Expr).

build_rval(mkword(Tag, Arg), FuncInfo, Expr) -->
	gcc__build_int(Tag, GCC_Tag),
	build_rval(Arg, FuncInfo, GCC_Arg),
	gcc__build_binop(gcc__plus_expr, gcc__ptr_type_node,
		GCC_Arg, GCC_Tag, Expr).

build_rval(const(Const), _FuncInfo, Expr) -->
	build_rval_const(Const, Expr).

build_rval(unop(Op, Rval), FuncInfo, Expr) -->
	build_unop(Op, Rval, FuncInfo, Expr).

build_rval(binop(Op, Rval1, Rval2), FuncInfo, Expr) -->
	build_std_binop(Op, Rval1, Rval2, FuncInfo, Expr).

build_rval(mem_addr(Lval), FuncInfo, AddrExpr) -->
	build_lval(Lval, FuncInfo, Expr),
	gcc__build_addr_expr(Expr, AddrExpr).

:- pred mlds_output_rval(mlds__rval, io__state, io__state).
:- mode mlds_output_rval(in, di, uo) is det.

mlds_output_rval(lval(Lval)) -->
	mlds_output_lval(Lval).

mlds_output_rval(mkword(Tag, Rval)) -->
	io__write_string("(MR_Word) MR_mkword("),
	mlds_output_tag(Tag),
	io__write_string(", "),
	mlds_output_rval(Rval),
	io__write_string(")").

mlds_output_rval(const(Const)) -->
	mlds_output_rval_const(Const).

mlds_output_rval(unop(Op, Rval)) -->
	mlds_output_unop(Op, Rval).

mlds_output_rval(binop(Op, Rval1, Rval2)) -->
	mlds_output_binop(Op, Rval1, Rval2).

mlds_output_rval(mem_addr(Lval)) -->
	% XXX are parentheses needed?
	io__write_string("&"),
	mlds_output_lval(Lval).

:- pred build_unop(mlds__unary_op, mlds__rval, func_info, gcc__expr,
		io__state, io__state).
:- mode build_unop(in, in, in, out, di, uo) is det.
	
build_unop(cast(Type), Rval, FuncInfo, GCC_Expr) -->
	build_cast_rval(Type, Rval, FuncInfo, GCC_Expr).
build_unop(box(Type), Rval, FuncInfo, GCC_Expr) -->
	(
		{ type_is_float(Type) }
	->
		{ sorry(this_file, "boxing of floats") }
	;
		build_cast_rval(mlds__generic_type, Rval, FuncInfo, GCC_Expr)
	).
build_unop(unbox(Type), Rval, FuncInfo, GCC_Expr) -->
	(
		{ type_is_float(Type) }
	->
		{ sorry(this_file, "unboxing of floats") }
	;
		build_cast_rval(Type, Rval, FuncInfo, GCC_Expr)
	).
build_unop(std_unop(Unop), Exprn, FuncInfo, GCC_Expr) -->
	build_std_unop(Unop, Exprn, FuncInfo, GCC_Expr).

:- pred type_is_float(mlds__type::in) is semidet.
type_is_float(Type) :-
	( Type = mlds__mercury_type(term__functor(term__atom("float"),
			[], _), _)
	; Type = mlds__native_float_type
	).

:- pred mlds_output_unop(mlds__unary_op, mlds__rval, io__state, io__state).
:- mode mlds_output_unop(in, in, di, uo) is det.
	
mlds_output_unop(cast(Type), Exprn) -->
	mlds_output_cast_rval(Type, Exprn).
mlds_output_unop(box(Type), Exprn) -->
	mlds_output_boxed_rval(Type, Exprn).
mlds_output_unop(unbox(Type), Exprn) -->
	mlds_output_unboxed_rval(Type, Exprn).
mlds_output_unop(std_unop(Unop), Exprn) -->
	mlds_output_std_unop(Unop, Exprn).

:- pred build_cast_rval(mlds__type, mlds__rval, func_info, gcc__expr,
		io__state, io__state).
:- mode build_cast_rval(in, in, in, out, di, uo) is det.
	
build_cast_rval(Type, Rval, FuncInfo, GCC_Expr) -->
	build_rval(Rval, FuncInfo, GCC_Rval),
	build_type(Type, GCC_Type),
	gcc__convert_type(GCC_Rval, GCC_Type, GCC_Expr).

:- pred mlds_output_cast_rval(mlds__type, mlds__rval, io__state, io__state).
:- mode mlds_output_cast_rval(in, in, di, uo) is det.
	
mlds_output_cast_rval(Type, Exprn) -->
	mlds_output_cast(Type),
	mlds_output_rval(Exprn).

:- pred mlds_output_cast(mlds__type, io__state, io__state).
:- mode mlds_output_cast(in, di, uo) is det.
	
mlds_output_cast(Type) -->
	io__write_string("("),
	mlds_output_type(Type),
	io__write_string(") ").

:- pred mlds_output_boxed_rval(mlds__type, mlds__rval, io__state, io__state).
:- mode mlds_output_boxed_rval(in, in, di, uo) is det.
	
mlds_output_boxed_rval(Type, Exprn) -->
	(
		{ Type = mlds__mercury_type(term__functor(term__atom("float"),
				[], _), _)
		; Type = mlds__native_float_type
		}
	->
		io__write_string("MR_box_float("),
		mlds_output_rval(Exprn),
		io__write_string(")")
	;
		% We cast first to MR_Word, and then to MR_Box.
		% This is done to avoid spurious warnings about "cast from
		% pointer to integer of different size" from gcc.
		% XXX The generated code would be more readable if we
		%     only did this for the cases where it was necessary.
		io__write_string("((MR_Box) (MR_Word) ("),
		mlds_output_rval(Exprn),
		io__write_string("))")
	).

:- pred build_std_unop(builtin_ops__unary_op, mlds__rval, func_info,
		gcc__expr, io__state, io__state).
:- mode build_std_unop(in, in, in, out, di, uo) is det.
	
build_std_unop(UnaryOp, Arg, FuncInfo, Expr) -->
	build_rval(Arg, FuncInfo, GCC_Arg),
	build_unop_expr(UnaryOp, GCC_Arg, Expr).

:- pred build_unop_expr(builtin_ops__unary_op, gcc__expr, gcc__expr,
		io__state, io__state).
:- mode build_unop_expr(in, in, out, di, uo) is det.

% We assume that the tag bits are kept on the low bits
% (`--tags low'), not on the high bits (`--tags high').
% XXX we should enforce this in handle_options.m.

build_unop_expr(mktag, Tag, Tag) --> [].
build_unop_expr(tag, Arg, Expr) -->
	globals__io_lookup_int_option(num_tag_bits, TagBits),
	gcc__build_int((1 << TagBits) - 1, Mask),
	gcc__build_binop(gcc__bit_and_expr, gcc__integer_type_node,
		Arg, Mask, Expr).
build_unop_expr(unmktag, Tag, Tag) --> [].
build_unop_expr(mkbody, Arg, Expr) -->
	globals__io_lookup_int_option(num_tag_bits, TagBits),
	gcc__build_int(TagBits, TagBitsExpr),
	gcc__build_binop(gcc__lshift_expr, gcc__integer_type_node,
		Arg, TagBitsExpr, Expr).
build_unop_expr(unmkbody, Arg, Expr) -->
	globals__io_lookup_int_option(num_tag_bits, TagBits),
	gcc__build_int(TagBits, TagBitsExpr),
	gcc__build_binop(gcc__rshift_expr, gcc__integer_type_node,
		Arg, TagBitsExpr, Expr).
build_unop_expr(cast_to_unsigned, _, _) -->
	{ sorry(this_file, "cast_to_unsigned") }.
build_unop_expr(hash_string, Arg, Expr) -->
	gcc__build_func_addr_expr(gcc__hash_string_func_decl,
		HashStringFuncExpr),
	gcc__empty_arg_list(GCC_ArgList0),
	gcc__cons_arg_list(Arg, GCC_ArgList0, GCC_ArgList),
	{ IsTailCall = no },
	gcc__build_call_expr(HashStringFuncExpr, GCC_ArgList,
		IsTailCall, Expr).
build_unop_expr(bitwise_complement, Arg, Expr) -->
	gcc__build_unop(gcc__bit_not_expr, gcc__integer_type_node, Arg, Expr).
build_unop_expr((not), Arg, Expr) -->
	gcc__build_unop(gcc__truth_not_expr, gcc__boolean_type_node, Arg, Expr).

:- pred build_std_binop(builtin_ops__binary_op, mlds__rval, mlds__rval,
		func_info, gcc__expr, io__state, io__state).
:- mode build_std_binop(in, in, in, in, out, di, uo) is det.
	
build_std_binop(BinaryOp, Arg1, Arg2, FuncInfo, Expr) -->
	( { string_compare_op(BinaryOp, CorrespondingIntOp) } ->
		%
		% treat string comparison operators specially:
		% convert "X `str_OP` Y" into "strcmp(X, Y) `OP` 0"
		%
		gcc__build_func_addr_expr(gcc__strcmp_func_decl,
			StrcmpFuncExpr),
		build_args([Arg1, Arg2], FuncInfo, GCC_ArgList),
		{ IsTailCall = no },
		gcc__build_call_expr(StrcmpFuncExpr, GCC_ArgList, IsTailCall,
			GCC_Call),
		gcc__build_int(0, Zero),
		gcc__build_binop(CorrespondingIntOp, gcc__boolean_type_node,
			GCC_Call, Zero, Expr)
	;
		%
		% the usual case: just build a gcc tree node for the expr.
		%
		build_rval(Arg1, FuncInfo, GCC_Arg1),
		build_rval(Arg2, FuncInfo, GCC_Arg2),
		{ convert_binary_op(BinaryOp, GCC_BinaryOp, GCC_ResultType) },
		gcc__build_binop(GCC_BinaryOp, GCC_ResultType,
			GCC_Arg1, GCC_Arg2, Expr)
	).

:- pred string_compare_op(builtin_ops__binary_op, gcc__op).
:- mode string_compare_op(in, out) is semidet.
string_compare_op(str_eq, gcc__eq_expr).
string_compare_op(str_ne, gcc__ne_expr).
string_compare_op(str_lt, gcc__lt_expr).
string_compare_op(str_gt, gcc__gt_expr).
string_compare_op(str_le, gcc__le_expr).
string_compare_op(str_ge, gcc__ge_expr).

	% Convert one of our operators to the corresponding
	% gcc operator.  Also compute the gcc return type.
:- pred convert_binary_op(builtin_ops__binary_op, gcc__op, gcc__type).
:- mode convert_binary_op(in, out, out) is det.

		% Operator	GCC operator	     GCC result type
convert_binary_op(+,		gcc__plus_expr,      gcc__integer_type_node).
convert_binary_op(-,		gcc__minus_expr,     gcc__integer_type_node).
convert_binary_op(*,		gcc__mult_expr,      gcc__integer_type_node).
convert_binary_op(/,		gcc__trunc_div_expr, gcc__integer_type_node).
convert_binary_op((mod),	gcc__trunc_mod_expr, gcc__integer_type_node).
convert_binary_op((<<),		gcc__lshift_expr,    gcc__integer_type_node).
convert_binary_op((>>),		gcc__rshift_expr,    gcc__integer_type_node).
convert_binary_op((&),		gcc__bit_and_expr,   gcc__integer_type_node).
convert_binary_op(('|'),	gcc__bit_ior_expr,   gcc__integer_type_node).
convert_binary_op((^),		gcc__bit_xor_expr,   gcc__integer_type_node).
convert_binary_op((and),	gcc__truth_andif_expr, gcc__boolean_type_node).
convert_binary_op((or),		gcc__truth_orif_expr, gcc__boolean_type_node).
convert_binary_op(eq,		gcc__eq_expr,	     gcc__boolean_type_node).
convert_binary_op(ne,		gcc__ne_expr,	     gcc__boolean_type_node).
convert_binary_op(body,		gcc__minus_expr,     gcc__integer_type_node).
convert_binary_op(array_index,  gcc__array_ref,	     Type) :-
	% XXX temp hack -- this is wrong.
	% We should change builtin_ops:array_index
	% so that it takes the type as an argument.
	Type = gcc__integer_type_node.
convert_binary_op(str_eq, _, _) :- unexpected(this_file, "str_eq").
convert_binary_op(str_ne, _, _) :- unexpected(this_file, "str_ne").
convert_binary_op(str_lt, _, _) :- unexpected(this_file, "str_lt").
convert_binary_op(str_gt, _, _) :- unexpected(this_file, "str_gt").
convert_binary_op(str_le, _, _) :- unexpected(this_file, "str_le").
convert_binary_op(str_ge, _, _) :- unexpected(this_file, "str_ge").
convert_binary_op((<),		gcc__le_expr,	     gcc__boolean_type_node).
convert_binary_op((>),		gcc__gt_expr,	     gcc__boolean_type_node).
convert_binary_op((<=),		gcc__le_expr,	     gcc__boolean_type_node).
convert_binary_op((>=),		gcc__ge_expr,	     gcc__boolean_type_node).
convert_binary_op(float_plus,	gcc__plus_expr,	     gcc__double_type_node).
convert_binary_op(float_minus,	gcc__minus_expr,     gcc__double_type_node).
convert_binary_op(float_times,	gcc__mult_expr,	     gcc__double_type_node).
convert_binary_op(float_divide,	gcc__trunc_div_expr, gcc__double_type_node).
convert_binary_op(float_eq,	gcc__eq_expr,	     gcc__boolean_type_node).
convert_binary_op(float_ne,	gcc__ne_expr,	     gcc__boolean_type_node).
convert_binary_op(float_lt,	gcc__lt_expr,	     gcc__boolean_type_node).
convert_binary_op(float_gt,	gcc__gt_expr,	     gcc__boolean_type_node).
convert_binary_op(float_le,	gcc__le_expr,	     gcc__boolean_type_node).
convert_binary_op(float_ge,	gcc__ge_expr,	     gcc__boolean_type_node).

%-----------------------------------------------------------------------------%

:- pred mlds_output_unboxed_rval(mlds__type, mlds__rval, io__state, io__state).
:- mode mlds_output_unboxed_rval(in, in, di, uo) is det.
	
mlds_output_unboxed_rval(Type, Exprn) -->
	(
		{ Type = mlds__mercury_type(term__functor(term__atom("float"),
				[], _), _)
		; Type = mlds__native_float_type
		}
	->
		io__write_string("MR_unbox_float("),
		mlds_output_rval(Exprn),
		io__write_string(")")
	;
		% We cast first to MR_Word, and then to the desired type.
		% This is done to avoid spurious warnings about "cast from
		% pointer to integer of different size" from gcc.
		% XXX The generated code would be more readable if we
		%     only did this for the cases where it was necessary.
		io__write_string("("),
		mlds_output_cast(Type),
		io__write_string("(MR_Word) "),
		mlds_output_rval(Exprn),
		io__write_string(")")
	).

:- pred mlds_output_std_unop(builtin_ops__unary_op, mlds__rval,
		io__state, io__state).
:- mode mlds_output_std_unop(in, in, di, uo) is det.
	
mlds_output_std_unop(UnaryOp, Exprn) -->
	{ c_util__unary_prefix_op(UnaryOp, UnaryOpString) },
	io__write_string(UnaryOpString),
	io__write_string("("),
	( { UnaryOp = tag } ->
		% The MR_tag macro requires its argument to be of type 
		% `MR_Word'.
		% XXX should we put this cast inside the definition of MR_tag?
		io__write_string("(MR_Word) ")
	;
		[]
	),
	mlds_output_rval(Exprn),
	io__write_string(")").

:- pred mlds_output_binop(binary_op, mlds__rval, mlds__rval,
			io__state, io__state).
:- mode mlds_output_binop(in, in, in, di, uo) is det.
	
mlds_output_binop(Op, X, Y) -->
	(
		{ Op = array_index }
	->
		mlds_output_bracketed_rval(X),
		io__write_string("["),
		mlds_output_rval(Y),
		io__write_string("]")
	;
		{ c_util__string_compare_op(Op, OpStr) }
	->
		io__write_string("(strcmp("),
		mlds_output_rval(X),
		io__write_string(", "),
		mlds_output_rval(Y),
		io__write_string(")"),
		io__write_string(" "),
		io__write_string(OpStr),
		io__write_string(" "),
		io__write_string("0)")
	;
		( { c_util__float_compare_op(Op, OpStr1) } ->
			{ OpStr = OpStr1 }
		; { c_util__float_op(Op, OpStr2) } ->
			{ OpStr = OpStr2 }
		;
			{ fail }
		)
	->
		io__write_string("("),
		mlds_output_bracketed_rval(X),
		io__write_string(" "),
		io__write_string(OpStr),
		io__write_string(" "),
		mlds_output_bracketed_rval(Y),
		io__write_string(")")
	;
/****
XXX broken for C == minint
(since `NewC is 0 - C' overflows)
		{ Op = (+) },
		{ Y = const(int_const(C)) },
		{ C < 0 }
	->
		{ NewOp = (-) },
		{ NewC is 0 - C },
		{ NewY = const(int_const(NewC)) },
		io__write_string("("),
		mlds_output_rval(X),
		io__write_string(" "),
		mlds_output_binary_op(NewOp),
		io__write_string(" "),
		mlds_output_rval(NewY),
		io__write_string(")")
	;
******/
		io__write_string("("),
		mlds_output_rval(X),
		io__write_string(" "),
		mlds_output_binary_op(Op),
		io__write_string(" "),
		mlds_output_rval(Y),
		io__write_string(")")
	).

:- pred mlds_output_binary_op(binary_op, io__state, io__state).
:- mode mlds_output_binary_op(in, di, uo) is det.

mlds_output_binary_op(Op) -->
	( { c_util__binary_infix_op(Op, OpStr) } ->
		io__write_string(OpStr)
	;
		{ error("mlds_output_binary_op: invalid binary operator") }
	).

:- pred build_rval_const(mlds__rval_const, gcc__expr,
		io__state, io__state).
:- mode build_rval_const(in, out, di, uo) is det.

build_rval_const(true, Expr) -->
	% XXX currently we don't use a separate boolean type
	gcc__build_int(1, Expr).
build_rval_const(false, Expr) -->
	% XXX currently we don't use a separate boolean type
	gcc__build_int(0, Expr).
build_rval_const(int_const(N), Expr) -->
	gcc__build_int(N, Expr).
build_rval_const(float_const(FloatVal), _Expr) -->
	% XXX NYI
	io__write_float(FloatVal),
	{ sorry(42) }.
build_rval_const(string_const(String), Expr) -->
	gcc__build_string(String, Expr).
build_rval_const(multi_string_const(Length, String), Expr) -->
	gcc__build_string(Length, String, Expr).
build_rval_const(code_addr_const(CodeAddr), Expr) -->
	build_code_addr(CodeAddr, Expr).
build_rval_const(data_addr_const(DataAddr), Expr) -->
	build_data_addr(DataAddr, Expr).
build_rval_const(null(_Type), Expr) -->
	% XXX is it OK to ignore the type here?
	gcc__build_null_pointer(Expr).

:- pred mlds_output_rval_const(mlds__rval_const, io__state, io__state).
:- mode mlds_output_rval_const(in, di, uo) is det.

mlds_output_rval_const(true) -->
	io__write_string("TRUE").	% XXX should we use `MR_TRUE'?
mlds_output_rval_const(false) -->
	io__write_string("FALSE").	% XXX should we use `MR_FALSE'?
mlds_output_rval_const(int_const(N)) -->
	% we need to cast to (MR_Integer) to ensure
	% things like 1 << 32 work when `Integer' is 64 bits
	% but `int' is 32 bits.
	io__write_string("(MR_Integer) "),
	io__write_int(N).
mlds_output_rval_const(float_const(FloatVal)) -->
	% the cast to (MR_Float) here lets the C compiler
	% do arithmetic in `float' rather than `double'
	% if `MR_Float' is `float' not `double'.
	io__write_string("(MR_Float) "),
	io__write_float(FloatVal).
mlds_output_rval_const(string_const(String)) -->
	% the cast avoids the following gcc warning
	% "assignment discards qualifiers from pointer target type"
	io__write_string("(MR_String) "),
	io__write_string(""""),
	c_util__output_quoted_string(String),
	io__write_string("""").
mlds_output_rval_const(multi_string_const(Length, String)) -->
	io__write_string(""""),
	c_util__output_quoted_multi_string(Length, String),
	io__write_string("""").
mlds_output_rval_const(code_addr_const(CodeAddr)) -->
	mlds_output_code_addr(CodeAddr).
mlds_output_rval_const(data_addr_const(DataAddr)) -->
	mlds_output_data_addr(DataAddr).
mlds_output_rval_const(null(_)) -->
       io__write_string("NULL").

%-----------------------------------------------------------------------------%

:- pred mlds_output_tag(mlds__tag, io__state, io__state).
:- mode mlds_output_tag(in, di, uo) is det.

mlds_output_tag(Tag) -->
	io__write_string("MR_mktag("),
	io__write_int(Tag),
	io__write_string(")").

%-----------------------------------------------------------------------------%

:- pred build_code_addr(mlds__code_addr, gcc__expr, io__state, io__state).
:- mode build_code_addr(in, out, di, uo) is det.

build_code_addr(CodeAddr, Expr) -->
	(
		{ CodeAddr = proc(Label, Signature) },
		{ MaybeSeqNum = no }
	;
		{ CodeAddr = internal(Label, SeqNum, Signature) },
		{ MaybeSeqNum = yes(SeqNum) }
	),
	% convert the label into a entity_name, 
	% so we can use make_func_decl below
	{ Label = qual(ModuleName, PredLabel - ProcId) },
	{ invalid_pred_id(InvalidPredId) },
	{ Name = qual(ModuleName, function(PredLabel, ProcId,
		MaybeSeqNum, InvalidPredId)) },
	% build a function declaration for the function,
	% and take its address.
	make_func_decl(Name, Signature, FuncDecl),
	gcc__build_func_addr_expr(FuncDecl, Expr).

:- pred mlds_output_code_addr(mlds__code_addr, io__state, io__state).
:- mode mlds_output_code_addr(in, di, uo) is det.

mlds_output_code_addr(proc(Label, _Sig)) -->
	mlds_output_fully_qualified_proc_label(Label).
mlds_output_code_addr(internal(Label, SeqNum, _Sig)) -->
	mlds_output_fully_qualified_proc_label(Label),
	io__write_string("_"),
	io__write_int(SeqNum).

:- pred mlds_output_proc_label(mlds__proc_label, io__state, io__state).
:- mode mlds_output_proc_label(in, di, uo) is det.

mlds_output_proc_label(PredLabel - ProcId) -->
	mlds_output_pred_label(PredLabel),
	{ proc_id_to_int(ProcId, ModeNum) },
	io__format("_%d", [i(ModeNum)]).

:- pred build_data_addr(mlds__data_addr, gcc__expr, io__state, io__state).
:- mode build_data_addr(in, out, di, uo) is det.

build_data_addr(DataAddr, Expr) -->
	build_data_decl(DataAddr, Decl),
	gcc__build_addr_expr(gcc__var_expr(Decl), Expr).

:- pred build_data_decl(mlds__data_addr, gcc__var_decl, io__state, io__state).
:- mode build_data_decl(in, out, di, uo) is det.

build_data_decl(data_addr(ModuleName, DataName), Decl) -->
	% XXX Bug! Type won't always be 'MR_Word'
	% XXX Bug! Shouldn't always be extern
	{ VarName = build_data_var_name(ModuleName, DataName) },
	{ Type = 'MR_Word' },
	gcc__build_extern_var_decl(VarName, Type, Decl).

:- pred mlds_output_data_addr(mlds__data_addr, io__state, io__state).
:- mode mlds_output_data_addr(in, di, uo) is det.

mlds_output_data_addr(data_addr(ModuleName, DataName)) -->
	(
		% if its an array type, then we just use the name,
		% otherwise we must prefix the name with `&'.
		{ DataName = rtti(_, RttiName) },
		{ rtti_name_has_array_type(RttiName) = yes }
	->
		mlds_output_data_var_name(ModuleName, DataName)
	;
		io__write_string("(&"),
		mlds_output_data_var_name(ModuleName, DataName),
		io__write_string(")")
	).

:- func build_data_var_name(mlds_module_name, mlds__data_name) = string.

build_data_var_name(ModuleName, DataName) =
		ModuleQualifier ++ build_data_name(DataName) :-
	(
		%
		% don't module-qualify base_typeclass_infos
		%
		% We don't want to include the module name as part
		% of the name if it is a base_typeclass_info, since
		% we _want_ to cause a link error for overlapping
		% instance decls, even if they are in a different
		% module
		%
		DataName = base_typeclass_info(_, _)
	->
		ModuleQualifier = ""
	;
		ModuleNameString = get_module_name(
			mlds_module_name_to_sym_name(ModuleName)),
		ModuleQualifier = string__append(ModuleNameString, "__")
	).

:- pred mlds_output_data_var_name(mlds_module_name, mlds__data_name,
		io__state, io__state).
:- mode mlds_output_data_var_name(in, in, di, uo) is det.

mlds_output_data_var_name(ModuleName, DataName) -->
	(
		%
		% don't module-qualify base_typeclass_infos
		%
		% We don't want to include the module name as part
		% of the name if it is a base_typeclass_info, since
		% we _want_ to cause a link error for overlapping
		% instance decls, even if they are in a different
		% module
		%
		{ DataName = base_typeclass_info(_, _) }
	->
		[]
	;
		mlds_output_module_name(
			mlds_module_name_to_sym_name(ModuleName)),
		io__write_string("__")
	),
	mlds_output_data_name(DataName).

%-----------------------------------------------------------------------------%

:- pred mlds_output_init_fn_defns(mlds_module_name::in,
		io__state::di, io__state::uo) is det.

mlds_output_init_fn_defns(MLDS_ModuleName) -->
	%
	% Generate an empty function of the form
	%
	%	void <foo>_init_type_tables() {}
	%
	{ FuncName = init_fn_name(MLDS_ModuleName, "_type_tables") },
	{ GCC_ParamTypes = gcc__empty_param_types },
	{ GCC_ParamDecls = gcc__empty_param_decls },
	{ GCC_RetType = gcc__void_type_node },
	gcc__build_function_decl(FuncName, FuncName,
		GCC_RetType, GCC_ParamTypes, GCC_ParamDecls, GCC_FuncDecl),
	{ Name = export(FuncName) },
	{ Signature = mlds__func_params([], []) },
	{ map__init(SymbolTable) },
	{ map__init(LabelTable) },
	{ FuncInfo = func_info(qual(MLDS_ModuleName, Name),
		Signature, SymbolTable, LabelTable) },
	{ term__context_init(Context) },
	{ FuncBody = mlds__statement(block([], []), mlds__make_context(Context)) },
	gcc__start_function(GCC_FuncDecl),
	gen_statement(FuncInfo, FuncBody),
	gcc__end_function.

:- func init_fn_name(mlds_module_name, string) = string.

init_fn_name(ModuleName, Suffix) = InitFnName :-
		% Here we ensure that we only get one "mercury__" at the
		% start of the function name.
	prog_out__sym_name_to_string(
			mlds_module_name_to_sym_name(ModuleName), "__", 
			ModuleNameString0),
	(
		string__prefix(ModuleNameString0, "mercury__")
	->
		ModuleNameString = ModuleNameString0
	;
		string__append("mercury__", ModuleNameString0,
				ModuleNameString)
	),
	string__append_list([ModuleNameString, "__init", Suffix], InitFnName).

%-----------------------------------------------------------------------------%
%
% Miscellaneous stuff to handle indentation and generation of
% source context annotations (#line directives).
%

:- pred mlds_output_context(mlds__context, io__state, io__state).
:- mode mlds_output_context(in, di, uo) is det.

mlds_output_context(Context) -->
	{ ProgContext = mlds__get_prog_context(Context) },
	{ term__context_file(ProgContext, FileName) },
	{ term__context_line(ProgContext, LineNumber) },
	c_util__set_line_num(FileName, LineNumber).

%-----------------------------------------------------------------------------%

:- pred defn_is_public(mlds__defn).
:- mode defn_is_public(in) is semidet.

defn_is_public(Defn) :-
	Defn = mlds__defn(_Name, _Context, Flags, _Body),
	access(Flags) \= private.

:- pred defn_is_type(mlds__defn).
:- mode defn_is_type(in) is semidet.

defn_is_type(Defn) :-
	Defn = mlds__defn(Name, _Context, _Flags, _Body),
	Name = type(_, _).

:- pred defn_is_function(mlds__defn).
:- mode defn_is_function(in) is semidet.

defn_is_function(Defn) :-
	Defn = mlds__defn(Name, _Context, _Flags, _Body),
	Name = function(_, _, _, _).

:- pred defn_is_type_ctor_info(mlds__defn).
:- mode defn_is_type_ctor_info(in) is semidet.

defn_is_type_ctor_info(Defn) :-
	Defn = mlds__defn(_Name, _Context, _Flags, Body),
	Body = mlds__data(Type, _),
	Type = mlds__rtti_type(RttiName),
	RttiName = type_ctor_info.

:- pred defn_is_commit_type_var(mlds__defn).
:- mode defn_is_commit_type_var(in) is semidet.

defn_is_commit_type_var(Defn) :-
	Defn = mlds__defn(_Name, _Context, _Flags, Body),
	Body = mlds__data(Type, _),
	Type = mlds__commit_type.

%-----------------------------------------------------------------------------%

:- pred mlds_indent(mlds__context, indent, io__state, io__state).
:- mode mlds_indent(in, in, di, uo) is det.

mlds_indent(Context, N) -->
	mlds_output_context(Context),
	mlds_indent(N).

% A value of type `indent' records the number of levels
% of indentation to indent the next piece of code.
% Currently we output two spaces for each level of indentation.
:- type indent == int.

:- pred mlds_indent(indent, io__state, io__state).
:- mode mlds_indent(in, di, uo) is det.

mlds_indent(N) -->
	( { N =< 0 } ->
		[]
	;
		io__write_string("  "),
		mlds_indent(N - 1)
	).

%-----------------------------------------------------------------------------%

:- pred set_context(mlds__context::in, io__state::di, io__state::uo) is det.
set_context(MLDS_Context) -->
	{ ProgContext = mlds__get_prog_context(MLDS_Context) },
	{ FileName = term__context_file(ProgContext) },
	{ LineNumber = term__context_line(ProgContext) },
	gcc__set_context(FileName, LineNumber).

:- pred gen_context(mlds__context, io__state, io__state).
:- mode gen_context(in, di, uo) is det.

gen_context(MLDS_Context) -->
	{ ProgContext = mlds__get_prog_context(MLDS_Context) },
	{ FileName = term__context_file(ProgContext) },
	{ LineNumber = term__context_line(ProgContext) },
	gcc__gen_line_note(FileName, LineNumber).

%-----------------------------------------------------------------------------%
%
% We use the same names for types as in the MLDS -> C back-end.
%

:- func 'MR_Box'	= gcc__type.
:- func 'MR_Integer'	= gcc__type.
:- func 'MR_Float'	= gcc__type.
:- func 'MR_Char'	= gcc__type.
:- func 'MR_String'	= gcc__type.
:- func 'MR_Word'	= gcc__type.

'MR_Box'	= gcc__ptr_type_node.
'MR_Integer'	= gcc__integer_type_node.
'MR_Float'	= gcc__double_type_node.
'MR_Char'	= gcc__char_type_node.
'MR_String'	= gcc__string_type_node.
'MR_Word'	= gcc__integer_type_node.
	% XXX 'MR_Word' should perhaps be unsigned, to match the C back-end

%-----------------------------------------------------------------------------%

:- pred sorry(int::in) is erroneous.
sorry(Num) :- error(format("%s: sorry, not yet implemented (%d)",
		[s(this_file), i(Num)])).

:- func this_file = string.
this_file = "mlds_to_gcc.m".

:- end_module mlds_to_gcc.

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

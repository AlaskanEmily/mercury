%-----------------------------------------------------------------------------%
% Copyright (C) 2003 University of Melbourne.
% This file may only be copied under the terms of the GNU Library General
% Public License - see the file COPYING.LIB in the Mercury distribution.
%-----------------------------------------------------------------------------%
% File: aditi_private_builtin.m
% Author: stayl
%
% Internals of the Mercury->Aditi interface.
%
% This module is automatically imported when `--aditi' is passed to
% the compiler.
%
% Calls to some of these predicates are generated by the compiler,
% and some are called from aditi.m.
%
% None of these predicates should appear in user programs.
%
%-----------------------------------------------------------------------------%
:- module aditi_private_builtin.

:- interface.

:- import_module io.
:- import_module aditi.

:- pred connect(string, string, string, int, aditi__connection,
		io__state, io__state).
:- mode connect(in, in, in, out, out, di, uo) is det.

:- pred disconnect(aditi__connection, int, io__state, io__state).
:- mode disconnect(in, out, di, uo) is det.

:- pred start_transaction(aditi__connection, aditi__result(aditi__state),
		io__state, io__state).
:- mode start_transaction(in, out, di, uo) is det.

:- pred commit_transaction(aditi__state, io__state, io__state).
:- mode commit_transaction(in, di, uo) is det.

:- pred abort_transaction(aditi__state, io__state, io__state).
:- mode abort_transaction(in, di, uo) is det.

:- type relation_ticket == c_pointer.

	% do_call_returning_relation(ProcName, InputSchema, InputTuple,
	%		OutputRel).
	%
	% Call an Aditi procedure, returning a reference to the output
	% relation. InputTuple is a tuple containing the
	% input arguments. InputSchema is an Aditi schema string
	% describing the tuple of input arguments.
:- impure pred do_call_returning_relation(string, string,
			T, relation_ticket).
:- mode do_call_returning_relation(in, in, in, out) is det.

	% Find the single solution for a deterministic database call.
	% Abort the transaction if the call does not succeed at
	% least once.
	% InputTuple and OutputTuple must have type '{}/N' (the arity
	% depends on the relation being called).
:- impure pred do_det_call(string, string, InputTuple, OutputTuple).
:- mode do_det_call(in, in, in, out) is det.

:- impure pred do_semidet_call(string, string, InputTuple, OutputTuple).
:- mode do_semidet_call(in, in, in, out) is semidet.

:- impure pred do_nondet_call(string, string, InputTuple, OutputTuple).
:- mode do_nondet_call(in, in, in, out) is nondet.

:- impure pred do_multi_call(string, string, InputTuple, OutputTuple).
:- mode do_multi_call(in, in, in, out) is multi.

	% XXX I'm not sure whether it makes sense to have
	% committed choice Aditi predicates.
:- impure pred do_cc_nondet_call(string, string, InputTuple, OutputTuple).
:- mode do_cc_nondet_call(in, in, in, out) is cc_nondet.

:- impure pred do_cc_multi_call(string, string, InputTuple, OutputTuple).
:- mode do_cc_multi_call(in, in, in, out) is cc_multi.

:- impure pred do_erroneous_call(string, string, InputTuple, OutputTuple).
:- mode do_erroneous_call(in, in, in, out) is erroneous.

:- impure pred do_failure_call(string, string, InputTuple, OutputTuple).
:- mode do_failure_call(in, in, in, out) is failure.

	% do_insert_tuple(BaseRelationName, Tuple).
	%
	% TypeInfos is an array containing the type-infos for
	% the tuple to insert. TupleArgs contains the attribute
	% values of the tuple to insert.
:- pred do_insert_tuple(string, InputTuple, aditi__state, aditi__state).
:- mode do_insert_tuple(in, in, aditi_di, aditi_uo) is det.

	% do_delete_tuple(BaseRelationName, DeleteProcName,
	%	DeleteProcInputSchema, Tuple).
:- pred do_delete_tuple(string, string, string, Tuple,
		aditi__state, aditi__state).
:- mode do_delete_tuple(in, in, in, in, aditi_di, aditi_uo) is det.

:- type update_closure == pred(relation_ticket).
:- inst update_closure == (pred(out) is det).

	% do_bulk_insert(BaseRelationName, UpdateProcName, Closure).
:- pred do_bulk_insert(string, string, update_closure,
		aditi__state, aditi__state).
:- mode do_bulk_insert(in, in, in(update_closure), aditi_di, aditi_uo) is det.

	% do_bulk_delete(BaseRelationName, UpdateProcName, Closure).
:- pred do_bulk_delete(string, string, update_closure,
		aditi__state, aditi__state).
:- mode do_bulk_delete(in, in, in(update_closure), aditi_di, aditi_uo) is det.

	% do_bulk_modify(BaseRelationName, UpdateProcName, Closure).
:- pred do_bulk_modify(string, string, update_closure,
		aditi__state, aditi__state).
:- mode do_bulk_modify(in, in, in(update_closure), aditi_di, aditi_uo) is det.

	% Try to classify an error code returned by Aditi.
:- pred error_code(int, aditi__error, string).
:- mode error_code(in, out, out) is det.

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%
:- implementation.

:- import_module bool, char, exception, int, list, require, std_util, string.

:- type cursor == c_pointer.

:- pragma c_header_code("

#include ""mercury_wrapper.h""
#include ""mercury_string.h""

/* aditi_api_config.h must be included before aditi_clnt.h */
#include ""aditi_api_config.h""
#include ""aditi_clnt.h""

	/*
	** MADITI_check can only be used within functions which return
	** an Aditi error code.
	*/
#define MADITI_check(status)						\\
    do {	int MADITI_line_xxx = __LINE__;				\\
		int MADITI_check_status_xxx;				\\
		MADITI_check_status_xxx = status;			\\
		MADITI_do_debug_status(MADITI_check_status_xxx,		\\
			MADITI_line_xxx);				\\
		if (MADITI_check_status_xxx != ADITI_OK) {		\\
			MADITI_status = MADITI_check_status_xxx;	\\
    			return MADITI_check_status_xxx;			\\
		}							\\
    } while(0)

#define MADITI_debug_status(status)					\\
    do {	int MADITI_line_xxx_2 = __LINE__;			\\
		int MADITI_check_status_xxx_2;				\\
		MADITI_check_status_xxx_2 = status;			\\
	    	MADITI_do_debug_status(MADITI_check_status_xxx_2,	\\
			MADITI_line_xxx_2);				\\
    } while(0)

#define MADITI_do_debug_status(status, line)				\\
    do {	int MADITI_do_debug_status_xxx;				\\
		MADITI_do_debug_status_xxx = status;			\\
		if (MADITI_do_debug_status_xxx != ADITI_OK) {		\\
			MR_DEBUG(fprintf(stderr, ""\\naditi_private_builtin.m:%d: API call failed, returned %d\\n"", \\
			line, MADITI_do_debug_status_xxx));		\\
	}								\\
    } while(0)

/*
** Maximum time allowed for a query (in seconds)
*/
#define MADITI_QUERY_TIMEOUT 600

typedef enum { MADITI_INSERT_TUPLE, MADITI_DELETE_TUPLE } MADITI_insert_delete;
typedef enum { MADITI_INSERT, MADITI_DELETE, MADITI_MODIFY } MADITI_bulk_op;

/*
** Information used to clean up a call result if there is a commit
** or an exception across a database call.
*/
typedef struct {
	ticket *output_rel;
	ticket *output_cursor;
	bool cleaned_up;
} MADITI_output_info;

static ticket MADITI_ticket;		/* Current connection ticket. */
static int MADITI_status;		/* Return code of the last
					** Aditi API call.
					*/

static int  MADITI_run_procedure(MR_String proc_name,
		MR_String input_schema, String input_tuple, ticket **result);
static int MADITI_create_cursor(ticket *output_ticket,
		MADITI_output_info **result);
static int MADITI_do_insert_delete_tuple(MADITI_insert_delete operation,
		MR_String relation_name, MR_String update_proc,
		MR_String update_schema, MR_String tuple);
static int MADITI_do_bulk_operation(MADITI_bulk_op operation,
		MR_String relation_name, MR_String update_proc,
		ticket *closure_result);
static int MADITI_cleanup_call_output(MADITI_output_info *);

#ifdef MR_USE_TRAIL
static void MADITI_trail_cleanup_call_output(void *cleanup_data,
		MR_untrail_reason reason);
#endif

static int MADITI_list_rel(ticket* rel);
").

:- pragma c_code("

	/*
	** No effort is made to ensure that MR_hp is valid where
	** memory is allocated. Given that it is likely that a better
	** way of allocating memory from C code is will be implemented
	** when the accurate garbage collector is finished, I don't
	** see much point in cluttering the code here with
	** save_transient_registers()/restore_transient_registers() calls.
	*/
#ifndef CONSERVATIVE_GC
#error ""The Aditi interface requires conservative garbage collection. \\
                Use a compilation grade containing .gc.""
#endif
").

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

	%
	% Code to handle connections.
	%
:- pragma c_code(
	connect(Host::in, User::in, Passwd::in,
		Stat::out, Connection::out, IO0::di, IO::uo),
		will_not_call_mercury,
"
{
	/* connect */
	if ((Stat = init_aditi_clnt()) == ADITI_OK
		&& (Stat = ADITI_NAME(recon)(Host)) == ADITI_OK) {

		MR_DEBUG(fprintf(stderr, ""connected\\n""));

		/*
		** Login and upload all the RL code for the program to 
		** the database.
		*/
		if ((Stat = ADITI_NAME(login)(User, Passwd)) == ADITI_OK) {

			MR_DEBUG(ADITI_NAME(set_debug)());

			MR_DEBUG(fprintf(stderr, ""logged in\\n""));
			if ((Stat = MR_load_aditi_rl_code())
					== ADITI_OK) {
				MR_DEBUG(fprintf(stderr, ""code loaded\\n""));
			} else {
				ADITI_NAME(discon)(FORCE_LOGOUT);
			}
		} else {
			ADITI_NAME(discon)(FORCE_LOGOUT);
		}
	}
	MADITI_debug_status(Stat);
	Connection = 1;
	IO = IO0;
}
").

:- pragma c_code(
		disconnect(_Connection::in, Stat::out, IO0::di, IO::uo),
		will_not_call_mercury,
"
{
	Stat = ADITI_NAME(discon)(FORCE_LOGOUT);
	MADITI_debug_status(Stat);
	if (Stat == ADITI_OK) {
		Stat = fin_aditi_clnt();
		MADITI_debug_status(Stat);
	}
	IO = IO0;
}
").

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

	%
	% This section handles starting, committing and aborting transactions.
	%

start_transaction(_, Result) -->
	start_transaction_2(Status, State),
	{ Status = 0 ->
		Result = ok(State)
	;
		error_code(Status, Error, String),
		Result = error(Error, String)
	}.

:- pred start_transaction_2(int, aditi__state, io__state, io__state).
:- mode start_transaction_2(out, out, di, uo) is det.

:- pragma c_code(start_transaction_2(Stat::out, DB::out, IO0::di, IO::uo),
		will_not_call_mercury,
"{
	IO = IO0;
	MR_DEBUG(fprintf(stderr, ""starting transaction...""));
	Stat = ADITI_NAME(trans_begin)(&MADITI_ticket);
	MADITI_debug_status(Stat);
	MADITI_status = Stat;
	MR_DEBUG(fprintf(stderr, ""done\\n""));
	DB = (MR_Word) 0;

}").

:- pragma c_code(abort_transaction(DB::in, IO0::di, IO::uo),
		will_not_call_mercury,
"{
	/*
	** Ignore the return code -- we're more interested
	** in the error which caused the abort.
	*/
	ADITI_NAME(trans_abort)(&MADITI_ticket);
	DB = 0;
	IO = IO0;
}").

:- pragma promise_pure(commit_transaction/3).
commit_transaction(DB) -->
	{ semipure check_for_old_error },
	commit_transaction_2(DB, Status),
	{ semipure maybe_throw_aditi_exception(Status) }.

:- pred commit_transaction_2(aditi__state, int, io__state, io__state).
:- mode commit_transaction_2(in, out, di, uo) is det.

:- pragma c_code(commit_transaction_2(DB::in, Stat::out, IO0::di, IO::uo),
		will_not_call_mercury,
"{
	Stat = ADITI_NAME(trans_commit)(&MADITI_ticket);
	MADITI_debug_status(Stat);
	DB = 0;
	IO = IO0;
}").

	% Throw an exception to abort the transaction if the status
	% is not ADITI_OK.
	% This needs to be impure to stop it being reordered with
	% other calls.
:- semipure pred maybe_throw_aditi_exception(int).
:- mode maybe_throw_aditi_exception(in) is det.

maybe_throw_aditi_exception(Status) :-
	( Status = 0 ->
		true
	;
		error_code(Status, Error, String),
		throw(aditi__exception(Error, String))
	).	

:- pred maybe_throw_aditi_exception(int, aditi__state, aditi__state).
:- mode maybe_throw_aditi_exception(in, aditi_di, aditi_uo) is det.
:- pragma promise_pure(maybe_throw_aditi_exception/3).

maybe_throw_aditi_exception(Status) -->
	{ semipure maybe_throw_aditi_exception(Status) }.

	% If a call result is cleaned up by untrailing, any errors
	% will not result in the transaction being aborted immediately
	% because there is no way to throw an exception from a trail
	% function. Instead, a global variable is set to indicate that
	% an error has occurred, and the next database call will
	% check for the error and abort the transaction.
	% This needs to be semipure to stop it being reordered with
	% other calls.
:- semipure pred check_for_old_error is det.

check_for_old_error :-
	semipure get_aditi_status(Status),
	semipure maybe_throw_aditi_exception(Status).

:- pred check_for_old_error(aditi__state, aditi__state).
:- mode check_for_old_error(aditi_di, aditi_uo) is det.
:- pragma promise_pure(check_for_old_error/2).

check_for_old_error -->
	{ semipure check_for_old_error }.

:- semipure pred get_aditi_status(int).
:- mode get_aditi_status(out) is det.

:- pragma c_code(get_aditi_status(Stat::out), will_not_call_mercury,
		"Stat = MADITI_status;").

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

	%
	% This section handles calls to Aditi predicates and functions.
	%

do_det_call(ProcName, InputSchema, InputTuple, OutputTuple) :-
	impure do_call_returning_relation(ProcName, 
		InputSchema, InputTuple, OutputRel),
	impure create_cursor(OutputRel, CursorStatus, Cursor0),
	semipure maybe_throw_aditi_exception(CursorStatus),
	( get_next_tuple(OutputTuple0, Cursor0, Cursor) ->
		OutputTuple = OutputTuple0,
		impure destroy_cursor(Cursor, DestroyStatus),
		semipure maybe_throw_aditi_exception(DestroyStatus)
	;
		impure destroy_cursor(Cursor0, DestroyStatus),
		semipure maybe_throw_aditi_exception(DestroyStatus),
		determinism_error("no solution", "det", ProcName)
	).

do_semidet_call(ProcName, InputSchema, InputTuple, OutputTuple) :-
	impure do_call_returning_relation(ProcName,
		InputSchema, InputTuple, OutputRel),
	impure create_cursor(OutputRel, CursorStatus, Cursor0),
	semipure maybe_throw_aditi_exception(CursorStatus),
	( get_next_tuple(OutputTuple0, Cursor0, Cursor) ->
		%
		% Assume that if a call succeeds multiple times,
		% the other solutions are just duplicates.
		%
		OutputTuple = OutputTuple0,
		impure destroy_cursor(Cursor, DestroyStatus),
		semipure maybe_throw_aditi_exception(DestroyStatus)
	;
		impure destroy_cursor(Cursor0, DestroyStatus),
		semipure maybe_throw_aditi_exception(DestroyStatus),
		fail
	).

do_nondet_call(ProcName, InputSchema, InputTuple, OutputTuple) :-
	impure do_call_returning_relation(ProcName, InputSchema,
		InputTuple, OutputRel),
	impure create_cursor(OutputRel, CursorStatus, Cursor),
	semipure maybe_throw_aditi_exception(CursorStatus),
	impure collect_nondet_output_tuples(Cursor, OutputTuple).

do_multi_call(ProcName, InputSchema, InputTuple, OutputTuple) :-
	(
		impure do_nondet_call(ProcName, InputSchema,
			InputTuple, OutputTuple0)
	->
		OutputTuple = OutputTuple0
	;
		determinism_error("no solution", "multi", ProcName)
	).

do_cc_nondet_call(ProcName, InputSchema, InputTuple, OutputTuple) :-
	impure do_nondet_call(ProcName, InputSchema, InputTuple, OutputTuple).

do_cc_multi_call(ProcName, InputSchema, InputTuple, OutputTuple) :-
	impure do_multi_call(ProcName, InputSchema, InputTuple, OutputTuple).

do_erroneous_call(ProcName, InputSchema, InputTuple, OutputTuple) :-
	impure do_det_call(ProcName, InputSchema, InputTuple, OutputTuple),
	determinism_error("solution", "erroneous", ProcName).

do_failure_call(ProcName, InputSchema, InputTuple, OutputTuple) :-
	(
		impure do_semidet_call(ProcName, InputSchema,
			InputTuple, OutputTuple0)
	->
		OutputTuple = OutputTuple0,
		determinism_error("solution", "failure", ProcName)
	;
		fail
	).

:- pred determinism_error(string, string, string).
:- mode determinism_error(in, in, in) is erroneous.

determinism_error(Solution, Det, ProcName) :-	
	string__format(
		"Error in Aditi call: %s for procedure with determinism %s\n",
		[s(Solution), s(Det), s(ProcName)], Msg),
	throw(aditi__exception(determinism_error, Msg)).

:- impure pred collect_nondet_output_tuples(cursor, T).
:- mode collect_nondet_output_tuples(in, out) is nondet.

collect_nondet_output_tuples(Cursor0, OutputTuple) :-
	semipure check_for_old_error,
	(
		get_next_tuple(OutputTuple0, Cursor0, Cursor)
	->
		(
			OutputTuple = OutputTuple0
		;
			impure collect_nondet_output_tuples(Cursor,
				OutputTuple)
		)
	;
		impure destroy_cursor(Cursor0, DestroyStatus),
		semipure maybe_throw_aditi_exception(DestroyStatus),
		fail
	).

do_call_returning_relation(ProcName, InputSchema, InputTuple, OutputRel) :-
	construct_input_tuple(InputTuple, InputTupleStr),
	impure do_call_returning_relation_2(ProcName, InputSchema,
		InputTupleStr, Status, OutputRel),
	semipure maybe_throw_aditi_exception(Status).

:- impure pred do_call_returning_relation_2(string, string,
		string, int, relation_ticket).
:- mode do_call_returning_relation_2(in, in, in, out, out) is det.

:- pragma c_code(do_call_returning_relation_2(ProcName::in, InputSchema::in,
		InputTuple::in, Stat::out, OutputRel::out),
		will_not_call_mercury,
"{
	ticket *output_rel;
	Stat = (MR_Word) MADITI_run_procedure(ProcName,
			InputSchema, InputTuple, &output_rel);
	OutputRel = (MR_Word) output_rel;
}").

	% Create a cursor, adding an entry to the trail if possible
	% to make sure that it is cleaned up.
:- impure pred create_cursor(relation_ticket, int, cursor).
:- mode create_cursor(in, out, out) is det.

:- pragma c_code(create_cursor(Relation::in, Stat::out, Cursor::out),
		will_not_call_mercury,
"{
	MADITI_output_info *output_info;
	Stat = MADITI_create_cursor((ticket *)Relation, &output_info);
	Cursor = (MR_Word) output_info;
}").

:- impure pred destroy_cursor(cursor, int).
:- mode destroy_cursor(in, out) is det.

:- pragma c_code(destroy_cursor(Cursor::in, Stat::out),
		will_not_call_mercury,
"
	Stat = MADITI_cleanup_call_output((MADITI_output_info *) Cursor);
").

:- pred get_next_tuple(T, cursor, cursor).
:- mode get_next_tuple(out, in, out) is semidet.

get_next_tuple(OutputTuple, Cursor0, Cursor) :-
	cursor_next(TupleStr, Cursor0, Cursor),
	ArgTypeDescs = type_args(type_of(OutputTuple)),
	Posn0 = posn(1, 0, 0),
	string__length(TupleStr, TupleLength),
	parse_output_tuple(ArgTypeDescs, TupleStr, TupleLength, Posn0,
		OutputArgUnivs),
	OutputTuple0 = univ_value(construct_tuple(OutputArgUnivs)),
	OutputTuple = cast(OutputTuple0).

	% The arguments of the output tuple were constructed using
	% the argument types passed in -- we don't need to check
	% that they match again.
:- func cast(T) = U.
:- pragma c_code(cast(T::in) = (U::out), will_not_call_mercury, "U = T;").

:- pred cursor_next(string, cursor, cursor).
:- mode cursor_next(out, in, out) is semidet.

:- pragma c_code(cursor_next(Tuple::out, Cursor0::in, Cursor::out),
		will_not_call_mercury,
"
{
	int rc;
	char *tuple_str;
	int tuple_str_len;
	MADITI_output_info *output_info;

	Cursor = Cursor0;
	output_info = (MADITI_output_info *) Cursor;
	rc = ADITI_NAME(cursor_next)(output_info->output_cursor,
		&tuple_str_len, &tuple_str);

	/*
	** XXX This check should be more specific, but there is no
	** Aditi return code for no more tuples. 
	*/
	if (rc == ADITI_OK) {
		MR_DEBUG(fprintf(stderr, ""received tuple: %s\\n"", tuple_str));
		MR_make_aligned_string_copy(Tuple, tuple_str);
		free(tuple_str);
		SUCCESS_INDICATOR = TRUE;
	} else {
		SUCCESS_INDICATOR = FALSE;
	}
}
").

:- pred parse_output_tuple(list(type_desc), string, int,
		io__posn, list(univ)).
:- mode parse_output_tuple(in, in, in, in, out) is det.

parse_output_tuple([], _, _, _, []).
parse_output_tuple([TypeDesc | TypeDescs], Tuple, TupleLength, Posn0,
		[Arg | Args]) :-
	has_read_result_type(Result, TypeDesc),
	io__read_from_string_with_int_instead_of_char("Aditi result tuple",
		Tuple, TupleLength, Result, Posn0, Posn),
	(
		Result = ok(Field),
		Arg = univ(Field)
	;
		Result = eof,
		string__format("Aditi: unexpected end of tuple: %s",
			[s(Tuple)], ErrorMsg),
		throw(aditi__exception(parse_error_in_tuple, ErrorMsg))
	;
		Result = error(Msg, _),
		string__format("Aditi: invalid tuple returned: %s",
			[s(Msg)], ErrorMsg),
		throw(aditi__exception(parse_error_in_tuple, ErrorMsg))
	),
	parse_output_tuple(TypeDescs, Tuple, TupleLength, Posn, Args).

	% Use existential types to set up the type of the output argument
	% using the type-info passed for the output tuple. 
:- some [T] pred has_read_result_type(io__read_result(T), type_desc).
:- mode has_read_result_type(unused, in) is det.

has_read_result_type(Result, TypeDesc) :-
	has_type(Var, TypeDesc), 
	read_result_type(Var, Result).

:- pred read_result_type(T, io__read_result(T)).
:- mode read_result_type(unused, unused) is det.

read_result_type(_, _).

:- pragma c_code("

/* 
** Given an RL procedure name, the schema of the input relation and a tuple
** to insert into the input relation, run the procedure, returning a ticket
** for the output relation.
*/
static int
MADITI_run_procedure(MR_String proc_name, MR_String input_schema,
	MR_String input_tuple, ticket **output_ticket_ptr)
{

	ticket input_ticket;	/* Ticket identifying the input relation. */
	ticket *output_ticket;	/* Ticket identifying the input relation. */
	

	/*
	** Create a temporary relation to hold the input tuple.
	*/
	MR_DEBUG(fprintf(stderr, ""creating input temporary (schema %s)..."",
		input_schema));
	MADITI_check(ADITI_NAME(tmp_create)(&MADITI_ticket,
		input_schema, &input_ticket));
	MR_DEBUG(fprintf(stderr, ""done\\n""));

	/*
	** Insert the input tuple into the relation.
	*/
	MR_DEBUG(fprintf(stderr, ""adding input tuple...%s"", input_tuple));
	MADITI_check(ADITI_NAME(tmp_addtup)(&input_ticket, input_tuple));
	MR_DEBUG(fprintf(stderr, ""done\\n""));

	/*
	** Run the procedure.
	*/
	MR_DEBUG(fprintf(stderr, ""running procedure... ""));
	output_ticket = (ticket *) MR_GC_NEW(ticket);
	MADITI_check(ADITI_NAME(run2_s)(proc_name, MADITI_QUERY_TIMEOUT,
		&MADITI_ticket, &input_ticket, output_ticket));
	MR_DEBUG(fprintf(stderr, ""done\\n""));

	/*
	** Drop the input relation.
	*/
	MR_DEBUG(fprintf(stderr, ""dropping input temporary...""));
	MADITI_check(ADITI_NAME(tmp_destroy)(&input_ticket));
	MR_DEBUG(fprintf(stderr, ""done\\n""));

	MR_DEBUG(fprintf(stderr, ""output tuples\n""));
	MR_DEBUG(MADITI_check(MADITI_list_rel(output_ticket)));
	MR_DEBUG(fprintf(stderr, ""\\n\\n""));
	
	*output_ticket_ptr = output_ticket;
	return ADITI_OK;
}

static int
MADITI_create_cursor(ticket *relation, MADITI_output_info **output_info_ptr)
{
	ticket *cursor;
	MADITI_output_info *output_info;

	/* create cursor on the output relation */
	MR_DEBUG(fprintf(stderr, ""opening output cursor...""));
	cursor = (ticket *) MR_GC_NEW(ticket);
	MADITI_check(ADITI_NAME(rel_cursor_create)(relation, cursor));
	MADITI_check(ADITI_NAME(cursor_open)(cursor, CUR_FORWARD));
	MR_DEBUG(fprintf(stderr, ""done\\n""));

	output_info = MR_GC_NEW(MADITI_output_info);
	output_info->output_rel = relation;
	output_info->output_cursor = cursor;
	output_info->cleaned_up = FALSE;
#ifdef MR_USE_TRAIL
	MR_trail_function(MADITI_trail_cleanup_call_output,
		(void *) output_info);
#endif
	*output_info_ptr = output_info;
	return ADITI_OK;
}

static int
MADITI_list_rel(ticket* rel)
{
	size_t len;
	char* ptr;
	ticket cur;

	MADITI_check(ADITI_NAME(tmp_cursor_create)(rel,&cur));
	MADITI_check(ADITI_NAME(cursor_open)(&cur,CUR_FORWARD));
	len = 0;
	ptr = NULL;
	fflush(stdout);
	while (ADITI_NAME(cursor_next)(&cur,&len,&ptr) == ADITI_OK) {
		fprintf(stderr, ""tuple: [%.*s]\n"",(int)len,ptr);
		free(ptr);
		len = 0;
		ptr = NULL;
	}
	MADITI_check(ADITI_NAME(cursor_close)(&cur));
	MADITI_check(ADITI_NAME(cursor_destroy)(&cur));
	return ADITI_OK;
}

/*---------------------------------------------------------------------------*/

/*
** Free all resources used by a database call.
*/

#ifdef MR_USE_TRAIL
static void
MADITI_trail_cleanup_call_output(void *data, MR_untrail_reason reason)
{
    switch (reason) {
	case MR_commit:
	case MR_exception:
	case MR_retry:
	    /*
	    ** Clean up the output relation. If the transaction
	    ** status is not ADITI_OK, the transaction is about
	    ** to be aborted, so it's best not to try to clean up.
	    ** The database will do any cleaning up that is required.
	    */
	    if (MADITI_status == ADITI_OK) {
		MR_DEBUG(fprintf(stderr, 
		    ""MADITI_trail_cleanup_call_output: cleaning up %d\\n"",
		    reason));
		/*
		** We shouldn't throw exceptions during an untrail operation,
		** so we just set the status so that the next Aditi operation
		** called will abort the transaction if there were any errors.
		*/
		MADITI_status = MADITI_cleanup_call_output(
			(MADITI_output_info *)data);
	    }
	    break;
	case MR_solve:
	case MR_undo:
	    /*
	    ** Undo on backtracking will be handled by
	    ** do_*_call, so that the  cleanup will happen
	    ** even if trailing is not being used.
	    */
	    break;

	case MR_gc:
	default:
	    MR_fatal_error(""MADITI_trail_cleanup_call_output"");
    }
}
#endif /* MR_USE_TRAIL */

static int 
MADITI_cleanup_call_output(MADITI_output_info *output_info)
{
	if (output_info->cleaned_up) {

		/*
		** This can happen if there is a commit followed
		** by an exception -- the commit will not reset
		** the trail.
		*/
		MR_DEBUG(fprintf(stderr, 
			""MADITI_cleanup_call_output: already cleaned up\n""
		));

	} else {

		MR_DEBUG(fprintf(stderr, 
			""MADITI_cleanup_call_output: cleaning up\n""
		));

		/* close cursor */
		MR_DEBUG(fprintf(stderr, ""closing cursor\\n""));
		MADITI_check(
			ADITI_NAME(cursor_close)(output_info->output_cursor)
		);

		/* destroy cursor */
		MR_DEBUG(fprintf(stderr, ""destroying cursor\\n""));
		MADITI_check(
			ADITI_NAME(cursor_destroy)(output_info->output_cursor)
		);
		MR_GC_free(output_info->output_cursor);

		/* close output temporary */
		MR_DEBUG(fprintf(stderr,
			""closing output temporary relation\\n""));
		MADITI_check(ADITI_NAME(rel_close)(output_info->output_rel));
		MR_GC_free(output_info->output_rel);

		/* Make sure we don't do this again. */
		output_info->cleaned_up = TRUE;
	}

	return ADITI_OK;
}
").

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

	%
	% This section handles updates.
	%

do_insert_tuple(RelationName, Args) -->
	% There are no compiler-generated procedures for inserting
	% a single tuple into a relation.
	{ UpdateProc = "" },
	{ UpdateSchema = "" },

	do_insert_delete_tuple(insert_tuple, RelationName,
		UpdateProc, UpdateSchema, Args).

do_delete_tuple(RelationName, DeleteProc, DeleteProcInputSchema, Args) -->
	do_insert_delete_tuple(delete_tuple, RelationName,
		DeleteProc, DeleteProcInputSchema, Args).

:- pred do_insert_delete_tuple(int, string, string, string,
		T, aditi__state, aditi__state).
:- mode do_insert_delete_tuple(in, in, in, in, in, aditi_di, aditi_uo) is det.

do_insert_delete_tuple(InsertDelete, RelationName,
		UpdateProc, UpdateSchema, Args) -->
	check_for_old_error,
	{ construct_input_tuple(Args, Tuple) },
	do_insert_delete_tuple_2(InsertDelete, RelationName,
		UpdateProc, UpdateSchema, Tuple, Status),
	maybe_throw_aditi_exception(Status).

:- pred do_insert_delete_tuple_2(int, string, string, string, string, int,
		aditi__state, aditi__state).
:- mode do_insert_delete_tuple_2(in, in, in, in, in, out,
		aditi_di, aditi_uo) is det.

:- pragma c_code(do_insert_delete_tuple_2(InsertDelete::in, RelationName::in,
		UpdateProc::in, UpdateSchema::in, Tuple::in, Stat::out,
		DB0::aditi_di, DB::aditi_uo), will_not_call_mercury,
"{
	Stat = MADITI_do_insert_delete_tuple(
			(MADITI_insert_delete) InsertDelete,
			RelationName, UpdateProc, UpdateSchema, Tuple);
	DB = DB0;
}").

:- func insert_tuple = int.
:- pragma c_code(insert_tuple = (InsertTuple::out),
		[will_not_call_mercury, thread_safe],
		"InsertTuple = MADITI_INSERT_TUPLE;").
:- func delete_tuple = int.
:- pragma c_code(delete_tuple = (DeleteTuple::out),
		[will_not_call_mercury, thread_safe],
		"DeleteTuple = MADITI_DELETE_TUPLE;").

do_bulk_insert(RelationName, InsertProcName, Closure) -->
	do_bulk_operation(bulk_insert, RelationName, InsertProcName, Closure).

do_bulk_delete(RelationName, DeleteProcName, Closure) -->
	do_bulk_operation(bulk_delete, RelationName, DeleteProcName, Closure).
	
do_bulk_modify(RelationName, ModifyProcName, Closure) -->
	do_bulk_operation(bulk_delete, RelationName, ModifyProcName, Closure).

:- pred do_bulk_operation(int, string, string, update_closure,
		aditi__state, aditi__state).
:- mode do_bulk_operation(in, in, in, in(update_closure),
		aditi_di, aditi_uo) is det.

do_bulk_operation(Op, RelationName, UpdateProc, Closure) -->
	check_for_old_error,
	{ Closure(ResultRelation) },
	do_bulk_operation_2(Op, RelationName, UpdateProc,
		ResultRelation, Status),
	maybe_throw_aditi_exception(Status).

:- pred do_bulk_operation_2(int, string, string, relation_ticket, int,
		aditi__state, aditi__state).
:- mode do_bulk_operation_2(in, in, in, in, out,
		aditi_di, aditi_uo) is det.

:- pragma c_code(do_bulk_operation_2(Op::in, RelationName::in, UpdateProc::in,
		ResultRelation::in, Stat::out, DB0::aditi_di, DB::aditi_uo),
		will_not_call_mercury,
"{
	Stat = MADITI_do_bulk_operation((MADITI_bulk_op) Op,
			RelationName, UpdateProc, (ticket *) ResultRelation);
	DB = DB0;
}").			

:- func bulk_insert = int.
:- pragma c_code(bulk_insert = (Insert::out),
		[will_not_call_mercury, thread_safe],
		"Insert = MADITI_INSERT;").

:- func bulk_delete = int.
:- pragma c_code(bulk_delete = (Delete::out),
		[will_not_call_mercury, thread_safe],
		"Delete = MADITI_DELETE;").

:- func bulk_modify = int.
:- pragma c_code(bulk_modify = (Modify::out),
		[will_not_call_mercury, thread_safe],
		"Modify = MADITI_MODIFY;").

%-----------------------------------------------------------------------------%

:- pragma c_code("

static int
MADITI_do_insert_delete_tuple(MADITI_insert_delete operation,
		MR_String relation_name, MR_String update_proc,
		MR_String update_schema, MR_String tuple)
{
	ticket *delete_output_rel;

	switch (operation) {
		case MADITI_INSERT_TUPLE:
			MR_DEBUG(fprintf(stderr, 
				""inserting tuple %s into relation %s\\n"",
				tuple, relation_name));
			MADITI_check(ADITI_NAME(addtup)(relation_name, tuple));
			MR_DEBUG(fprintf(stderr, ""finished insertion\\n""));
			break;

		case MADITI_DELETE_TUPLE:
			MR_DEBUG(fprintf(stderr, 
				""deleting tuple %s from relation %s\\n"",
				tuple , relation_name));
			MADITI_check(MADITI_run_procedure(update_proc,
					update_schema, tuple,
					&delete_output_rel));
			MADITI_check(
				ADITI_NAME(rel_close)(delete_output_rel));
			MR_DEBUG(fprintf(stderr, ""finished deletion\\n""));
			break;
	}
	return ADITI_OK;
}

static int
MADITI_do_bulk_operation(MADITI_bulk_op operation, MR_String relation_name,
		MR_String update_proc, ticket *closure_result)
{
	ticket dummy_output_ticket;

	MR_DEBUG(
	    switch (operation) {
		case MADITI_INSERT:
			fprintf(stderr,
				""aditi_bulk_insert(%s)\\n"", relation_name);	
			break;
		case MADITI_DELETE:
			fprintf(stderr,
				""aditi_bulk_delete(%s)\\n"", relation_name);
			break;
		case MADITI_MODIFY:
			fprintf(stderr,
				""aditi_bulk_delete(%s)\\n"", relation_name);	
			break;
	    }
	)

	/*
	** Call the procedure generated by the compiler to apply the update.
	*/
	MR_DEBUG(fprintf(stderr, ""Calling update procedure %s\\n"",
		update_proc));
	MADITI_check(ADITI_NAME(run2_s)(update_proc, MADITI_QUERY_TIMEOUT,
		&MADITI_ticket, closure_result, &dummy_output_ticket)
	);

	/*
	** Clean up.
	*/
	MADITI_check(ADITI_NAME(rel_close)(&dummy_output_ticket));
	MADITI_check(ADITI_NAME(rel_close)((ticket *)closure_result));
	MR_GC_free((ticket *)closure_result);

	return ADITI_OK;
}

").

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%
	%
	% Data conversion.
	%

:- pred construct_input_tuple(T, string).
:- mode construct_input_tuple(in, out) is det.

construct_input_tuple(Tuple, TupleStr) :-
	NumArgs = type_ctor_arity(type_ctor(type_of(Tuple))),
	construct_input_tuple_2(0, NumArgs, Tuple, ["("], RevStrings),

	% XXX deforest this to reduce memory usage.
	list__reverse([")\n" | RevStrings], Strings),
	string__append_list(Strings, TupleStr).

:- pred construct_input_tuple_2(int, int, T, list(string), list(string)).
:- mode construct_input_tuple_2(in, in, in, in, out) is det.

construct_input_tuple_2(Index, NumArgs, Tuple, Strings0, Strings) :-
	( Index < NumArgs ->
		univ_to_string(det_argument(Tuple, Index), String),
		( Index = 0 ->
			Strings1 = [String | Strings0]
		;
			Strings1 = [String, ", " | Strings0]
		),
		construct_input_tuple_2(Index + 1, NumArgs, Tuple,
			Strings1, Strings)
	;
		Strings = Strings0
	).

	% This is very similar to io__write except
	% a) it writes to a string
	% b) everything is written in prefix form.
	% c) arrays, c_pointers, type_infos and univs result in an abort.
:- pred univ_to_string(univ, string).
:- mode univ_to_string(in, out) is det.

univ_to_string(Univ, String) :-
	%
	% we need to special-case the builtin types:
	%	int, char, float, string
	%	type_info, univ, c_pointer, array
	%
	( univ_to_type(Univ, String1) ->
		string__append_list(["\"", String1, "\""], String)
	; univ_to_type(Univ, Char) ->
		char__to_int(Char, CharInt),
		string__int_to_string(CharInt, String)
	; univ_to_type(Univ, Int) ->
		string__int_to_string(Int, String)
	; univ_to_type(Univ, Float) ->
		string__float_to_string(Float, String)
	;
		ordinary_term_to_string(Univ, String)
	).

:- pred ordinary_term_to_string(univ, string).
:- mode ordinary_term_to_string(in, out) is det.

ordinary_term_to_string(Term, String) :-
	deconstruct(univ_value(Term), Functor, _Arity, Args),
	quote_atom(Functor, FunctorStr),
	term_args_to_strings(yes, Args, ["(" | FunctorStr],
		Strings0),
	list__reverse([")" | Strings0], Strings),
	string__append_list(Strings, String).

:- pred term_args_to_strings(bool, list(univ),
		list(string), list(string)).
:- mode term_args_to_strings(in, in, in, out) is det.

term_args_to_strings(_, [], Strings, Strings).
term_args_to_strings(IsFirst, [X | Xs], Strings0, Strings) :-
	univ_to_string(X, XStr),
	( IsFirst = yes ->
		Comma = ""
	;
		Comma = ", "
	),
	term_args_to_strings(no, Xs, [XStr, Comma | Strings0], Strings).

:- pred quote_atom(string::in, list(string)::out) is det.

quote_atom(String0, Quoted) :-
	( string__is_alnum_or_underscore(String0) ->
		Quoted = [String0]
	;
		Quoted = ["'", String0, "'"]
	).

%-----------------------------------------------------------------------------%
	%
	% Attempt to make sense of the Aditi return code.
	% XXX Aditi needs some way to return more descriptive
	% error messages.
	%

error_code(Status, Error, String) :-
	( error_code_2(Status, Error0) ->
		Error = Error0,
		error_message(Status, String)
	;
		Error = general_failure,
		string__format("invalid Aditi error code %i",
			[i(Status)], String)
	).

:- pred error_code_2(int::in, aditi__error::out) is semidet.
	
error_code_2(-1, invalid_passwd).
error_code_2(-2, invalid_passwd).
error_code_2(-3, general_failure).
error_code_2(-4, general_failure).
error_code_2(-5, too_many_connections).
error_code_2(-6, general_failure).
error_code_2(-7, general_failure).
error_code_2(-8, already_logged_in).
error_code_2(-9, not_logged_in).
error_code_2(-10, general_failure).
error_code_2(-11, general_failure).
error_code_2(-12, general_failure).
error_code_2(-13, general_failure).
error_code_2(-14, error_creating_client).
error_code_2(-15, general_failure).
error_code_2(-16, not_implemented).
error_code_2(-17, abort).
error_code_2(-18, general_failure).
error_code_2(-19, general_failure).
error_code_2(-20, general_failure).
error_code_2(-21, bad_value).
error_code_2(-22, not_connected).
error_code_2(-23, bad_rl_code).
error_code_2(-24, bad_rl_code).
error_code_2(-25, bad_rl_code).
error_code_2(-26, error_opening_relation).
error_code_2(-27, bad_rl_code).
error_code_2(-28, bad_rl_code).
error_code_2(-29, security_violation).
error_code_2(-30, bad_rl_code).
error_code_2(-31, bad_rl_code).
error_code_2(-32, bad_rl_code).
error_code_2(-33, unique_key_violation).
error_code_2(-34, relation_or_cursor_not_open).
error_code_2(-35, general_failure).
error_code_2(-36, bad_value).
error_code_2(-37, timeout).

:- pred error_message(int::in, string::out) is det.

:- pragma c_code(error_message(Stat::in, Msg::out),
		will_not_call_mercury,
"
	Msg = aditi_strerror((int) Stat);
").


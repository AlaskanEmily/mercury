*******************************************************************************

TODO LIST:
----------

For more information on any of these issues, contact mercury@cs.mu.oz.au.

mode analysis
-------------

- check that unique modes do not get used in a context that could require
  backtracking
	[being done by fjh]

- extend the mode system to allow known aliasing.
  This is needed to make partially instantiated modes and unique modes work.
	[will be done by fjh]

- detect incorrect usage of `bound(...)' insts.
  That is, make sure that all of the functors in a bound(...) inst
  are valid functors for the type.

- split construct/deconstruct unifications into their atomic
  "micro-unification" pieces when necessary.
  (When is it necessary?)

mercury_to_goedel.m
-------------------

- see comments at the start of that file

type system
-----------

- handle predicate overloading in the case where predicates
  with the same name and arity occur in different modules
	  [will be done by fjh]

module system
-------------

- check that the interface for a module is type-correct
  independently of any declarations or imports in the implementation
  section

- handle module qualifiers properly
	  [being done by dylan]

- imports should not be transitive
  (currently we get this right for predicates, constants, and functors,
  but wrong for types, insts, and modes).

C interface
-----------

- make C interface bidirectional: allow C programs to call Mercury programs
	  [is being done by dgj]

runtime system
--------------

- reimplement runtime/*.mod using the new C interface.

*******************************************************************************

WISH LIST
---------

typechecking
------------

- allow explicit type qualifications `X :: Type'

- allow type inference for non-exported predicates


mode analysis:
--------------

- handle polymorphic modes (some research issues?)

- handle abstract insts in the same way abstract types are handled
  (a research issue - is this possible at all?)

- implement `willbe(Inst)' insts
	  [will be done by conway and fjh]

- mode segments & high-level transformation of circularly moded programs.


higher-order preds:
-------------------

- implement single-use higher-order predicate modes.
  Single-use higher-order predicates are allowed to bind
 
- allow taking the address of a predicate with multiple modes
  (This would require mode inference.)


code generation:
----------------

- The generated code should include some more profiling hooks.
  In particular, we should add a version of the heap allocation
  macro which takes an extra string parameter identifying which
  routine allocated the memory.  Then we can do heap-allocation
  profiling to identify which routines use up all the bloody memory.

- We could still generate better code for switches


source-level transformations
----------------------------

- specialization of calls to list__map and similar higher-order predicates
  that take predicates as arguments in the case where the predicate arguments
  are known

- more work on module system, separate compilation, and the multiple
  specialization problem, in particular
	- cross-module inlining
	- cross-module specialization of higher-order preds

- deforestation

- transform non-tail-recursive predicates into tail-recursive form
  using accumulators


low-level optimizations
-----------------------

- reduce the overhead of higher-order predicate calls (avoid copying
  the real registers into the fake_reg array and back)

- tail recursion optimization using pass-by-reference argument conventions

- other specializations, e.g. if argument is known to be bound to
  f(X,Y), then just pass X and Y in registers


compilation speed
-----------------

- improve efficiency of the expansion of equivalence types (currently O(N^2))
  (e.g. this is particularly bad when compiling live_vars.m.)

- improve efficiency of the module import handling (currently O(N^2))

- improve the efficiency of mode checking very large facts
  (e.g. this is particularly bad when compiling eliza.m.)

- improve the efficiency of the type_to_term and term_to_type implementation
  so that we can enable them in the standard distribution of the Mercury
  compiler


better diagnostics
------------------

- optional warning for any implicit quantifiers whose scope is not
  the entire clause (the "John Lloyd" option :-).

- warn about multiple calls to a predicate with the same input arguments,
  because this is likely to be a programming mistake.
  eg.

	p(...) :-
		...
		q(InA, InB, OutC, OutD),
		...
		q(InA, InB, OutE, OutF).

  should result in

	Warning: redundant call to `q(InA, InB, _, _)'

- give a better error message for the use of if-then without else.

- give a better error message for the use of `<=' instead of `>='
  (but how?)

- give a better error message for type errors involving higher-order pred
  constants (requested by Bart Demoen)

- give better error messages for syntax errors in lambda expressions

- issue a warning if the only use of an argument is in a recursive call


general
-------

- coroutining and parallel versions of Mercury
	[being worked on by conway]

- implement a very fast turn-around bytecode compiler/interpreter/debugger,
  similar to Gofer

- implement a new backend which compiles to high-level C that can
  be debugged at the Mercury source code level using gdb
	[a start has been made by fjh]

- implement "accurate" garbage collection
	[being worked on by tyson]

- implement user-defined operators:
	Add a new construct `:- op(Pred, Type, Op).' as in Prolog;
	change prog_io.m to parse this construct and call io__op
	accordingly.

*******************************************************************************

#-----------------------------------------------------------------------------#

# Mmake.rules - rules for building Mercury programs

main_target: $(MAIN_TARGET)

#-----------------------------------------------------------------------------#

.SUFFIXES: .m .nl .no .err .int .int2 .dep .depend .doit .ugly \
		.date .c .nu .o .pic_o .mod .pp .s .garb .mod_h .ql .pl

.PRECIOUS: %.date

# All the builtin rules must use $@ as the target, so that they work
# when $(VPATH) is set.

.pp.m:
	@-[ ! -f $@ ] || chmod +w $@
	sed '/^#if *NU_PROLOG/,/^#endif/s/.*//' $< > $@
	@-chmod -w $@

.m.nl:
	rm -f $@
	ln -s $< $@

.nl.no:
	$(MNC) $(MNCFLAGS) -o $@ $<

.nl.ql:
	$(MSC) $(MSCFLAGS) -o $@ $<

.nl.pl:
	sicstus_conv $<

# The `touch' is necessary, since otherwise if
# the old .err file was of size zero and
# the new .err file is also of size zero,
# the time-stamp doesn't get updated!
# (Is that a bug in unix? In bash?)
.nl.err:
	$(MC) $(MCFLAGS) $< > $@ 2>&1
	@touch $@

# do not remove the whitespace in the following two rules!

.date.int:
	

.date.int2:
	

.nl.date:
	$(MCI) $(MCFLAGS) $(MCIFLAGS) $<

.nl.garb:
	$(MCG) --garbage-collection accurate $(MCGFLAGS) $<

.nl.ugly:
	$(MC) --convert-to-mercury $(MCFLAGS) $<

.nl.depend:
	@-[ ! -f $*.dep ] || chmod +w $*.dep
	$(MCD) $(MCDFLAGS) $<
	@-chmod -w $*.dep

.dep.doit:
	sed -e ':a' -e '/\\/N' -e 's/\\\n	//' -e 't a' $< |  \
	tee tmp | \
	grep 'srcs *=' | \
	sed	-e 's/.*=/:-[ '\''nu_library.doit'\'', /' \
		-e 's/\.nl/,/g' \
		-e 's/$$/ portray ]./' \
		> $@

.nl.mod:
	rm -f $*.mod
	$(MCG) -s $(GRADE) $(MCGFLAGS) $< > $*.err2 2>&1

.mod.c:
	[ -f $< ] && $(MOD2C) -s$(GRADE) $(MOD2CFLAGS) $< > $@

.mod.mod_h:
	[ -f $< ] && $(MOD2H) -s$(GRADE) $(MOD2HFLAGS) $< > $@

.c.o:
	$(MGNUC) -s$(GRADE) $(MGNUCFLAGS) -c $< -o $@

.c.pic_o:
	$(MGNUC) -s$(GRADE) $(MGNUCFLAGS) $(PIC) -c $< -o $@

.c.s:
	$(MGNUC) -s$(GRADE) $(MGNUCFLAGS) -S $< -o $@

#-----------------------------------------------------------------------------#

# Clean up some mess

# You can attach new dependencies to the `clean' and `realclean' targets
# to make them clean up more than just the stuff listed here.

.PHONY: clean
clean:	clean_no clean_ns clean_err clean_err2 clean_ints clean_ugly \
	clean_hlds_dump clean_mod clean_c clean_o clean_s

.PHONY: clean_no
clean_no:
	-rm -f *.no
	
.PHONY: clean_ns
clean_ns:
	-rm -f *.ns
	
.PHONY: clean_err
clean_err:
	-rm -f *.err

.PHONY: clean_err2
clean_err2:
	-rm -f *.err2

.PHONY: clean_ints
clean_ints:
	-rm -f *.int *.int2 *.date

.PHONY: clean_ugly
clean_ugly:
	-rm -f *.ugly

.PHONY: clean_hlds_dump
clean_hlds_dump:
	-rm -f *.hlds_dump*

.PHONY: clean_c
clean_c:
	$(CLEAN_C)

.PHONY: clean_mod
clean_mod:
	$(CLEAN_MOD)

.PHONY: clean_o
clean_o:
	-rm -f *.o

.PHONY: clean_s
clean_s:
	$(CLEAN_S)

.PHONY: realclean
realclean: clean clean_deps clean_nu clean_progs clean_libs

.PHONY: clean_deps
clean_deps:
	-rm -f *.dep *.d

.PHONY: clean_nu
clean_nu:
	-rm -f *.nu *.save

.PHONY: clean_progs
clean_progs: clean_a_out

.PHONY: clean_a_out
clean_a_out:
	-rm -f a.out

.PHONY: clean_libs
clean_libs:
	-rm -f *.a *.so

#-----------------------------------------------------------------------------#

PROFILING

1. BUILDING PROFILED APPLICATIONS

To build an application with profiling turned on you need to make sure
the following conditions hold about the library files (in the
directories `boehm_gc', `runtime', and `library').

The `runtime' and `library' libraries must be built with profiling enabled,
and the `boehm_gc' library must be build without `-DNO_SIGNALS'.
To do this add the line 

	EXTRA_CFLAGS = -DPROFILE_TIME -DPROFILE_CALLS -UNO_SIGNALS

to the Mmake.params file.  Delete any existing object files (*.o) in
those directories, and then rebuild the libraries.

2. DISPLAYING THE PROFILE

The profile generated is actually a statistical approximation of the real
profile.  Hence there a few steps that should be taken to ensure 
meaningful results.

One is to compile all the modules in a program with the --profiling option.
This generate's a file called <module_name>.prof.  This file contains the
static call graph of the particular module that is in a form easy for
the profiler to use.  

The advantage of using the static call graph over the dynamic call graph
which is inherent in the data collected is due to the presence of cycles.
Cycles are groups of procedures that can eventually call themselves again.
Due to the way the profiler propagates time through the call graph more
meaningful results will be obtained if you can guarantee the same cycles
will be present in the call graph no matter which run of the program you
are profiling.

Then just type 
	mprof *.prof

NB. If you don't have all of the prof files including the library ones,
    just type mprof and that will generate the dynamic graph.


NB. Also at the moment you also have to delete the line 
	0	1
    from the file Prof.Counts.  Problem soon to be rectified.


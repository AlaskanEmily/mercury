/*
** Copyright (C) 1995-2000 The University of Melbourne.
** This file may only be copied under the terms of the GNU Library General
** Public License - see the file COPYING.LIB in the Mercury distribution.
*/

/*
** mercury_type_info.h -
**	Definitions for accessing the type_infos, type_layouts, and
**	type_functors tables generated by the Mercury compiler.
**	Also contains definitions for accessing the Mercury `univ' type.
**
**	Changes to the structures of type_infos and pseudo_type_infos
**	may also require changes in:
**
**		compiler/polymorphism.m
**		compiler/pseudo_type_info.m
**		compiler/higher_order.m
**
**	Changes to the structures of type_ctor_infos may require changes in:
**
**		compiler/type_ctor_info.m
**		compiler/rtti.m
**		compiler/rtti_out.m
**			(for updating the compiler-generated RTTI
**			structures)
**
**		library/array.m
**		library/builtin.m
**		library/private_builtin.m
**		library/std_util.m
**		runtime/mercury_bootstrap.c
**			(for updating the hand-written RTTI
**			structures)
**
**	Both kinds of changes will of course also require changes to the code
**	that traverses type_infos and type_ctor_infos:
**
**		runtime/mercury_deep_copy_body.h
**		runtime/mercury_tabling.c
**		runtime/mercury_type_info.c
**		library/std_util.m
*/

#ifndef MERCURY_TYPE_INFO_H
#define MERCURY_TYPE_INFO_H

#include "mercury_std.h"	/* for `MR_STRINGIFY' and `MR_PASTEn' */
#include "mercury_types.h"	/* for `Word' */

/*---------------------------------------------------------------------------*/

/*
** The version of the RTTI data structures -- useful for bootstrapping.
** MR_RTTI_VERSION sets the version number in the handwritten
** type_ctor_infos.
** If you write runtime code that checks this version number and
** can at least handle the previous version of the data
** structure, it makes it easier to bootstrap changes to the data
** structures used for RTTI.
**
** This number should be kept in sync with type_ctor_info_rtti_version in
** compiler/base_type_info.m.
*/

#define MR_RTTI_VERSION 		MR_RTTI_VERSION__CLEAN_LAYOUT
#define MR_RTTI_VERSION__INITIAL 	2
#define MR_RTTI_VERSION__USEREQ 	3
#define MR_RTTI_VERSION__CLEAN_LAYOUT 	4

/*
** Check that the RTTI version is in a sensible range.
** The lower bound should be the lowest currently supported version
** number.  The upper bound is the current version number.
** If you increase the lower bound you should also increase the binary
** compatibility version number in runtime/mercury_grade.h (MR_GRADE_PART_0).
*/

#define MR_TYPE_CTOR_INFO_CHECK_RTTI_VERSION_RANGE(typector)	\
	assert(MR_RTTI_VERSION__USEREQ <= typector->type_ctor_version \
	&& typector->type_ctor_version <= MR_RTTI_VERSION__CLEAN_LAYOUT)

/*---------------------------------------------------------------------------*/

/*
** For now, we don't give a C definition of the structures of typeinfos
** and pseudotypeinfos. We may change this later.
**
** A pseudotypeinfo is the same as a typeinfo (see polymorphism.m) but
** may also store free type variables, represented as small integers:
** 1 to 512 represent universally quantified type variables
** and 513 to 1024 represent existentially quantified type variables.
** (We do not use zero to represent any type variable, for two reasons.
** First, variable numbering starts at one inside the compiler. Second,
** starting at one allows us to use universally quantified type variable
** numbers to be used directly as the offset into a (non-higher-order)
** typeinfo.
**
** This scheme relies on the bit patterns of these integers corresponding
** to memory that is either inaccessible (due to the first page of virtual
** memory being invalid) or is guaranteed to contains something other than
** type_ctor_info structures (such as the code of the program).
**
** MR_PSEUDOTYPEINFO_EXIST_VAR_BASE should be kept in sync with
** base_type_layout__pseudo_typeinfo_min_exist_var in base_type_layout.m.
**
** MR_PSEUDOTYPEINFO_MAX_VAR should be kept in sync with
** base_type_layout__pseudo_typeinfo_max_var in base_type_layout.m,
** and with the default value of MR_VARIABLE_SIZED in mercury_conf_params.h.
*/

typedef	Word	MR_TypeInfo;
typedef	Word	MR_PseudoTypeInfo;

#define MR_PSEUDOTYPEINFO_EXIST_VAR_BASE	512
#define MR_PSEUDOTYPEINFO_MAX_VAR		1024

#define TYPEINFO_IS_VARIABLE(T)	( (Unsigned) T <= MR_PSEUDOTYPEINFO_MAX_VAR )

#define MR_TYPE_VARIABLE_IS_EXIST_QUANT(T)	\
	( (Word) (T) > MR_PSEUDOTYPEINFO_EXIST_VAR_BASE )
#define MR_TYPE_VARIABLE_IS_UNIV_QUANT(T)	\
	( (Word) (T) <= MR_PSEUDOTYPEINFO_EXIST_VAR_BASE )

/*---------------------------------------------------------------------------*/

/*
** Define offsets of fields in the type_ctor_info or type_info structure.
** See polymorphism.m for explanation of these offsets and how the
** type_info and type_ctor_info structures are laid out.
**
** ANY CHANGES HERE MUST BE MATCHED BY CORRESPONDING CHANGES
** TO THE DOCUMENTATION IN compiler/polymorphism.m.
**
** The current type_info representation *depends* on OFFSET_FOR_COUNT being 0.
*/

#define OFFSET_FOR_COUNT			0
#define OFFSET_FOR_UNIFY_PRED			1
#define OFFSET_FOR_INDEX_PRED			2
#define OFFSET_FOR_COMPARE_PRED			3
#define OFFSET_FOR_TYPE_CTOR_REPRESENTATION	4
#define OFFSET_FOR_BASE_TYPE_FUNCTORS		5
#define OFFSET_FOR_BASE_TYPE_LAYOUT		6
#define OFFSET_FOR_TYPE_MODULE_NAME		7
#define OFFSET_FOR_TYPE_NAME			8

/*
** Define offsets of fields in the type_info structure.
*/

#define OFFSET_FOR_ARG_TYPE_INFOS 1

/*
** Where the predicate arity and args are stored in the type_info.
** They are stored in the type_info (*not* the type_ctor_info).
** This is brought about by higher-order predicates all using the
** same type_ctor_info - pred/0.
*/

#define TYPEINFO_OFFSET_FOR_PRED_ARITY 1
#define TYPEINFO_OFFSET_FOR_PRED_ARGS 2

/*---------------------------------------------------------------------------*/

/*
** Definitions for handwritten code, mostly for mercury_compare_typeinfo.
*/

#define MR_COMPARE_EQUAL 0
#define MR_COMPARE_LESS 1
#define MR_COMPARE_GREATER 2

/*---------------------------------------------------------------------------*/

/*
** Definitions and macros for type_ctor_layout definition.
**
** See compiler/base_type_layout.m for more information.
**
** If we don't have enough tags, we have to encode layouts
** less densely. The make_typelayout macro does this, and
** is intended for handwritten code. Compiler generated
** code can (and does) just create two rvals instead of one.
**
** XXX This stuff is part of USEREQ type_ctor_infos and is obsolete;
** it is needed now only for bootstrapping.
*/

/*
** Conditionally define USE_TYPE_LAYOUT.
**
** All code using type_layout structures should check to see if
** USE_TYPE_LAYOUT is defined, and give a fatal error otherwise.
** USE_TYPE_LAYOUT can be explicitly turned off with NO_TYPE_LAYOUT.
**
*/
#if !defined(NO_TYPE_LAYOUT)
	#define USE_TYPE_LAYOUT
#else
	#undef USE_TYPE_LAYOUT
#endif

/*
** Declaration for structs.
*/

#define MR_DECLARE_STRUCT(T)			\
	extern const struct T##_struct T
#define MR_DECLARE_TYPE_CTOR_INFO_STRUCT(T)			\
	extern const struct MR_TypeCtorInfo_Struct T

/*---------------------------------------------------------------------------*/

/*
** Tags in type_layout structures.
**
** These definitions are intended for use in handwritten
** C code.
**
** Some of the type-layout tags are shared.
**
** XXX This stuff is part of USEREQ type_ctor_infos and is obsolete;
** it is needed now only for bootstrapping.
*/

#define TYPE_CTOR_LAYOUT_CONST_TAG		0
#define TYPE_CTOR_LAYOUT_SHARED_LOCAL_TAG	0
#define TYPE_CTOR_LAYOUT_UNSHARED_TAG		1
#define TYPE_CTOR_LAYOUT_SHARED_REMOTE_TAG	2
#define TYPE_CTOR_LAYOUT_EQUIV_TAG		3
#define TYPE_CTOR_LAYOUT_NO_TAG			3

/*
** This constant is also used for other information - for
** ctor infos a small integer is used for higher order types.
** Even integers represent preds, odd represent functions.
** The arity of the pred or function can be found by dividing by
** two (integer division).
*/

#define MR_TYPE_CTOR_INFO_HO_PRED				\
	((MR_TypeCtorInfo) &mercury_data___type_ctor_info_pred_0)
#define MR_TYPE_CTOR_INFO_HO_FUNC				\
	((MR_TypeCtorInfo) &mercury_data___type_ctor_info_func_0)
#define MR_TYPE_CTOR_INFO_IS_HO_PRED(T)				\
	(T == MR_TYPE_CTOR_INFO_HO_PRED)
#define MR_TYPE_CTOR_INFO_IS_HO_FUNC(T)				\
	(T == MR_TYPE_CTOR_INFO_HO_FUNC)
#define MR_TYPE_CTOR_INFO_IS_HO(T)				\
	(T == MR_TYPE_CTOR_INFO_HO_FUNC || T == MR_TYPE_CTOR_INFO_HO_PRED)

#define MR_TYPECTOR_IS_HIGHER_ORDER(T)				\
	( (Word) T <= MR_PSEUDOTYPEINFO_MAX_VAR )
#define MR_TYPECTOR_MAKE_PRED(Arity)				\
	( (Word) ((Integer) (Arity) * 2) )
#define MR_TYPECTOR_MAKE_FUNC(Arity)				\
	( (Word) ((Integer) (Arity) * 2 + 1) )
#define MR_TYPECTOR_GET_HOT_ARITY(T)				\
	((Integer) (T) / 2 )
#define MR_TYPECTOR_GET_HOT_NAME(T)				\
	((ConstString) ( ( ((Integer) (T)) % 2 ) ? "func" : "pred" ))
#define MR_TYPECTOR_GET_HOT_MODULE_NAME(T)				\
	((ConstString) "builtin")
#define MR_TYPECTOR_GET_HOT_TYPE_CTOR_INFO(T)			\
	((Word) ( ( ((Integer) (T)) % 2 ) ?		\
		(const Word *) &mercury_data___type_ctor_info_func_0 :	\
		(const Word *) &mercury_data___type_ctor_info_pred_0 ))

/*
** Offsets into the type_layout structure for functors and arities.
**
** Constant and enumeration values start at 0, so the functor
** is at OFFSET + const/enum value.
**
** Functors for unshared tags are at OFFSET + arity (the functor is
** stored after all the argument info.
**
*/

#define TYPE_CTOR_LAYOUT_CONST_FUNCTOR_OFFSET		2
#define TYPE_CTOR_LAYOUT_ENUM_FUNCTOR_OFFSET		2
#define TYPE_CTOR_LAYOUT_UNSHARED_FUNCTOR_OFFSET	1

#define TYPE_CTOR_LAYOUT_UNSHARED_ARITY_OFFSET  	0
#define TYPE_CTOR_LAYOUT_UNSHARED_ARGS_OFFSET       	1

/*---------------------------------------------------------------------------*/

/*
** Offsets for dealing with `univ' types.
**
** `univ' is represented as a two word structure.
** The first word contains the address of a type_info for the type.
** The second word contains the data.
*/

#define UNIV_OFFSET_FOR_TYPEINFO 		0
#define UNIV_OFFSET_FOR_DATA			1

/*---------------------------------------------------------------------------*/

/*
** Code for dealing with the static code addresses stored in
** type_ctor_infos.
*/

/*
** Definitions for initialization of type_ctor_infos. If
** MR_STATIC_CODE_ADDRESSES are not available, we need to initialize
** the special predicates in the type_ctor_infos.
*/

/*
** A fairly generic static code address initializer - at least for entry
** labels.
*/
#define MR_INIT_CODE_ADDR(Base, PredAddr, Offset)			\
	do {								\
		Declare_entry(PredAddr);				\
		((Word *) (Word) &Base)[Offset]	= (Word) ENTRY(PredAddr);\
	} while (0)
			
#define MR_SPECIAL_PRED_INIT(Base, TypeId, Offset, Pred)	\
	MR_INIT_CODE_ADDR(Base, mercury____##Pred##___##TypeId, Offset)

/*
** Macros are provided here to initialize type_ctor_infos, both for
** builtin types (such as in library/builtin.m) and user
** defined C types (like library/array.m). Also, the automatically
** generated code uses these initializers.
**
** Examples of use:
**
** MR_INIT_BUILTIN_TYPE_CTOR_INFO(
** 	mercury_data__type_ctor_info_string_0, _string_);
**
** note we use _string_ to avoid the redefinition of string via #define
**
** MR_INIT_TYPE_CTOR_INFO(
** 	mercury_data_group__type_ctor_info_group_1, group__group_1_0);
**
** MR_INIT_TYPE_CTOR_INFO_WITH_PRED(
** 	mercury_date__type_ctor_info_void_0, mercury__unused_0_0);
**
** This will initialize a type_ctor_info with a single code address.
*/

#ifndef MR_STATIC_CODE_ADDRESSES

  #define MR_MAYBE_STATIC_CODE(X)	((Integer) 0)

  #define MR_STATIC_CODE_CONST

  #define	MR_INIT_BUILTIN_TYPE_CTOR_INFO(B, T)			\
  do {									\
	MR_INIT_CODE_ADDR(B, mercury__builtin_unify##T##2_0, 		\
		OFFSET_FOR_UNIFY_PRED);					\
	MR_INIT_CODE_ADDR(B, mercury__builtin_index##T##2_0, 		\
		OFFSET_FOR_INDEX_PRED);					\
	MR_INIT_CODE_ADDR(B, mercury__builtin_compare##T##3_0, 		\
		OFFSET_FOR_COMPARE_PRED);				\
  } while (0)

  #define	MR_INIT_TYPE_CTOR_INFO_WITH_PRED(B, P)			\
  do {									\
	MR_INIT_CODE_ADDR(B, P, OFFSET_FOR_UNIFY_PRED);			\
	MR_INIT_CODE_ADDR(B, P, OFFSET_FOR_INDEX_PRED);			\
	MR_INIT_CODE_ADDR(B, P, OFFSET_FOR_COMPARE_PRED);		\
  } while (0)

  #define	MR_INIT_TYPE_CTOR_INFO(B, T)				\
  do {									\
	MR_SPECIAL_PRED_INIT(B, T, OFFSET_FOR_UNIFY_PRED, Unify);	\
	MR_SPECIAL_PRED_INIT(B, T, OFFSET_FOR_INDEX_PRED, Index);	\
	MR_SPECIAL_PRED_INIT(B, T, OFFSET_FOR_COMPARE_PRED, Compare);	\
  } while (0)

#else	/* MR_STATIC_CODE_ADDRESSES */

  #define MR_MAYBE_STATIC_CODE(X)	(X)

  #define MR_STATIC_CODE_CONST const

  #define MR_INIT_BUILTIN_TYPE_CTOR_INFO(B, T) \
	do { } while (0)

  #define MR_INIT_TYPE_CTOR_INFO_WITH_PRED(B, P) \
	do { } while (0)

  #define MR_INIT_TYPE_CTOR_INFO(B, T) \
	do { } while (0)

#endif /* MR_STATIC_CODE_ADDRESSES */

/*---------------------------------------------------------------------------*/

/*
** Macros and defintions for defining and dealing with
** type_ctor_functors.
**
** XXX This stuff is part of USEREQ type_ctor_infos and is obsolete;
** it is needed now only for bootstrapping.
*/

/*
** All type_functors have an indicator.
*/

#define MR_TYPE_CTOR_FUNCTORS_OFFSET_FOR_INDICATOR	((Integer) 0)

#define MR_TYPE_CTOR_FUNCTORS_INDICATOR(functors)			\
	((functors)[MR_TYPE_CTOR_FUNCTORS_OFFSET_FOR_INDICATOR])

/*
** Values that the indicator can take.
*/

#define MR_TYPE_CTOR_FUNCTORS_DU	((Integer) 0)
#define MR_TYPE_CTOR_FUNCTORS_ENUM	((Integer) 1)
#define MR_TYPE_CTOR_FUNCTORS_EQUIV	((Integer) 2)
#define MR_TYPE_CTOR_FUNCTORS_SPECIAL	((Integer) 3)
#define MR_TYPE_CTOR_FUNCTORS_NO_TAG	((Integer) 4)
#define MR_TYPE_CTOR_FUNCTORS_UNIV	((Integer) 5)

	/*
	** Macros to access the data in a discriminated union
	** type_functors, the number of functors, and the functor descriptor
	** for functor number N (where N starts at 1).
	*/

#define MR_TYPE_CTOR_FUNCTORS_DU_OFFSET_FOR_NUM_FUNCTORS	((Integer) 1)
#define MR_TYPE_CTOR_FUNCTORS_DU_OFFSET_FOR_FUNCTOR_DESCRIPTORS	((Integer) 2)

#define MR_TYPE_CTOR_FUNCTORS_DU_NUM_FUNCTORS(Functors)			\
	((Functors)[MR_TYPE_CTOR_FUNCTORS_DU_OFFSET_FOR_NUM_FUNCTORS])

#define MR_TYPE_CTOR_FUNCTORS_DU_FUNCTOR_N(Functor, N)			\
	((Word *) ((Functor)[						\
		MR_TYPE_CTOR_FUNCTORS_DU_OFFSET_FOR_FUNCTOR_DESCRIPTORS + N]))

	/*
	** Macros to access the data in a enumeration type_functors, the
	** number of functors, and the enumeration vector.
	*/

#define MR_TYPE_CTOR_FUNCTORS_ENUM_OFFSET_FOR_ENUM_VECTOR	\
		((Integer) 1)

#define MR_TYPE_CTOR_FUNCTORS_ENUM_NUM_FUNCTORS(Functors)		\
	MR_TYPE_CTOR_LAYOUT_ENUM_VECTOR_NUM_FUNCTORS(			\
		MR_TYPE_CTOR_FUNCTORS_ENUM_VECTOR((Functors)))

#define MR_TYPE_CTOR_FUNCTORS_ENUM_VECTOR(Functor)			\
	((Word *) ((Functor)						\
		[MR_TYPE_CTOR_FUNCTORS_ENUM_OFFSET_FOR_ENUM_VECTOR]))

	/*
	** Macros to access the data in a no_tag type_functors, the
	** functor descriptor for the functor (there can only be one functor
	** with no_tags).
	*/

#define MR_TYPE_CTOR_FUNCTORS_NO_TAG_OFFSET_FOR_FUNCTOR_DESCRIPTOR \
	((Integer) 1)

#define MR_TYPE_CTOR_FUNCTORS_NO_TAG_FUNCTOR(Functors)			\
	((Word *) ((Functors)						\
		[MR_TYPE_CTOR_FUNCTORS_NO_TAG_OFFSET_FOR_FUNCTOR_DESCRIPTOR]))

	/*
	** Macros to access the data in an equivalence type_functors,
	** the equivalent type of this type.
	*/

#define MR_TYPE_CTOR_FUNCTORS_EQUIV_OFFSET_FOR_TYPE	((Integer) 1)

#define MR_TYPE_CTOR_FUNCTORS_EQUIV_TYPE(Functors)			\
	((Functors)[MR_TYPE_CTOR_FUNCTORS_EQUIV_OFFSET_FOR_TYPE])

/*---------------------------------------------------------------------------*/

/*
** Macros and defintions for defining and dealing with the data structures
** created by type_ctor_layouts (these are the same vectors referred to
** by type_ctor_functors)
** 	- the functor descriptor, describing a single functor
** 	- the enum_vector, describing an enumeration
** 	- the no_tag_vector, describing a single functor
**
** XXX This stuff is part of USEREQ type_ctor_infos and is obsolete;
** it is needed now only for bootstrapping.
*/

	/*
	** Macros for dealing with enum vectors.
	*/

typedef struct {
	int enum_or_comp_const;
	Word num_sharers;		
	ConstString functor1;
/* other functors follow, num_sharers of them.
** 	ConstString functor2;
** 	...
*/
} MR_TypeLayout_EnumVector;

#define MR_TYPE_CTOR_LAYOUT_ENUM_VECTOR_IS_ENUM(Vector)			\
	((MR_TypeLayout_EnumVector *) (Vector))->enum_or_comp_const

#define MR_TYPE_CTOR_LAYOUT_ENUM_VECTOR_NUM_FUNCTORS(Vector)		\
	((MR_TypeLayout_EnumVector *) (Vector))->num_sharers

#define MR_TYPE_CTOR_LAYOUT_ENUM_VECTOR_FUNCTOR_NAME(Vector, N)		\
	( (&((MR_TypeLayout_EnumVector *)(Vector))->functor1) [N] )

	/*
	** Macros for dealing with functor descriptors.
	**
	** XXX we might like to re-organize this structure so the
	**     variable length component isn't such a pain.
	*/

typedef struct {
	Integer		arity;
	Word		arg1;		
/* other functors follow, arity of them.
** 	Word		arg2;
** 	...
**	ConstString	functorname;
**	Word		tagbits;
**	Integer		num_extra_args; 	for exist quant args
**	Word		locn1;			type info locations
**	...
*/
} MR_TypeLayout_FunctorDescriptor;

#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_ARITY	\
	((Integer) 0)
#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_ARGS	((Integer) 1)
	/* Note, these offsets are from the end of the args */
#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_FUNCTOR_NAME	\
		((Integer) 1)
#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_FUNCTOR_TAG	\
		((Integer) 2)
#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_EXIST_TYPEINFO_VARCOUNT \
		((Integer) 3)
#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_EXIST_TYPECLASSINFO_VARCOUNT \
		((Integer) 4)
#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_TYPE_INFO_LOCNS \
		((Integer) 5)

#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_ARITY(V)			\
		((V)[MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_ARITY])

#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_ARGS(V)			\
		(V + MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_ARGS)

#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_FUNCTOR_NAME(V)		\
	((String) ((V)[MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_ARITY(V) + \
	    MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_FUNCTOR_NAME]))

#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_TAG(V)			\
	((Word) ((V)[MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_ARITY(V) +	\
		MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_FUNCTOR_TAG]))

#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_EXIST_TYPEINFO_VARCOUNT(V)	\
	((Word) ((V)[MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_ARITY(V) +	\
		MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_EXIST_TYPEINFO_VARCOUNT]))

#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_EXIST_TYPECLASSINFO_VARCOUNT(V)	\
	((Word) ((V)[MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_ARITY(V) +	\
		MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_EXIST_TYPECLASSINFO_VARCOUNT]))

#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_EXIST_VARCOUNT(V)	\
		MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_EXIST_TYPEINFO_VARCOUNT(V) + MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_EXIST_TYPECLASSINFO_VARCOUNT(V)

#define MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_TYPE_INFO_LOCNS(V)	  \
	(((Word *)V) + 							  \
		MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_ARITY((Word *)V) + \
		MR_TYPE_CTOR_LAYOUT_FUNCTOR_DESCRIPTOR_OFFSET_FOR_TYPE_INFO_LOCNS)

	/*
	** Macros for handling type info locations
	*/
#define MR_TYPE_INFO_LOCN_IS_INDIRECT(t) ((t) & (Unsigned) 1)
#define MR_TYPE_INFO_LOCN_INDIRECT_GET_TYPEINFO_NUMBER(t) (int) ((t) >> 7)
#define MR_TYPE_INFO_LOCN_INDIRECT_GET_ARG_NUMBER(t) \
	(int) (((t) >> 1) & (Unsigned) 63)
#define MR_TYPE_INFO_LOCN_DIRECT_GET_TYPEINFO_NUMBER(t) (int) ((t) >> 1)

	/*
	** Macros for dealing with shared remote vectors.
	*/

typedef struct {
	Word num_sharers;		
	Word functor_descriptor1;
/* other functor descriptors follow, num_sharers of them.
**	Word functor_descriptor2;
** 	...
*/
} MR_TypeLayout_SharedRemoteVector;

#define MR_TYPE_CTOR_LAYOUT_SHARED_REMOTE_VECTOR_NUM_SHARERS(Vector) 	\
	(((MR_TypeLayout_SharedRemoteVector *) (Vector))->num_sharers)

#define MR_TYPE_CTOR_LAYOUT_SHARED_REMOTE_VECTOR_GET_FUNCTOR_DESCRIPTOR( \
		Vector, N)						 \
	( (Word *) MR_strip_tag((&((MR_TypeLayout_SharedRemoteVector *)	 \
		(Vector))->functor_descriptor1) [N]) )
		
	/*
	** Macros for dealing with no_tag vectors
	**
	** (Note, we know the arity is 1).
	*/

typedef struct {
	int		is_no_tag;
	Word		arg;
	ConstString	name;
} MR_TypeLayout_NoTagVector;

#define MR_TYPE_CTOR_LAYOUT_NO_TAG_VECTOR_IS_NO_TAG(Vector)		\
		((MR_TypeLayout_NoTagVector *) (Vector))->is_no_tag

#define MR_TYPE_CTOR_LAYOUT_NO_TAG_VECTOR_ARITY(Vector)			\
		(1)

#define MR_TYPE_CTOR_LAYOUT_NO_TAG_VECTOR_ARGS(Vector)			\
		&(((MR_TypeLayout_NoTagVector *) (Vector))->arg)
		
#define MR_TYPE_CTOR_LAYOUT_NO_TAG_VECTOR_FUNCTOR_NAME(Vector)		\
		((MR_TypeLayout_NoTagVector *) (Vector))->name

	/*
	** Macros for dealing with equivalent vectors
	*/	

typedef struct {
	int	is_no_tag;		/* might be a no_tag */
	Word	equiv_type;
} MR_TypeLayout_EquivVector;

#define MR_TYPE_CTOR_LAYOUT_EQUIV_OFFSET_FOR_TYPE	((Integer) 1)

#define MR_TYPE_CTOR_LAYOUT_EQUIV_IS_EQUIV(Vector)			\
		(!((MR_TypeLayout_EquivVector *) (Vector))->is_no_tag)

#define MR_TYPE_CTOR_LAYOUT_EQUIV_TYPE(Vector)				\
		((MR_TypeLayout_EquivVector *) (Vector))->equiv_type

/*---------------------------------------------------------------------------*/

	/*
	** Macros for retreiving things from type_infos.
	*/

#define MR_TYPEINFO_GET_TYPE_CTOR_INFO(TypeInfo)			\
	((MR_TypeCtorInfo) ((*(TypeInfo)) ? *(TypeInfo) : (Word) (TypeInfo)))

#define MR_TYPEINFO_GET_HIGHER_ARITY(TypeInfo)				\
	((Integer) (Word *) (TypeInfo)[TYPEINFO_OFFSET_FOR_PRED_ARITY])

/*---------------------------------------------------------------------------*/

/*
** definitions for accessing the representation of the
** Mercury typeclass_info
*/

#define	MR_typeclass_info_instance_arity(tci) \
	((Integer)(*(Word **)(tci))[0])
#define	MR_typeclass_info_num_superclasses(tci) \
	((Integer)(*(Word **)(tci))[1])
#define	MR_typeclass_info_num_type_infos(tci) \
	((Integer)(*(Word **)(tci))[2])
#define	MR_typeclass_info_num_methods(tci) \
	((Integer)(*(Word **)(tci))[3])
#define	MR_typeclass_info_class_method(tci, n) \
	((Code *)(*(Word **)tci)[(n+3)])
#define	MR_typeclass_info_arg_typeclass_info(tci, n) \
	(((Word *)(tci))[(n)])

	/*
	** The following have the same definitions. This is because
	** the call to MR_typeclass_info_type_info must already have the
	** number of superclass_infos for the class added to it
	*/
#define	MR_typeclass_info_superclass_info(tci, n) \
	(((Word *)(tci))[MR_typeclass_info_instance_arity(tci) + (n)])
#define	MR_typeclass_info_type_info(tci, n) \
	(((Word *)(tci))[MR_typeclass_info_instance_arity(tci) + (n)])

/*---------------------------------------------------------------------------*/

/*
** Definitions and functions for categorizing data representations.
*/

/*
** MR_DataRepresentation is the representation for a particular type
** constructor.  For the cases of MR_TYPE_CTOR_REP_DU and
** MR_TYPE_CTOR_REP_DU_USEREQ, the exact representation depends on the tag
** value -- lookup the tag value in type_ctor_layout to find out this
** information.
*/

typedef enum {
	MR_TYPECTOR_REP_ENUM,
	MR_TYPECTOR_REP_ENUM_USEREQ,
	MR_TYPECTOR_REP_DU,
	MR_TYPECTOR_REP_DU_USEREQ,
	MR_TYPECTOR_REP_NOTAG,
	MR_TYPECTOR_REP_NOTAG_USEREQ,
	MR_TYPECTOR_REP_EQUIV,
	MR_TYPECTOR_REP_EQUIV_VAR,
	MR_TYPECTOR_REP_INT,
	MR_TYPECTOR_REP_CHAR,
	MR_TYPECTOR_REP_FLOAT,
	MR_TYPECTOR_REP_STRING,
	MR_TYPECTOR_REP_PRED,
	MR_TYPECTOR_REP_UNIV,
	MR_TYPECTOR_REP_VOID,
	MR_TYPECTOR_REP_C_POINTER,
	MR_TYPECTOR_REP_TYPEINFO,
	MR_TYPECTOR_REP_TYPECLASSINFO,
	MR_TYPECTOR_REP_ARRAY,
	MR_TYPECTOR_REP_SUCCIP,
	MR_TYPECTOR_REP_HP,
	MR_TYPECTOR_REP_CURFR,
	MR_TYPECTOR_REP_MAXFR,
	MR_TYPECTOR_REP_REDOFR,
	MR_TYPECTOR_REP_REDOIP,
	MR_TYPECTOR_REP_TRAIL_PTR,
	MR_TYPECTOR_REP_TICKET,
	MR_TYPECTOR_REP_NOTAG_GROUND,
	MR_TYPECTOR_REP_NOTAG_GROUND_USEREQ,
	MR_TYPECTOR_REP_EQUIV_GROUND,
	/*
	** MR_TYPECTOR_REP_UNKNOWN should remain the last alternative;
	** MR_CTOR_REP_STATS depends on this.
	*/
	MR_TYPECTOR_REP_UNKNOWN
} MR_TypeCtorRep;

/*
** This macro is intended to be used for the initialization of an array
** that converts each MR_TypeCtorRep into a string form. Therefore it
** must be kept synchronized with the definition of MR_TypeCtorRep.
*/

#define	MR_CTOR_REP_NAMES						\
	"ENUM",								\
	"ENUM_USEREQ",							\
	"DU",								\
	"DU_USEREQ",							\
	"NOTAG",							\
	"NOTAG_USEREQ",							\
	"EQUIV",							\
	"EQUIV_VAR",							\
	"INT",								\
	"CHAR",								\
	"FLOAT",							\
	"STRING",							\
	"PRED",								\
	"UNIV",								\
	"VOID",								\
	"C_POINTER",							\
	"TYPEINFO",							\
	"TYPECLASSINFO",						\
	"ARRAY",							\
	"SUCCIP",							\
	"HP",								\
	"CURFR",							\
	"MAXFR",							\
	"REDOFR",							\
	"REDOIP",							\
	"TRAIL_PTR",							\
	"TICKET",							\
	"NOTAG_GROUND",							\
	"NOTAG_GROUND_USEREQ",						\
	"EQUIV_GROUND",							\
	"UNKNOWN"

#define	MR_type_ctor_rep_is_basically_du(rep)				\
	(  ((rep) == MR_TYPECTOR_REP_ENUM)				\
	|| ((rep) == MR_TYPECTOR_REP_ENUM_USEREQ)			\
	|| ((rep) == MR_TYPECTOR_REP_DU)				\
	|| ((rep) == MR_TYPECTOR_REP_DU_USEREQ)				\
	|| ((rep) == MR_TYPECTOR_REP_NOTAG)				\
	|| ((rep) == MR_TYPECTOR_REP_NOTAG_USEREQ)			\
	|| ((rep) == MR_TYPECTOR_REP_NOTAG_GROUND)			\
	|| ((rep) == MR_TYPECTOR_REP_NOTAG_GROUND_USEREQ))

/*
** If the MR_TypeCtorRep is MR_TYPE_CTOR_REP_DU{,_USEREQ},
** we have a discriminated union type which is not a no-tag type or
** an enumeration. Each tag may have a different representation.
*/

typedef enum MR_DiscUnionTagRepresentation {
	MR_DISCUNIONTAG_SHARED_LOCAL,
	MR_DISCUNIONTAG_UNSHARED,
	MR_DISCUNIONTAG_SHARED_REMOTE
} MR_DiscUnionTagRepresentation;

/*
** Return the tag representation used by the data with the given
** entry in the type_ctor_layout table.
*/

MR_DiscUnionTagRepresentation MR_get_tag_representation(Word layout_entry);

/*---------------------------------------------------------------------------*/

typedef	Word *	MR_TypeCtorFunctors;
typedef	Word *	MR_TypeCtorLayout;

	/*
	** Macros for retrieving things from type_ctor_infos.
	**
	** XXX zs: these macros should be deleted; the code using them
	** would be clearer if it referred to TypeCtorInfo fields directly.
	*/

#define MR_TYPE_CTOR_INFO_GET_TYPE_ARITY(TypeCtorInfo)			\
	((TypeCtorInfo)->arity)

/*---------------------------------------------------------------------------*/

/*
** The argument number gives the offset in the cell (in a form in which
** it can be given to the MR_field macro directly) of either of the typeinfo
** itself or of the typeclassinfo containing the typeinfo. If the former,
** the offset field will be negative; otherwise, it will be an integer
** which can be given as a second argument to the MR_typeclass_info_type_info
** macro.
*/

typedef	struct {
	MR_int_least16_t	MR_exist_arg_num;
	MR_int_least16_t	MR_exist_offset_in_tci;
} MR_DuExistLocn;

/*
** This structure contains information about the typeinfos of the
** existentially quantified type variables occurring in the types of some
** of the arguments of a functor in a du type.
** 
** The num_typeinfos_plain gives the number of typeinfos directly inserted
** at the start of the memory cell of the functor, while the num_tcis field
** gives the number of typeclassinfos inserted after them. The arguments
** visible to the programmer start after these two blocks, which means that
** when accessing them, one must add the sum of num_typeinfos_plain and
** num_tcis to the visible argument number in order to arrive at an offset
** in the cell.
**
** It is possible for a typeclassinfo to contain more than one type variable.
** The num_typeinfos_in_tci field contains the total number of typeinfos stored
** inside the typeclassinfos of the cell.
**
** The typeinfo_locns field points to an array of MR_ExistTypeInfoLocns.
** This array has num_typeinfos_plain + num_typeinfos_in_tci elements,
** each one of which describes the location (directly in the cell or indirectly
** inside a typeclassinfo) of the typeinfo for an existentially quantified
** type variable. The typeinfo for type variable N will be at the offset
** N - MR_PSEUDOTYPEINFO_EXIST_VAR_BASE - 1. (The one is subtracted to convert
** from type var numbering, which starts at 1, to array offset numbering).
*/

typedef	struct {
	MR_int_least16_t	MR_exist_typeinfos_plain;
	MR_int_least16_t	MR_exist_typeinfos_in_tci;
	MR_int_least16_t	MR_exist_tcis;
	const MR_DuExistLocn	*MR_exist_typeinfo_locns;
} MR_DuExistInfo;

/*
** This type describes the implementation of a function symbol
** from a (proper) discriminated union type, whether it has standard
** or user-defined-equality.
**
** Functor descriptors are reachable from both the layout and functor tables.
** They all the information one may need about the function symbol, even
** though some of this information may be redundant along some access paths.
** 
** The fields that you are likely to be interested in when you arrive at the
** functor descriptor through the functor table are clustered at the front,
** the fields that you are likely to be interested in when you arrive at the
** functor descriptor through the layout table are clustered at the back.
** This is an attempt to optimize cache effectiveness.
**
** The primary and secondary fields give the corresponding tag values, and
** the sectag_locn field gives the location of the secondary tag.
**
** The ordinal field gives the position of the function symbol in the
** list of function symbols of the type; one function symbol compares
** as less than another iff its ordinal number is smaller.
** 
** The orig_arity field records the visible arity of the functor, without
** the typeinfos and/or typeclass_infos added for existentially typed
** arguments.
**
** The arg_types field points to an array of pseudo typeinfos, one for each
** visible argument.
**
** The arg_type_contains_var field contains a bit vector which has one bit
** for each of the first N (currently N=15) arguments, and one bit shared
** between all the other arguments. One of the first N bits is set iff
** the type of the corresponding argument contains a type variable, while
** the last bit is set iff the types of any of the remaining arguments
** contains a type variable.
** This field is meant to be used only via the MR_arg_type_may_contain_var
** and MR_any_arg_type_may_contain_var macros below. In the absence of
** compiler-recorded information, these macros return conservative answers
** for any argument whose type is not represented in this bit vector.
**
** The arg_name field points to an array of field names, one for each
** visible argument. If no argument has a name, this field will be NULL.
**
** If the functor has any arguments whose types include existentially
** quantified type variables, the exist_info field will point to information
** about those type variable; otherwise, the exist_info field will be NULL.
*/

typedef	enum {
	MR_SECTAG_NONE,
	MR_SECTAG_LOCAL,
	MR_SECTAG_REMOTE
} MR_Sectag_Locn;

typedef struct {
	ConstString		MR_du_functor_name;
	MR_int_least16_t	MR_du_functor_orig_arity;
	MR_int_least16_t	MR_du_functor_arg_type_contains_var;
	MR_Sectag_Locn		MR_du_functor_sectag_locn;
	MR_int_least8_t		MR_du_functor_primary;
	MR_int_least32_t	MR_du_functor_secondary;
	MR_int_least32_t	MR_du_functor_ordinal;
	MR_PseudoTypeInfo	*MR_du_functor_arg_types;
	const ConstString	*MR_du_functor_arg_names;
	const MR_DuExistInfo	*MR_du_functor_exist_info;
} MR_DuFunctorDesc;

/*
** This macro represents the number of bits in the
** MR_du_functor_arg_type_contains_var field of a MR_DuFunctorDesc.
** It should be kept in sync with contains_var_bit_vector_size
** in base_type_layout.m.
*/

#define	MR_ARG_TYPE_CONTAINS_VAR_BIT_VECTOR_SIZE	16

#define	MR_arg_has_own_contain_var_bit(arg_num)				     \
	((arg_num) < MR_ARG_TYPE_CONTAINS_VAR_BIT_VECTOR_SIZE - 1)

#define	MR_initial_arg_type_may_contain_var(functor_desc, arg_num)	     \
	(((functor_desc)->MR_du_functor_arg_type_contains_var &		     \
	 	(1 << (arg_num))) != 0)

#define	MR_later_arg_type_may_contain_var(functor_desc)			     \
	(((functor_desc)->MR_du_functor_arg_type_contains_var &		     \
	 	(1 << (MR_ARG_TYPE_CONTAINS_VAR_BIT_VECTOR_SIZE - 1))) != 0)

#define MR_arg_type_may_contain_var(functor_desc, arg_num)		     \
	( MR_arg_has_own_contain_var_bit(arg_num)			     \
	? MR_initial_arg_type_may_contain_var((functor_desc), (arg_num))     \
	: MR_later_arg_type_may_contain_var(functor_desc))

#define	MR_some_arg_type_contains_var(functor_desc)			     \
	((functor_desc)->MR_du_functor_arg_type_contains_var > 0)

/*---------------------------------------------------------------------------*/

typedef struct {
	ConstString		MR_enum_functor_name;
	MR_int_least32_t	MR_enum_functor_ordinal;
} MR_EnumFunctorDesc;

/*---------------------------------------------------------------------------*/

typedef struct {
	ConstString		MR_notag_functor_name;
	MR_PseudoTypeInfo	MR_notag_functor_arg_type;
} MR_NotagFunctorDesc;

/*---------------------------------------------------------------------------*/

/*
** This type describes the function symbols that share the same primary tag.
** The sharers field gives their number, and thus also the size
** of the array of pointers to functor descriptors pointed to by the
** alternatives field.
**
** The intention is that if you have a word in a DU type that you want to
** interpret, you compute its primary tag and find its MR_DuPtagLayout.
** You then look at the locn field. If it is MR_SECTAG_NONE, you index
** the alternatives field with zero; if it is MR_SECTAG_{LOCAL,REMOTE}, you
** compute the secondary tag and index the alternatives field with that.
**
** A value of type MR_DuTypeLayout points to an array of MR_DuPtagLayout
** structures. The element at index k gives information about primary tag
** value k. The size of the array is recorded in the num_ptags field of the
** type_ctor_info.
*/

typedef	struct {
	MR_int_least32_t	MR_sectag_sharers;
	MR_Sectag_Locn		MR_sectag_locn;
	MR_DuFunctorDesc	**MR_sectag_alternatives;
} MR_DuPtagLayout;

typedef	MR_DuPtagLayout		*MR_DuTypeLayout;

/*---------------------------------------------------------------------------*/

/*
** This type describes the function symbols in an enum type.
**
** An MR_EnumLayout points to an array of pointers to functor descriptors.
** There is one pointer for each function symbol, and thus the size of
** the array is given by the num_functors field of the type_ctor_info.
** The array is ordered on the integer value by which the functor is
** represented.
**
** The intention is that if you have a word in an enum type that you want to
** interpret, you index into the array with the word.
*/

typedef	MR_EnumFunctorDesc	**MR_EnumTypeLayout;

/*---------------------------------------------------------------------------*/

/*
** This type describes the single function symbol in a notag type.
**
** An MR_NotagLayout points to the one functor descriptor of the type.
**
** The intention is that if you have a word in a notag type that you want to
** interpret, you look at the given functor descriptor.
*/

typedef	MR_NotagFunctorDesc	*MR_NotagTypeLayout;

/*---------------------------------------------------------------------------*/

/*
** This type describes the identity of the type that an equivalence type
** is equivalent to, and hence its layout.
**
** An MR_NotagLayout gives the pseudo typeinfo of the type that this type
** is equivalent to.
**
** The intention is that if you have a word in an equivalence type that you
** want to interpret, you expand the pseudo typeinfo into a real typeinfo,
** and then use that to interpret the word.
*/

typedef	MR_PseudoTypeInfo	MR_EquivLayout;

/*---------------------------------------------------------------------------*/

/*
** This type describes the layout in any kind of discriminated union
** type: du, enum and notag. In an equivalence type, it gives the identity
** of the equivalent-to type.
** 
** The layout_init alternative is used only for static initializers,
** because ANSI C89 does not allow you to say which member of a union
** you are initializing, and instead forces you to initialize the first member.
** When we can rely on C99 compilers, layout_init should no longer be needed.
*/

typedef	union {
	void			*layout_init;
	MR_DuTypeLayout		layout_du;
	MR_EnumTypeLayout	layout_enum;
	MR_NotagTypeLayout	layout_notag;
	MR_EquivLayout		layout_equiv;
} MR_TypeLayout;

/*---------------------------------------------------------------------------*/

/*
** This type describes the function symbols in any kind of discriminated union
** type: du, enum and notag.
**
** The pointer points to an array of pointers to functor descriptors.
** There is one pointer for each function symbol, and thus the size of
** the array is given by the num_alternatives field of the type_ctor_info.
** The array is ordered on the name of the function symbol, and then on arity.
**
** The intention is that if you have a function symbol you want to represent,
** you can do binary search on the array for the symbol name and arity.
** 
** The functors_init alternative is used only for static initializers;
** see the comment for MR_TypeLayout above.
*/

typedef	union {
	void			*functors_init;
	MR_DuFunctorDesc	**functors_du;
	MR_EnumFunctorDesc	**functors_enum;
	MR_NotagFunctorDesc	*functors_notag;
} MR_TypeFunctors;

/*---------------------------------------------------------------------------*/

	/*
	** Structs defining the structure of type_ctor_infos.
	** A type_ctor_info describes the structure of a particular
	** type constructor.  One of these is generated for every
	** `:- type' declaration.
	**
	** The offsets of the fields in this structure must match the
	** offset macros defines near the top of this file.
	*/

struct MR_TypeCtorInfo_Struct {
	Integer				arity;
	Code				*unify_pred;
	Code				*index_pred;
	Code				*compare_pred;
	MR_TypeCtorRep			type_ctor_rep;
/*
** The type_ctor_functors and type_ctor_layout fields have been replaced
** by the type_ctor_num_functors, type_functors and type_layout fields.
** They are present only for backward compatibility. Once that is not needed
** anymore, those two slots will contain stuff for HAL:
**
**	Code				*solver_pred;
**	Code				*init_pred;
*/
	MR_TypeCtorFunctors		type_ctor_functors;
	MR_TypeCtorLayout		type_ctor_layout;
	ConstString			type_ctor_module_name;
	ConstString			type_ctor_name;
	Integer				type_ctor_version;
	MR_TypeFunctors			type_functors;
	MR_TypeLayout			type_layout;
	MR_int_least32_t		type_ctor_num_functors;
	MR_int_least8_t			type_ctor_num_ptags;	/* if DU */

/*
** The following fields will be added later, once we can exploit them:
**	union MR_TableNode_Union	**type_std_table;
**	Code				*prettyprinter;
*/
};

typedef struct MR_TypeCtorInfo_Struct *MR_TypeCtorInfo;

/*---------------------------------------------------------------------------*/

/*
** Macros to help the runtime and the library create type_ctor_info
** structures for builtin and special types.
*/

#define	MR_DEFINE_BUILTIN_TYPE_CTOR_INFO_FULL(m, cm, n, a, cr, u, i, c)	\
	Declare_entry(u);						\
	Declare_entry(i);						\
	Declare_entry(c);						\
	MR_STATIC_CODE_CONST struct MR_TypeCtorInfo_Struct		\
	MR_PASTE6(mercury_data_, cm, __type_ctor_info_, n, _, a) = {	\
		a,							\
		MR_MAYBE_STATIC_CODE(ENTRY(u)),				\
		MR_MAYBE_STATIC_CODE(ENTRY(i)),				\
		MR_MAYBE_STATIC_CODE(ENTRY(c)),				\
		cr,							\
		NULL,							\
		NULL,							\
		MR_string_const(MR_STRINGIFY(m), sizeof(MR_STRINGIFY(m))-1),\
		MR_string_const(MR_STRINGIFY(n), sizeof(MR_STRINGIFY(n))-1),\
		MR_RTTI_VERSION,					\
		{ 0 },							\
		{ 0 },							\
		-1,							\
		-1							\
	}

#define	MR_DEFINE_BUILTIN_TYPE_CTOR_INFO_PRED(m, n, a, cr, u, i, c)	\
	MR_DEFINE_BUILTIN_TYPE_CTOR_INFO_FULL(m, m, n, a, cr, u, i, c)

#define	MR_DEFINE_BUILTIN_TYPE_CTOR_INFO(m, n, a, cr)			\
	MR_DEFINE_BUILTIN_TYPE_CTOR_INFO_FULL(m, m, n, a, cr,		\
		MR_PASTE7(mercury____Unify___, m, __, n, _, a, _0),	\
		MR_PASTE7(mercury____Index___, m, __, n, _, a, _0),	\
		MR_PASTE7(mercury____Compare___, m, __, n, _, a, _0))

#define	MR_DEFINE_BUILTIN_TYPE_CTOR_INFO_UNUSED(n, a, cr)		\
	MR_DEFINE_BUILTIN_TYPE_CTOR_INFO_FULL(builtin, , n, a, cr,	\
		mercury__unused_0_0,					\
		mercury__unused_0_0,					\
		mercury__unused_0_0)

/*---------------------------------------------------------------------------*/

extern	int	MR_compare_type_info(Word, Word);
extern	Word	MR_collapse_equivalences(Word);

/*
** Functions for creating type_infos from pseudo_type_infos.
** See mercury_type_info.c for documentation on these.
*/

extern	Word	*MR_create_type_info(const Word * term_type_info,
			const Word *arg_pseudo_type_info);
extern	Word	*MR_create_type_info_maybe_existq(const Word *term_type_info,
			const Word *arg_pseudo_type_info,
			const Word *data_value, int rtti_version,
			const MR_DuFunctorDesc *functor_descriptor);

/* for MR_make_type_info(), we keep a list of allocated memory cells */
struct MR_MemoryCellNode {
	void				*data;
	struct MR_MemoryCellNode	*next;
};

typedef struct MR_MemoryCellNode *MR_MemoryList;

extern	Word	*MR_make_type_info(const Word *term_type_info,
			const Word *arg_pseudo_type_info,
			MR_MemoryList *allocated);
extern	Word	*MR_make_type_info_maybe_existq(const Word *term_type_info,
			const Word *arg_pseudo_type_info,
			const Word *data_value, int rtti_version,
			const MR_DuFunctorDesc *functor_descriptor,
			MR_MemoryList *allocated) ;
extern	void	MR_deallocate(MR_MemoryList allocated_memory_cells);

/*---------------------------------------------------------------------------*/

#endif /* not MERCURY_TYPEINFO_H */

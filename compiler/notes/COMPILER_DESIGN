This file contains various notes about the design of the compiler.
The top-level of the compiler is in the file mercury_compile.m.
The overall structure for the compiler is as follows:

1. lexical analysis & stage 1 parsing - convert strings to terms
   (lexer.m, parser.m).

2. stage 2 parsing - convert terms to declarations, clauses, etc.
   result of this stage has a one-to-one correspondence with
   the source code
   (prog_io.m)

3. simplify - convert parse tree to simplified high-level data structure
   (including conversion to superhomogeneous form) and construct symbol
   tables (make_hlds.m); also handle imports and exports (done in
   mercury_compile.m)

4. type checking, overloading resolution & module name resolution
   fully qualify all names
   (typecheck.m)

5. mode analysis (modes.m - plus the sub-modules mode_info.m, mode_util.m,
				inst_match.m, and delay_info.m),
   common goal hoisting (cse_detection.m)
	(this is here because it needs to be done before switch_detection
	so that we can do deep indexing)
   switch detection (switch_detection.m),
   inlining (inlining.m),
	(note that inlining does not affect the results of determinism
	analysis - the only reason it comes before determinism analysis
	is because it happens to be easier)
   determinism analysis (det_analysis.m),

6. code generation.  This comprises several subpasses:
	recognization of builtins (builtins.m),
	migration of builtins following branched structures (followvars.m),
	allocation of stack slots (store_alloc.m)
	allocation of variable targets following branched structures
		(followvars.m)
	code generation (codegen.m).

7. various LLDS-to-LLDS optimizations (optimize.m), including
	optimization of jumps to jumps (jumpopt.m)
	elimination of duplicate code sequences (dupelim.m)
	optimization of stack frame allocation/deallocation (frameopt.m)
	dead code removal (labelopt.m)
	value numbering (value_number.m, vn_*.m)
	peephole optimization (peephole.m)

8. output C code (llds.m).


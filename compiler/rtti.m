%-----------------------------------------------------------------------------%
% Copyright (C) 2000 The University of Melbourne.
% This file may only be copied under the terms of the GNU General
% Public License - see the file COPYING in the Mercury distribution.
%-----------------------------------------------------------------------------%
%
% Definitions of data structures for representing run-time type information
% within the compiler. When output by rtti_out.m, values of most these types
% will correspond to the types defined in runtime/mercury_type_info.h;
% the documentation of those types can be found there.
%
% Eventually, this module will be independent of whether we are compiling
% to LLDS or MLDS. For the time being, it depends on LLDS.
%
% Author: zs.

%-----------------------------------------------------------------------------%

:- module rtti.

:- interface.

:- import_module llds, prog_data.
:- import_module bool, list, std_util.

	% For a given du type and a primary tag value, this says where,
	% if anywhere, the secondary tag is.
:- type sectag_locn
	--->	sectag_none
	;	sectag_local
	;	sectag_remote.

	% For a given du family type, this says whether the user has defined
	% their own unification predicate.
:- type equality_axioms
	--->	standard
	;	user_defined.

	% For a notag or equiv type, this says whether the target type
	% contains variables or not.
:- type equiv_type_inst
	--->	equiv_type_is_ground
	;	equiv_type_is_not_ground.

	% The compiler is concerned with the type constructor representations
	% of only the types it generates RTTI information for; it need not and
	% does not know about the type_ctor_reps of types which have
	% hand-defined RTTI.
:- type type_ctor_rep
	--->	enum(equality_axioms)
	;	du(equality_axioms)
	;	notag(equality_axioms, equiv_type_inst)
	;	equiv(equiv_type_inst)
	;	unknown.

	% Different kinds of types have different type_layout information
	% generated for them, and some have no type_layout info at all.
	% This type represents values that will be put into the type_layout
	% field of a MR_TypeCtorInfo.
:- type type_ctor_layout_info
	--->	enum_layout(
			rtti_name
		)
	;	notag_layout(
			rtti_name
		)
	;	du_layout(
			rtti_name
		)
	;	equiv_layout(
			rval
		)
	;	no_layout.

	% Different kinds of types have different type_functors information
	% generated for them, and some have no type_functors info at all.
	% This type represents values that will be put into the type_functors
	% field of a MR_TypeCtorInfo.
:- type type_ctor_functors_info
	--->	enum_functors(
			rtti_name
		)
	;	notag_functors(
			rtti_name
		)
	;	du_functors(
			rtti_name
		)
	;	no_functors.

	% This type corresponds to the C type MR_DuExistLocn.
:- type exist_typeinfo_locn
	--->	plain_typeinfo(
			int			% The typeinfo is stored
						% directly in the cell, at this
						% offset.
		)
	;	typeinfo_in_tci(
			int,			% The typeinfo is stored
						% indirectly in the typeclass
						% info stored at this offset
						% in the cell.
			int			% To find the typeinfo inside
						% the typeclass info structure,
						% give this integer to the
						% MR_typeclass_info_type_info
						% macro.
		).

	% This type corresponds to the MR_DuPtagTypeLayout C type.
:- type du_ptag_layout
	--->	du_ptag_layout(
			int,			% number of function symbols
						% sharing this primary tag
			sectag_locn,
			rtti_name		% a vector of size num_sharers;
						% element N points to the
						% functor descriptor for the
						% functor with secondary tag S;
						% if sectag_locn is none, S=0
		).

	% Values of this type uniquely identify a type in the program.
:- type rtti_type_id
	--->	rtti_type_id(
			module_name,		% module name
			string,			% type ctor's name
			arity			% type ctor's arity
		).

	% Global data generated by the compiler. Usually readonly,
	% with one exception: data containing code addresses must
	% be initialized at runtime in grades that don't support static
	% code initializers.
:- type rtti_data
	--->	exist_locns(
			rtti_type_id,		% identifies the type
			int,			% identifies functor in type

			% The remaining argument of this function symbol
			% corresponds to an array of MR_ExistTypeInfoLocns.

			list(exist_typeinfo_locn)
		)
	;	exist_info(
			rtti_type_id,		% identifies the type
			int,			% identifies functor in type

			% The remaining arguments of this function symbol
			% correspond to the MR_DuExistInfo C type.

			int,			% number of plain typeinfos
			int,			% number of typeinfos in tcis
			int,			% number of tcis
			rtti_name		% table of typeinfo locations
		)
	;	field_names(
			rtti_type_id,		% identifies the type
			int,			% identifies functor in type

			list(maybe(string))	% gives the field names
		)
	;	enum_functor_desc(
			rtti_type_id,		% identifies the type

			% The remaining arguments of this function symbol
			% correspond one-to-one to the fields of
			% MR_EnumFunctorDesc.

			string,			% functor name
			int			% ordinal number of functor
						% (also its value)
		)
	;	notag_functor_desc(
			rtti_type_id,		% identifies the type

			% The remaining arguments of this function symbol
			% correspond one-to-one to the fields of
			% the MR_NotagFunctorDesc C type.

			string,			% functor name
			rval			% pseudo typeinfo of argument
		)
	;	du_functor_desc(
			rtti_type_id,		% identifies the type

			% The remaining arguments of this function symbol
			% correspond one-to-one to the fields of
			% the MR_DuFunctorDesc C type.

			string,			% functor name
			int,			% functor primary tag
			int,			% functor secondary tag
			sectag_locn,
			int,			% ordinal number of functor
						% in type definition
			arity,			% the functor's visible arity
			int,			% a bit vector of size at most
						% contains_var_bit_vector_size
						% which contains a 1 bit in the
						% position given by 1 << N if
						% the type of argument N
						% contains variables (assuming
						% that arguments are numbered
						% from zero)
			rval,			% a vector of length arity
						% containing the pseudo
						% typeinfos of the arguments
			maybe(rtti_name),	% possibly a vector of length
						% arity containing the names
						% of the arguments, if any
			maybe(rtti_name)	% information about the
						% existentially quantified
						% type variables, if any
		)
	;	enum_name_ordered_table(
			rtti_type_id,		% identifies the type

			% The remaining argument of this function symbol
			% corresponds to the functors_enum alternative of
			% the MR_TypeFunctors C type.

			list(rtti_name)
		)	
	;	enum_value_ordered_table(
			rtti_type_id,		% identifies the type

			% The remaining argument of this function symbol
			% corresponds to the MR_EnumTypeLayout C type.

			list(rtti_name)
		)	
	;	du_name_ordered_table(
			rtti_type_id,		% identifies the type

			% The remaining argument of this function symbol
			% corresponds to the functors_du alternative of
			% the MR_TypeFunctors C type.

			list(rtti_name)
		)	
	;	du_stag_ordered_table(
			rtti_type_id,		% identifies the type
			int,			% primary tag value

			% The remaining argument of this function symbol
			% corresponds to the MR_sectag_alternatives field
			% of the MR_DuPtagTypeLayout C type.

			list(rtti_name)
		)	
	;	du_ptag_ordered_table(
			rtti_type_id,		% identifies the type

			% The remaining argument of this function symbol
			% corresponds to the elements of the MR_DuTypeLayout
			% C type.

			list(du_ptag_layout)
		)	
	;	type_ctor_info(
			% The arguments of this function symbol correspond
			% one-to-one to the fields of the MR_TypeCtorInfo
			% C type.

			rtti_type_id,		% identifies the type
			maybe(code_addr),	% unify
			maybe(code_addr),	% index
			maybe(code_addr),	% compare
			type_ctor_rep,
			maybe(code_addr),	% solver
			maybe(code_addr),	% init
			int,			% RTTI version number
			int,			% num of ptags used if ctor_rep
						% is DU or DUUSEREQ
			int,			% number of functors in type
			type_ctor_functors_info,% the functor layout
			type_ctor_layout_info,	% the layout table
			maybe(rtti_name),	% the type's hash cons table
			maybe(code_addr)	% prettyprinter
		).

:- type rtti_name
	--->	exist_locns(int)		% functor ordinal
	;	exist_info(int)			% functor ordinal
	;	field_names(int)		% functor ordinal
	;	enum_functor_desc(int)		% functor ordinal
	;	notag_functor_desc
	;	du_functor_desc(int)		% functor ordinal
	;	enum_name_ordered_table
	;	enum_value_ordered_table
	;	du_name_ordered_table
	;	du_stag_ordered_table(int)	% primary tag
	;	du_ptag_ordered_table
	;	type_ctor_info
	;	type_hashcons_pointer.

	% Return the C variable name of the RTTI data structure identified
	% by the input arguments.

:- pred rtti__addr_to_string(rtti_type_id::in, rtti_name::in, string::out)
	is det.

	% Return the C representation of a secondary tag location.

:- pred rtti__sectag_locn_to_string(sectag_locn::in, string::out) is det.

	% Return the C representation of a type_ctor_rep value.

:- pred rtti__type_ctor_rep_to_string(type_ctor_rep::in, string::out) is det.

	% Return true iff the given type of RTTI data structure includes
	% code addresses.

:- pred rtti__name_would_include_code_address(rtti_name::in, bool::out) is det.

:- implementation.

:- import_module llds_out.
:- import_module string.

rtti__addr_to_string(RttiTypeId, RttiName, Str) :-
	RttiTypeId = rtti_type_id(ModuleName0, TypeName0, TypeArity),
	llds_out__sym_name_mangle(ModuleName0, ModuleName),
	llds_out__name_mangle(TypeName0, TypeName),
	string__int_to_string(TypeArity, A_str),
	(
		RttiName = exist_locns(Ordinal),
		string__int_to_string(Ordinal, O_str),
		string__append_list([ModuleName, "__exist_locns_",
			TypeName, "_", A_str, "_", O_str], Str)
	;
		RttiName = exist_info(Ordinal),
		string__int_to_string(Ordinal, O_str),
		string__append_list([ModuleName, "__exist_info_",
			TypeName, "_", A_str, "_", O_str], Str)
	;
		RttiName = field_names(Ordinal),
		string__int_to_string(Ordinal, O_str),
		string__append_list([ModuleName, "__field_names_",
			TypeName, "_", A_str, "_", O_str], Str)
	;
		RttiName = enum_functor_desc(Ordinal),
		string__int_to_string(Ordinal, O_str),
		string__append_list([ModuleName, "__enum_functor_desc_",
			TypeName, "_", A_str, "_", O_str], Str)
	;
		RttiName = notag_functor_desc,
		string__append_list([ModuleName, "__notag_functor_desc_",
			TypeName, "_", A_str], Str)
	;
		RttiName = du_functor_desc(Ordinal),
		string__int_to_string(Ordinal, O_str),
		string__append_list([ModuleName, "__du_functor_desc_",
			TypeName, "_", A_str, "_", O_str], Str)
	;
		RttiName = enum_name_ordered_table,
		string__append_list([ModuleName, "__enum_name_ordered_",
			TypeName, "_", A_str], Str)
	;
		RttiName = enum_value_ordered_table,
		string__append_list([ModuleName, "__enum_value_ordered_",
			TypeName, "_", A_str], Str)
	;
		RttiName = du_name_ordered_table,
		string__append_list([ModuleName, "__du_name_ordered_",
			TypeName, "_", A_str], Str)
	;
		RttiName = du_stag_ordered_table(Ptag),
		string__int_to_string(Ptag, P_str),
		string__append_list([ModuleName, "__du_stag_ordered_",
			TypeName, "_", A_str, "_", P_str], Str)
	;
		RttiName = du_ptag_ordered_table,
		string__append_list([ModuleName, "__du_ptag_ordered_",
			TypeName, "_", A_str], Str)
	;
		RttiName = type_ctor_info,
		string__append_list([ModuleName, "__type_ctor_info_",
			TypeName, "_", A_str], Str)
	;
		RttiName = type_hashcons_pointer,
		string__append_list([ModuleName, "__hashcons_ptr_",
			TypeName, "_", A_str], Str)
	).

rtti__sectag_locn_to_string(sectag_none,   "MR_SECTAG_NONE").
rtti__sectag_locn_to_string(sectag_local,  "MR_SECTAG_LOCAL").
rtti__sectag_locn_to_string(sectag_remote, "MR_SECTAG_REMOTE").

rtti__type_ctor_rep_to_string(du(standard),
	"MR_TYPECTOR_REP_DU").
rtti__type_ctor_rep_to_string(du(user_defined),
	"MR_TYPECTOR_REP_DU_USEREQ").
rtti__type_ctor_rep_to_string(enum(standard),
	"MR_TYPECTOR_REP_ENUM").
rtti__type_ctor_rep_to_string(enum(user_defined),
	"MR_TYPECTOR_REP_ENUM_USEREQ").
rtti__type_ctor_rep_to_string(notag(standard, equiv_type_is_not_ground),
	"MR_TYPECTOR_REP_NOTAG").
rtti__type_ctor_rep_to_string(notag(user_defined, equiv_type_is_not_ground),
	"MR_TYPECTOR_REP_NOTAG_USEREQ").
rtti__type_ctor_rep_to_string(notag(standard, equiv_type_is_ground),
	"MR_TYPECTOR_REP_NOTAG_GROUND").
rtti__type_ctor_rep_to_string(notag(user_defined, equiv_type_is_ground),
	"MR_TYPECTOR_REP_NOTAG_GROUND_USEREQ").
rtti__type_ctor_rep_to_string(equiv(equiv_type_is_not_ground),
	"MR_TYPECTOR_REP_EQUIV").
rtti__type_ctor_rep_to_string(equiv(equiv_type_is_ground),
	"MR_TYPECTOR_REP_EQUIV_GROUND").
rtti__type_ctor_rep_to_string(unknown,
	"MR_TYPECTOR_REP_UNKNOWN").

rtti__name_would_include_code_address(exist_locns(_),            no).
rtti__name_would_include_code_address(exist_info(_),             no).
rtti__name_would_include_code_address(field_names(_),            no).
rtti__name_would_include_code_address(enum_functor_desc(_),      no).
rtti__name_would_include_code_address(notag_functor_desc,        no).
rtti__name_would_include_code_address(du_functor_desc(_),        no).
rtti__name_would_include_code_address(enum_name_ordered_table,   no).
rtti__name_would_include_code_address(enum_value_ordered_table,  no).
rtti__name_would_include_code_address(du_name_ordered_table,     no).
rtti__name_would_include_code_address(du_stag_ordered_table(_),  no).
rtti__name_would_include_code_address(du_ptag_ordered_table,     no).
rtti__name_would_include_code_address(type_ctor_info,            yes).
rtti__name_would_include_code_address(type_hashcons_pointer,     no).

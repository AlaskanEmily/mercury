%-----------------------------------------------------------------------------%
% vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
%-----------------------------------------------------------------------------%
% Copyright (C) 2005 The University of Melbourne.
% This file may only be copied under the terms of the GNU General
% Public License - see the file COPYING in the Mercury distribution.
%-----------------------------------------------------------------------------%
%
% File: trace_counts.m.
%
% Main author: wangp.
% Modifications by zs.
%
% This module defines predicates to read in the execution trace summaries
% generated by programs compiled using the compiler's tracing options.

%-----------------------------------------------------------------------------%

:- module mdbcomp.trace_counts.

:- interface.

:- import_module mdbcomp.prim_data.
:- import_module mdbcomp.program_representation.

:- import_module assoc_list.
:- import_module io.
:- import_module list.
:- import_module map.

:- type trace_count_file_type
    --->    user_all
            % The file contains counts for all labels from user-defined
            % procedures.

    ;       user_nonzero.
            % The file contains counts for all labels from user-defined
            % procedures, provided the count is nonzero.

:- type trace_counts        == map(proc_label, proc_trace_counts).

:- type proc_trace_counts   == map(path_port, context_and_count).

:- type path_port
    --->    port_only(trace_port)
    ;       path_only(goal_path)
    ;       port_and_path(trace_port, goal_path).

:- type context_and_count
    --->    context_and_count(
                file_name   :: string,
                line_number :: int,
                exec_count  :: int
            ).

:- pred summarize_trace_counts_list(list(trace_counts)::in, trace_counts::out)
    is det.

:- pred sum_trace_counts(trace_counts::in, trace_counts::in, trace_counts::out)
    is det.

%-----------------------------------------------------------------------------%

:- type read_trace_counts_result
    --->    ok(trace_count_file_type, trace_counts)
    ;       syntax_error(string)
    ;       error_message(string)
    ;       open_error(io__error)
    ;       io_error(io__error).

    % read_trace_counts(FileName, Result, !IO):
    %
    % Read in the trace counts stored in FileName.
    %
:- pred read_trace_counts(string::in, read_trace_counts_result::out,
    io::di, io::uo) is det.

:- type read_trace_counts_list_result
    --->    list_ok(assoc_list(trace_count_file_type, trace_counts))
    ;       list_error_message(string).

    % read_trace_counts_list(FileName, Result, !IO):
    %
    % Read the trace_counts in the files whose names appear in FileName.
    %
:- pred read_trace_counts_list(string::in, read_trace_counts_list_result::out,
    io::di, io::uo) is det.

:- type slice_source
    --->    file_list
    ;       single_file
    ;       try_single_first.

    % read_trace_counts_source(Source, FileName, Result, !IO):
    %
    % Read in trace counts stored in one or more trace count files.
    %
    % If Source is file_list, then FileName should contain a list of filenames,
    % and read_trace_counts_source will read in the trace counts from each
    % of those files.
    %
    % If Source is single_file, then FileName should itself be a file
    % containing trace counts data.
    %
    % If Source is try_single_first, then read_trace_counts_source will
    % check to see if FileName contains trace counts data. If yes, it will
    % get trace counts from there. If not, read_trace_counts_source will
    % interpret FileName as a file that itself contains filenames, and
    % will treat it as with Source=file_list.
    %
:- pred read_trace_counts_source(slice_source::in, string::in,
    read_trace_counts_list_result::out, io::di, io::uo) is det.

:- pred string_to_trace_port(string, trace_port).
:- mode string_to_trace_port(in, out) is semidet.
:- mode string_to_trace_port(out, in) is det.

:- pred restrict_trace_counts_to_module(module_name::in, trace_counts::in,
    trace_counts::out) is det.

%-----------------------------------------------------------------------------%

:- implementation.

:- import_module char.
:- import_module exception.
:- import_module int.
:- import_module io.
:- import_module lexer.
:- import_module require.
:- import_module set.
:- import_module std_util.
:- import_module string.
:- import_module svmap.

%-----------------------------------------------------------------------------%

summarize_trace_counts_list(TraceCountsList, TraceCounts) :-
    ( TraceCountsList = [TraceCountsPrime] ->
        % optimize the common case
        TraceCounts = TraceCountsPrime
    ;
        list.foldl(sum_trace_counts, TraceCountsList, map.init, TraceCounts)
    ).

sum_trace_counts(TraceCountsA, TraceCountsB, TraceCounts) :-
    map.union(sum_proc_trace_counts, TraceCountsA, TraceCountsB, TraceCounts).

:- pred sum_proc_trace_counts(proc_trace_counts::in, proc_trace_counts::in,
    proc_trace_counts::out) is det.

sum_proc_trace_counts(ProcTraceCountsA, ProcTraceCountsB, ProcTraceCounts) :-
    ProcTraceCounts = map.union(sum_counts_in_context,
        ProcTraceCountsA, ProcTraceCountsB).

:- func sum_counts_in_context(context_and_count, context_and_count)
    = context_and_count.

sum_counts_in_context(CC1, CC2) = CC :-
    % We could add a sanity check that FileName1 = FileName2 and
    % LineNumber1 = LineNumber2, but that would take time to no good purpose,
    % since there isn't much we can do to generate a meaningful message,
    % and that situation doesn't necessarily represent an error anyway.
    % (Consider the case when the two trace files are derived from sources
    % that are identical except for the addition of a comment.)

    CC1 = context_and_count(FileName1, LineNumber1, Count1),
    CC2 = context_and_count(_FileName2, _LineNumber, Count2),
    CC = context_and_count(FileName1, LineNumber1, Count1 + Count2).

%-----------------------------------------------------------------------------%

read_trace_counts_source(Source, FileName, Result, !IO) :-
    (
        Source = file_list,
        read_trace_counts_list(FileName, ListResult, !IO),
        (
            ListResult = list_ok(AssocList),
            Result = list_ok(AssocList)
        ;
            ListResult = list_error_message(Msg),
            Result = list_error_message(Msg)
        )
    ;
        Source = single_file,
        read_trace_counts(FileName, ReadTCResult, !IO),
        (
            ReadTCResult = ok(FileType, TraceCount),
            Result = list_ok([FileType - TraceCount])
        ;
            ReadTCResult = io_error(IOError),
            Result = list_error_message("IO error reading file " ++
                "`" ++ FileName ++ "': " ++ string.string(IOError))
        ;
            ReadTCResult = open_error(IOError),
            Result = list_error_message("IO error opening file " ++
                "`" ++ FileName ++ "': " ++ string.string(IOError))
        ;
            ReadTCResult = syntax_error(Error),
            Result = list_error_message("Syntax error in file `" ++
                FileName ++ "': " ++ Error)
        ;
            ReadTCResult = error_message(Message),
            Result = list_error_message("Error reading trace counts " ++
                "from file `" ++ FileName ++ "': " ++ Message)
        )
    ;
        Source = try_single_first,
        read_trace_counts_source(single_file, FileName, TryResult, !IO),
        (
            TryResult = list_ok(_),
            Result = TryResult
        ;
            TryResult = list_error_message(_),
            read_trace_counts_source(file_list, FileName, Result, !IO)
        )
    ).

read_trace_counts_list(FileName, Result, !IO) :-
    io.open_input(FileName, OpenResult, !IO),
    (
        OpenResult = ok(FileStream),
        read_trace_counts_list_stream(FileName, FileStream, Result, !IO)
    ;
        OpenResult = error(IOError),
        Result = list_error_message("Error opening file `" ++ FileName ++
            "': " ++ string.string(IOError))
    ).

    % Same as read_trace_counts_list/4, but read the filenames containing
    % the trace_counts from the given stream.  MainFileName is the
    % name of the file being read and is only used for error messages.
    %
:- pred read_trace_counts_list_stream(string::in, io.input_stream::in,
    read_trace_counts_list_result::out, io::di, io::uo) is det.

read_trace_counts_list_stream(MainFileName, Stream, Result, !IO) :-
    io.read_line_as_string(Stream, ReadResult, !IO),
    (
        ReadResult = ok(Line),
        % Remove the trailing newline:
        FileName = string.left(Line, string.length(Line) - 1),
        read_trace_counts(FileName, ReadTCResult, !IO),
        (
            ReadTCResult = ok(FileType, TraceCount),
            read_trace_counts_list_stream(MainFileName, Stream, RestResult,
                !IO),
            ( RestResult = list_ok(FileTypesTraceCounts) ->
                Result = list_ok([FileType - TraceCount
                    | FileTypesTraceCounts])
            ;
                Result = RestResult
            )
        ;
            ReadTCResult = io_error(IOError),
            Result = list_error_message("IO error reading file " ++
                "`" ++ FileName ++ "': " ++ string.string(IOError))
        ;
            ReadTCResult = open_error(IOError),
            Result = list_error_message("IO error opening file " ++
                "`" ++ FileName ++ "': " ++ string.string(IOError))
        ;
            ReadTCResult = syntax_error(Error),
            Result = list_error_message("Syntax error in file `" ++ FileName ++
                "': " ++ Error)
        ;
            ReadTCResult = error_message(Message),
            Result = list_error_message("Error reading trace counts " ++
                "from file `" ++ FileName ++ "': " ++ Message)
        )
    ;
        ReadResult = error(Error),
        Result = list_error_message("IO error reading file " ++ "`" ++
            MainFileName ++ "': " ++ string.string(Error))
    ;
        ReadResult = eof,
        Result = list_ok([])
    ).

read_trace_counts(FileName, ReadResult, !IO) :-
    % XXX We should be using zcat here, to avoid deleting the gzipped file
    % and having to recreate it again. Unfortunately, we don't have any
    % facilities equivalent to popen in Unix, and I don't know how to
    % write one in a way that is portable to Windows. zs.
    ( string__remove_suffix(FileName, ".gz", BaseName) ->
        io__call_system("gunzip " ++ FileName, _UnzipResult, !IO),
        ActualFileName = BaseName,
        GzipCmd = "gzip " ++ BaseName
    ;
        ActualFileName = FileName,
        GzipCmd = ""
    ),
    io__open_input(ActualFileName, Result, !IO),
    (
        Result = ok(FileStream),
        io__set_input_stream(FileStream, OldInputStream, !IO),
        io__read_line_as_string(IdReadResult, !IO),
        (
            IdReadResult = ok(FirstLine),
            FirstLine = trace_count_file_id
        ->
            promise_only_solution_io(read_trace_counts_from_cur_stream,
                ReadResult, !IO)
        ;
            ReadResult = syntax_error("no trace count file id")
        ),
        io__set_input_stream(OldInputStream, _, !IO),
        io__close_input(FileStream, !IO)
    ;
        Result = error(IOError),
        ReadResult = open_error(IOError)
    ),
    ( GzipCmd = "" ->
        true
    ;
        io__call_system(GzipCmd, _ZipResult, !IO)
    ).

:- func trace_count_file_id = string.

trace_count_file_id = "Mercury trace counts file\n".

:- pred read_trace_counts_from_cur_stream(read_trace_counts_result::out,
    io::di, io::uo) is cc_multi.

read_trace_counts_from_cur_stream(ReadResult, !IO) :-
    io__read_line_as_string(IdResult, !IO),
    (
        IdResult = ok(IdStr),
        (
            IdStr = "user_all\n",
            FileType = user_all
        ;
            IdStr = "user_nonzero\n",
            FileType = user_nonzero
        )
    ->
        try_io(read_trace_counts_setup(map__init), Result, !IO),
        (
            Result = succeeded(TraceCounts),
            ReadResult = ok(FileType, TraceCounts)
        ;
            Result = exception(Exception),
            ( Exception = univ(IOError) ->
                ReadResult = io_error(IOError)
            ; Exception = univ(Message) ->
                ReadResult = error_message(Message)
            ; Exception = univ(trace_count_syntax_error(Error)) ->
                ReadResult = syntax_error(Error)
            ;
                error("read_trace_counts_from_cur_stream: " ++
                    "unexpected exception type")
            )
        ;
            Result = failed,
            error("read_trace_counts_from_cur_stream: try_io failed")
        )
    ;
        ReadResult = syntax_error("no info on trace count file type")
    ).

:- pred read_trace_counts_setup(trace_counts::in, trace_counts::out,
    io::di, io::uo) is det.

read_trace_counts_setup(!TraceCounts, !IO) :-
    io__get_line_number(LineNumber, !IO),
    io__read_line_as_string(Result, !IO),
    (
        Result = ok(Line),
        CurFileName = "",
        read_proc_trace_counts(LineNumber, Line, CurFileName, !TraceCounts,
            !IO)
    ;
        Result = eof
    ;
        Result = error(Error),
        throw(Error)
    ).

:- type trace_count_syntax_error
    --->    trace_count_syntax_error(string).

:- pred read_proc_trace_counts(int::in, string::in, string::in,
    trace_counts::in, trace_counts::out, io::di, io::uo) is det.

read_proc_trace_counts(HeaderLineNumber, HeaderLine, CurFileName, !TraceCounts,
        !IO) :-
    lexer__string_get_token_list(HeaderLine, string__length(HeaderLine),
        TokenList, posn(HeaderLineNumber, 1, 0), _),
    (
        TokenList =
            token_cons(name("file"), _,
            token_cons(name(NextFileName), _,
            token_nil))
    ->
        io__read_line_as_string(Result, !IO),
        (
            Result = ok(Line),
            io__get_line_number(LineNumber, !IO),
            read_proc_trace_counts(LineNumber, Line, NextFileName,
                !TraceCounts, !IO)
        ;
            Result = eof
        ;
            Result = error(Error),
            throw(Error)
        )
    ;
        TokenList =
            token_cons(name("proc"), _,
            token_cons(name(DefModuleStr), _,
            token_cons(name(PredOrFuncStr), _,
            token_cons(name(DeclModuleStr), _,
            token_cons(name(Name), _,
            token_cons(integer(Arity), _,
            token_cons(integer(Mode), _,
            token_nil))))))),
        string_to_pred_or_func(PredOrFuncStr, PredOrFunc)
    ->
        string_to_sym_name(DefModuleStr, ".", DefModuleName),
        string_to_sym_name(DeclModuleStr, ".", DeclModuleName),
        % At the moment runtime/mercury_trace_base.c doesn't
        % write out data for unify, compare, index or init procedures.
        ProcLabel = proc(DefModuleName, PredOrFunc, DeclModuleName,
                Name, Arity, Mode),
        % For whatever reason some of the trace counts for a single
        % procedure or function can be split over multiple spans.
        % We collate them as if they appeared in a single span.
        ( svmap__remove(ProcLabel, ProbeCounts, !TraceCounts) ->
            StartCounts = ProbeCounts
        ;
            StartCounts = map__init
        ),
        read_proc_trace_counts_2(ProcLabel, CurFileName, StartCounts,
            !TraceCounts, !IO)
    ;
        string__format("parse error on line %d of execution trace",
            [i(HeaderLineNumber)], Message),
        throw(trace_count_syntax_error(Message))
    ).

:- pred read_proc_trace_counts_2(proc_label::in, string::in,
    proc_trace_counts::in, trace_counts::in, trace_counts::out,
    io::di, io::uo) is det.

read_proc_trace_counts_2(ProcLabel, CurFileName, ProcCounts0, !TraceCounts,
        !IO) :-
    io__read_line_as_string(Result, !IO),
    (
        Result = ok(Line),
        ( parse_path_port_line(Line, PathPort, ContextLineNumber, Count) ->
            ContextCount = context_and_count(CurFileName, ContextLineNumber,
                Count),
            map__det_insert(ProcCounts0, PathPort, ContextCount, ProcCounts),
            read_proc_trace_counts_2(ProcLabel, CurFileName, ProcCounts,
                !TraceCounts, !IO)
        ;
            svmap__det_insert(ProcLabel, ProcCounts0, !TraceCounts),
            io__get_line_number(LineNumber, !IO),
            read_proc_trace_counts(LineNumber, Line, CurFileName, !TraceCounts,
                !IO)
        )
    ;
        Result = eof,
        svmap__det_insert(ProcLabel, ProcCounts0, !TraceCounts)
    ;
        Result = error(Error),
        throw(Error)
    ).

:- pred parse_path_port_line(string::in, path_port::out, int::out, int::out)
    is semidet.

parse_path_port_line(Line, PathPort, LineNumber, Count) :-
    Words = string__words(Line),
    (
        Words = [Word1, CountStr, LineNumberStr],
        ( string_to_trace_port(Word1, Port) ->
            PathPort = port_only(Port)
        ; Path = string_to_goal_path(Word1) ->
            PathPort = path_only(Path)
        ;
            fail
        ),
        string__to_int(CountStr, Count),
        string__to_int(LineNumberStr, LineNumber)
    ;
        Words = [PortStr, PathStr, CountStr, LineNumberStr],
        string_to_trace_port(PortStr, Port),
        Path = string_to_goal_path(PathStr),
        PathPort = port_and_path(Port, Path),
        string__to_int(CountStr, Count),
        string__to_int(LineNumberStr, LineNumber)
    ).

:- pred string_to_pred_or_func(string::in, pred_or_func::out) is semidet.

string_to_pred_or_func("p", predicate).
string_to_pred_or_func("f", function).

string_to_trace_port("CALL", call).
string_to_trace_port("EXIT", exit).
string_to_trace_port("REDO", redo).
string_to_trace_port("FAIL", fail).
string_to_trace_port("EXCP", exception).
string_to_trace_port("COND", ite_cond).
string_to_trace_port("THEN", ite_then).
string_to_trace_port("ELSE", ite_else).
string_to_trace_port("NEGE", neg_enter).
string_to_trace_port("NEGS", neg_success).
string_to_trace_port("NEGF", neg_failure).
string_to_trace_port("DISJ", disj).
string_to_trace_port("SWTC", switch).
string_to_trace_port("FRST", nondet_pragma_first).
string_to_trace_port("LATR", nondet_pragma_later).

:- func string_to_goal_path(string) = goal_path is semidet.

string_to_goal_path(String) = Path :-
    string__prefix(String, "<"),
    string__suffix(String, ">"),
    string__length(String, Length),
    string__substring(String, 1, Length-2, SubString),
    path_from_string(SubString, Path).

%-----------------------------------------------------------------------------%

restrict_trace_counts_to_module(ModuleName, TraceCounts0, TraceCounts) :-
    map__foldl(restrict_trace_counts_2(ModuleName), TraceCounts0,
        map__init, TraceCounts).
    
:- pred restrict_trace_counts_2(module_name::in, proc_label::in, 
    proc_trace_counts::in, trace_counts::in, trace_counts::out) is det.

restrict_trace_counts_2(ModuleName, ProcLabel, ProcCounts, Acc0, Acc) :-
    (if ProcLabel = proc(ModuleName, _, _, _, _, _) then
        map__det_insert(Acc0, ProcLabel, ProcCounts, Acc)
    else
        Acc = Acc0
    ).

- undefined insts/modes cause an internal error

- the name mangling code needs to be generalized

- The --static-ground-terms sometimes causes duplicate labels in the
  generated C code.  Example:

:- pred special_pred_info(special_pred_id, type, string, list(type),
			list(mode), determinism).
:- mode special_pred_info(in, in, out, out, out, out) is det.

special_pred_info(unify, Type, "__Unify__", [Type, Type], [In, In], semidet) :-
	In = (ground -> ground).
special_pred_info(index, Type, "__Index__", [Type, IntType], [In, Out], det) :-
	term__context_init(Context),
	IntType = term__functor(term__atom("int"), [], Context),
	In = (ground -> ground),
	Out = (free -> ground).
special_pred_info(compare, Type,
		 "__Compare__", [ResType, Type, Type], [Out, In, In], det) :-
	term__context_init(Context),
	ResType = term__functor(term__atom("comparison_result"), [], Context),
	In = (ground -> ground),
	Out = (free -> ground).


- disjunctions or if-then-elses after a call to a nondet predicate cause
  "Software error: cannot restore unknown failure continuation"
  Example:

	:- module x.
	:- interface.
	:- pred p(int::out) is nondet.
	:- pred q(int::out, int::out) is nondet.

	:- implementation.

	:- external(p/1).

	q(X, Y) :-
		p(X),
		( p(Y1) ->
			Y = Y1
		;
			Y = 42
		).

	:- module x.
	:- interface.
	:- pred p(int::out) is nondet.
	:- pred q(int::out, int::out) is nondet.

	:- implementation.

	:- external(p/1).

	q(X, Y) :-
		p(X),
		(
			Y = 41
		;
			Y = 42
		).

- The followcode transformation is buggy, in that it can make valid
  code become invalid due to determinism errors.  We need to fix
  this by running determinism analysis once before followcode
  to check for errors, and then running it again after followcode
  this time ignoring any errors.  Or alternately we could put more
  intelligence into the followcode transformation pass so that it doesn't
  apply the transformation if it would introduce a determinism error.

- Similarly, inlining flattens conjs which may introduce detism errors.

- The output of polymorphism is not in super-homogeneous form.
  e.g. unification of pair/1.  This does not cause any known bugs
  at this time, since the code generator can handle that, but it
  should be fixed at some stage.


NEWS since Mercury 0.12
-----------------------

HIGHLIGHTS
==========

Changes to the Mercury language:
* The Mercury typeclass system now supports functional dependencies.
* A new language construct allows programmers to promise that any given
  goal is pure or semipure.
* Two new language constructs allow programmers to promise that all solutions
  of a given goal are equivalent with respect to the relevant equality
  theories.
* We now have support for optional module initialisation and finalisation.
* We now have support for impure module-local mutable variables.
* We now have support for recognizing switches in which multiple switch arms
  have shared code.
* A new pragma allows programmers to promise that in a predicate or function
  defined by mode-specific clauses, the mode-specific definitions have
  equivalent semantics.
* We now allow users to control how each argument of a `pragma memo' predicate
  is tabled.
* Support for the old-style lambda, mode and pragma syntax has been removed.
* ':' is now the type qualification operator, not a module qualifier.
* To ensure soundness, goals in negated contexts using non-local variables
  with dynamic modes (inst "any") must now be marked as impure.

Changes to the Mercury standard library:
* We have removed the predicates dealing with runtime type information (RTTI)
  from std_util.m. Any users impacted by this change should look for required
  functionality in the construct, deconstruct and type_desc modules of the
  standard library, in forms that have been mostly unchanged since the
  0.11 release. In most cases, the differences are quite minor, but provide
  more expressive power.
* We have moved the all-solutions predicates from std_util.m into a new
  library module, solutions.m.  These predicates are still available in
  std_util.m but these versions are now deprecated.
* We have made the predicates semidet_succeed/0, semidet_fail/0 and
  cc_multi_equal/2 into builtins.  Formerly these were exported by std_util.m.
* We have added an `injection' module, for reversible maps that are injective.

Changes to the Mercury compiler:
* The compiler now generates error messages for mismatches between format
  strings and lists of values to be printed in calls to string.format and
  io.format.
* The compiler now generates better error messages for determinism errors
  involving single-solution contexts.
* We have significantly improved the compiler's performance on predicates
  with many clauses.
* We have deleted the old --split-c-files option, as it conflicted with the
  implementation of module initialisation and finalisation.

Portability Improvements:
* None yet.

Changes to the Mercury debugger:
* Users can now see a listing of the source code lines referred to by the
  current environment (see the documentation for the `list' command in
  the Mercury Users' Guide).
* Users can now keep hold of a term, referring to it even when execution has
  left the goal at which the term was available as the value of a program
  variable.
* Users can now see the set of places where two terms differ from each other.
* The declarative debugger now supports an `undo' command, and allows users to
  select the search algorithm.
* The declarative debugger can now exploit information from the "code
  footprints" of passed and failed test cases to find bugs with fewer
  questions. We have also added two tools, mslice and mdice, to manipulate
  files containing such footprints.
* Subterm dependency tracking in the declarative debugger is now significantly
  faster.

Changes to the compiler backends:
* We have implemented an optimization, --optimize-constructor-last-call,
  that can turn recursive calls that are followed only by unifications that
  construct output arguments into tail calls. This can reduce the stack space
  requirements of the predicates to which it is applicable from linear
  in the size of the input data to constant.
* We have implemented an optimization, --tuple, that can replace several
  arguments that are usually passed to predicates together with a single
  tuple. This can reduce parameter passing overheads.
* The compiler can now optimize away the trail manipulation code from parts
  of the program that cannot affect the trail.
* The compiler now optimizes away any instructions referring to values of dummy
  types. A type is a dummy type if it has one function symbol of arity zero.
* Higher order calls are now cheaper on the low level C backend.

Changes to the extras distribution:
* We've added a library of data structures designed to work with solver types. 
* We've added a library to generate Windows installer packages.
* We've added a program to generate optimisation flags for the compiler.


DETAILED LISTING
================

Changes to the Mercury language:

* We have added support for functional dependencies to the typeclass system.
  See the "Type classes" section of the Mercury Language Reference Manual for
  details.

* A new language construct allows programmers to promise that any given
  goal is pure or semipure. Given Goal, a goal that uses impure and/or
  semipure code, the goal

	  promise_pure ( Goal )

  promises that Goal presents a pure interface. Given Goal, a goal that
  uses impure code, the goal

	  promise_semipure ( Goal )

  promises that Goal presents a semipure interface.

* A new language construct allows programmers to promise that all solutions
  of a given goal are equivalent with respect to the relevant equality
  theories. Given Goal, a goal that computes values for two variables,
  X and Y, the goal

  	promise_equivalent_solutions [X, Y] ( Goal )

  promises that all solutions of Goal are equivalent with respect to the
  equality theories of the types of X and Y. This means that the
  promise_equivalent_solutions goal will be det if Goal is cc_multi,
  and that the promise_equivalent_solutions goal will be semidet if Goal
  is cc_nondet.

  A related language construct allows programmers to promise that although
  the solutions of a given goal are not necessarily equivalent with respect
  to the relevant equality theories, it is nevertheless immaterial which one
  is chosen in a particular context. The language construct is the `arbitrary'
  goal, and the context is established by a `promise_equivalent_solution_sets'
  goal. Consider a type representing maps from keys to values which is
  implemented using 2-3 trees. In such a type, the precise shape of the tree
  doesn't matter; two trees should be considered equal if they contain the same
  set of keys and map them to the same values:

  :- type tree23(K, V)
  	--->	two(tree23(K, V), K, V, tree23(K, V)
  	;	three(tree23(K, K, V, tree23(K, V), K, V, tree23(K, V))
	where equality is tree23_equal
	and comparison is tree23_compare.

  Two values of e.g. type tree23(int, string) may differ in their top level
  function symbol even through they denote the same map. Deconstructing a
  value of such a type may therefore theoretically yield either "two" or
  "three" as the top level function symbol, although in practice which one
  you get is determined by the concrete structure of the term. Unifications
  of such values with specific function symbols are therefore permitted only
  in committed choice contexts. Unfortunately, one cannot simply put the
  deconstruction into the scope of a promise_equivalent_solutions goal,
  since the solutions are not equivalent in all contexts. However, the
  solutions will be equivalent in *some* contexts. Consider this function
  to count the number of key-value pairs in the map:

  count(Tree) = Count :-
  	promise_equivalent_solution_sets [Count] (
		(
			arbitrary [Tree1, Tree2] (
				Tree = two(Tree1, _Key, _Value, Tree2)
			),
			Count = 1 + count(Tree1) + count(Tree2)
		;
			arbitrary [Tree1, Tree2, Tree3] (
				Tree = three(Tree1, _Key1, _Value1, Tree2,
					_Key2, _Value2, Tree3)
			),
			Count = 2 + count(Tree1) + count(Tree2) + count(Tree3)
		)
	).

  The construct `arbitrary [Tree1, Tree2] Goal', where Goal computes Tree1
  and Tree2, tells the compiler that it is OK to commit to the first solution
  of Goal, because regardless of whether the goal succeeds and if so with
  which values of Tree1 and Tree2, the set of solutions of the surrounding
  `promise_equivalent_solution_sets [Count] Goal' will not be affected.
  Regardless of whether Tree is bound to "two" or "three", the body of count
  will compute the right value for Count.

  A goal of the form `arbitrary [Vars] Goal' will be det if Goal is cc_multi,
  and it will be semidet if Goal is cc_nondet. Goals of that form may occur
  only inside `promise_equivalent_solution_sets' goals. There is no restriction
  on the determinism of `promise_equivalent_solution_sets' goals.

* We have added support for optional module initialisation.  See the 
  "Module initialisation" section of the Mercury Language Reference
  Manual for details.

* We have added support for optional module finalisation.  See the
  "Module finalisation" section of the Mercury Language Reference
  Manual for details.

* We have added support for impure module-local mutable variables.
  See the "Module-local mutable variables" section of the Mercury Language
  Reference Manual for details.

* We now have support for recognizing switches in which multiple switch arms
  have shared code. Where previously programmers had to write code like this

  (
  	X = a,
	... code for a ...
  ;
  	X = b(...),
	... code for b ...
  ;
  	X = c,
	... code for c ...
	... shared code ...
  ;
  	X = d(...),
	... code for d ...
	... shared code ...
  )

  to have the disjunction recognized as a switch on X, they can now write
  code like this:

  (
  	X = a,
	... code for a ...
  ;
  	X = b(...),
	... code for b ...
  ;
  	(
		X = c,
		... code for c ...
	;
		X = d(...),
		... code for d ...
	),
	... shared code ...
  )

* If a predicate or function is defined by mode-specific clauses, like this:

	reversible_sort(Raw::in, Sorted::out) :-
		list.sort(Raw, Sorted).
	reversible_sort(Raw::out, Sorted::in) :-
		is_sorted(Sorted),
		list.perm(Sorted, Raw).

  the compiler by default assumes that the definitions of the different modes
  have different semantics. Programmers can tell the compiler that the
  mode-specific definitions, though syntactically distinct, are semantically
  equivalent by including a pragma:

  :- pragma promise_equivalent_clauses(reverse_sort/2).

* To ensure soundness, goals in negated contexts using non-local variables
  with dynamic modes (inst "any") must now be marked as impure.

  If a goal uses a variable with a dynamic mode (inst "any"),
  and that goal occurs inside a negated context (such as the
  condition of an if-then-else, or a lambda expression),
  and the variable also occurs outside of that negated context,
  then the compiler will infer that goal to be impure,
  and so such goals must normally be marked as "impure".

  This change was required because Mercury implements negation using
  the standard negation-as-failure approach, which is not sound if the
  negated goal binds any non-local variables.

  As usual, the programmer can use "promise_pure" if they are
  sure that the goal is in fact pure, e.g. because they know that
  the goal inside the negation will not instantiate the variable.

Changes to the Mercury standard library:

* We have added the function `divide_equivalence_classes' to the `eqvclass'
  module.

* We have added an `injection' module, for reversible maps that are injective.

* We have added list.foldl_corresponding/5, list.foldl2_corresponding/7,
  list.map2_foldl2/8 and list.det_split_list/4.

* We have added string.word_wrap/2.

* We have added set.fold4/10.

* We have added semidet_true/0 and semidet_false/0 as synonyms for
  semidet_succeed/0 and semidet_fail/0.

* We have added impure_true/0 and semipure_true/0.

Changes to the Mercury compiler:

* The compiler now generates error messages for known mismatches between format
  strings and lists of values to be printed in calls to string.format and
  io.format, unless the user specifies the --no-warn-known-bad-format-call
  option.

  If the user specifies the --warn-unknown-format-call option, the compiler
  will also generate error messages for calls to string.format and io.format
  in which the format string or the structure of the list of values to be
  printed are not statically available.

Changes to the extras distribution:

* We've added a library of data structures designed to work for solver types. 

  The module extras/solver_types contains versions of the the standard
  library's array, assoc_list, list and map modules that are designed to
  work with terms that have inst `any'.

* We've added a library to generate Windows installer packages.

  The directory extras/windows_installer_generator contains a library to
  generate Wix source files.  WiX is an XML language that is used to generate
  Microsoft Windows Installer (.msi) packages.

* We've added a program to generate optimisation flags for the compiler.

  The directory extras/gator contains a program to search for the
  optimal set of compiler flags for a given program.  The search
  algorithm used is a genetic algorithm, which can run in parallel over
  multiple hosts (by default, 1).


NEWS for Mercury 0.12.2
----------------------

This release fixes some bugs with `mmc --make' and `--smart-recompilation'.


NEWS for Mercury 0.12.1
------------------------

This release is primarily a bug-fix release.
It fixes a problem with predicates that have existentially typed
arguments, makes sure that I/O tabling does not inadvertently
inline predicates that have a `:- pragma no_inline' declaration
attached to them, and makes various improvements to the MS-Windows
ports.


NEWS for Mercury 0.12
---------------------

HIGHLIGHTS
==========

Changes to the Mercury language:
* Infix `.' is now accepted as a module name separator.
* Field access syntax can now be used at the top-level in func and mode
  declarations and in the head of a clause for a user-defined field access
  function.
* We now support impure higher-order code.
* We now allow user-defined comparison predicates.
* User-defined equality and comparison predicates for a type are now
  required to be defined in the same module as the type.
* Experimental support for user-defined constrained types has been added.
* We now support the use of `..' as an infix operator.

Changes to the Mercury standard library:
* We've added several new modules: cord, for sequences with O(1) consing and
  concatenation, array2d, for two-dimensional arrays, and version_array,
  version_array2d, version_bitmap, version_hash_table, and version_store,
  implementing non-unique versions of these types supporting O(1) access for
  non-persistent use.  A new module term_to_xml has been added for converting
  arbitrary terms to XML documents. Two new modules, set_tree234 and
  set_ctree234, have been added to provide operations on sets with better
  worst-case behavior (but worse constant factors) than the current
  implementation. Ten new modules, svarray, sveqvclass, svmap, svmulti_map,
  svbimap, svset, svbag, svqueue, svrelation and svvarset now provide more
  convenient ways to update arrays, equivalence classes, maps, multi_maps,
  bimaps, sets, bags, queues, relations and varsets in code that uses state
  variables.
* New procedures have been added to many of the existing standard library
  modules.  Most notably, these include procedures for creating
  directories and symbolic links, for checking file types and file
  accessibility, for detecting floating point infinities and NaNs.
* The dir module now handles Microsoft Windows pathnames correctly.

Changes to the Mercury compiler:
* We have added optional support for a new type-accurate garbage collector
  as an alternative to using the Boehm et al conservative collector.
* Better support for incremental program development:
  there's two new compiler options, `--allow-stubs' and `--no-warn-stubs',
  to support execution of incomplete programs.
* There's a new warning option `--warn-dead-procs' for detecting unreachable
  code.
* It's now easier to use shared libraries on Linux/x86 systems
  with `mmc --make'.
* A new analysis: `--analyse-exceptions'.
  The compiler can use the results of this analysis to try and improve
  some optimizations.

Portability improvements:
* We have made the implementation compatible with gcc 3.4.
* Shared libraries now work on Mac OS X.

Changes to the Mercury debugger:
* Users can now arrange to have the goal and/or some variables printed
  every time execution arrives at a breakpoint.
* Users can now arrange to associate a condition with a breakpoint.
  Execution won't stop at the breakpoint if the condition is false.
* Users can now limit the output from stack traces.
* Users can now put breakpoints on unify and compare predicates.
* Users can now save runtime values to files.
* Users can now tell the declarative debugger to trust entire modules or 
  individual predicates or functions.
* The declarative debugger can track the origins of subterms.
* The declarative debugger can now use the divide-and-query search strategy.

Changes to the compiler back-ends:
* The .NET CLR back-end now bootstraps.
* Improvements to the Java back-end.
* The cost in disk space of enabling debugging is now much smaller.

Numerous minor improvements to the Mercury standard library.

Changes to the extras distribution:
* Added easyx, a new Xlib based graphics library suitable for implementing
  simple interactive graphical applications.
* Major improvements to the OpenGL binding.
* We've added a binding to GLUT (the GL utility toolkit).
* The OpenGL, GLUT and Tcl/Tk bindings have been ported to Mac OS X.

DETAILED LISTING
================

Changes to the Mercury language:

* The deprecated support for NU-Prolog style `when' declarations has been
  removed.	

* We have experimental support for user-defined constrained types, as
  documented in the reference manual section on "Solver types".  Variables
  of a constrained type can have constraints placed upon them before they
  are instantiated, allowing for various styles of constraint logic
  programming.

* We now allow user-defined comparison predicates, using the syntax
  :- type t ---> t where equality is unify_t, comparison is compare_t.

  See the "User-defined equality and comparison" chapter of the
  Mercury Language Reference Manual for details.

* User-defined equality and comparison predicates for a type are now
  required to be defined in the same module as the type.

* Infix `.' is now accepted as a module name separator.  Hence it is
  now possible to write io.write_string and list.member to mean the
  same thing as io__write_string and list__member, for instance.  This
  has required changing the associativity of `.' from xfy to yfx and
  from precedence 600 to 10.

* Field access notation can now be used at the top-level in func and
  mode declarations and in the head of a clause for a user-defined
  field access function.  That is, one can now write

  	:- func a ^ f(b) = c.
	:- mode a ^ f(b) = c is <detism>.
	A ^ f(B) = ...

* Mercury's support for impure code now also includes support for
  impure higher-order code.
  
  Specifically, impurity annotations can be used on higher-order types,
  lambda expressions, and higher-order calls; higher-order terms are
  permitted to call impure or semipure code provided that they are
  appropriately annotated as such.

  For details, see the "Higher-order impurity" section of the "Impurity"
  chapter of the Mercury Language Reference Manual.

* `..' is now accepted as an infix operator.  That means a list of
  successive integers can now be written as X .. Y.  For example:

	1 .. 5 = [1, 2, 3, 4, 5]


Changes to the Mercury standard library:

* We've add the function queue.from_list/1 as a synonym for
  queue.list_to_queue/1, function queue.to_list/1 (and predicate
  queue.to_list/2) as the converse of queue.from_list/1, queue.put_on_front/2
  (and predicate queue.put_on_front/3) to put items on to the front of a
  queue, queue.put_list_on_front/2 (and predicate queue.put_list_on_front/3)
  to put a list of items on to the front of a queue, and predicate
  queue.get_from_back/3 which removes the last element from a queue.

* We've added the function pqueue.from_assoc_list/1 as a synonym
  for pqueue.assoc_list_to_pqueue/1.

* We've added functions set.from_list/1 and set.from_sorted_list/1
  as synonyms for set.list_to_set/1 and set.sorted_list_to_set/1
  respectively.  Similar additions have also been made to the
  set_unordlist, set_ordlist and set_bbbtree modules.

* We've added some new higher-order predicates, rbtree.foldl2/6
  rbtree.foldl3 and rbtree.transform_value to the rbtree module.  The
  predicate rbtree.remove/3 has been deprecated.

* We've add some new predicates and functions to int.m.
  int.fold_up/4, int.fold_down/4, int.fold_up/5, int.fold_down/5,
  int.fold_up2/7 and int.fold_down2/7 support iteration over
  contiguous integer ranges.

* The predicate int.to_float/2 has now been deprecated.

* We've added a new library module, `array2d', for two-dimensional arrays.

* We've added a new module, cord, for sequences with O(1) consing and
  concatenation.  A cord is essentially a tree structure with data stored
  in the leaf nodes.  Joining two cords together to construct a new cord
  is therefore an O(1) operation.

* The dir module now handles Microsoft Windows pathnames correctly.

* dir__split_name and dir__basename are now semidet, not det.
  dir__split_name fails for root directories or pathnames not
  containing a directory separator.
  dir__basename fails for root directories.

* We've added some new predicates and functions to the dir module:
	basename_det/1,
	expand_braces/1,
	is_directory_separator/1,
	make_directory/4,
	make_single_directory/4,
	foldl2/6,
	parent_directory/0,
	path_name_is_absolute/1,
	path_name_is_root_directory/1,
	recursive_foldl2/7.

* We've added several new predicates to the io module:
	have_symlinks/0,
	make_symlink/4,
	follow_symlink/4,
	check_file_accessibility/5,
	file_type/4,
	input_stream_foldl2_io_maybe_stop/{6,7},
	binary_input_stream_foldl2_io_maybe_stop/{6,7}.

* We've added several new predicates and functions to the bimap module:
	det_insert,
	forward_search,
	reverse_search,
	from_corresponding_lists,
	map_keys,
	map_values,
	det_insert_from_assoc_list,
	det_insert_from_corresponding_lists,
	set_from_assoc_list,
	set_from_corresponding_lists,
	delete_key,
	delete_value,
	delete_keys,
	delete_values,
	overlay,
	apply_forward_map_to_list,
	apply_reverse_map_to_list,
	foldl

* We've added predicates relation__lookup_key_set_from/3 and
  relation__lookup_key_set_to/3.

* The type of the arguments giving the initial set of visited nodes
  to relation__dfs and relation__dfsrev has changed from set_bbbtree
  to sparse_bitset.

* Efficiency of the operations in the relation module has been
  greatly improved.

* Some predicates and functions have been added to the sparse_bitset module:
	to_set/1,
	from_set/1,
	member/2,
	foldl/4,
	foldr/4.

* exception.m now contains a predicate finally/6 which can be used to
  ensure that resources are released whether a called closure exits
  normally or throws an exception.

* exception.m now contains a predicate throw_if_near_stack_limits which
  can be used to prevent an application running out of stack space.

* We've changed the interface of exception.try_all/2 to separate
  exceptional results from normal results.

* We've added predicates multi_map.to_flat_assoc_list/2 and
  multi_map.from_flat_assoc_list/2. 

* Several new functions have been added to the string module, namely
  elem/2, unsafe_elem/2, chomp/1, lstrip/1, lstrip/2, rstrip/1, rstrip/2,
  strip/1, prefix_length/2, suffix_length/2, string/1, string/2, string/4
  and string.det_to_float/1. 

* We've added some new predicates, list__map2_foldl, list__map_foldl3,
  and list__foldl4 to list.m.

* We've added a predicate, list__cons/3 to list.m.  This is sometimes
  useful with higher-order code.  It can also be useful with state
  variables.  We've also added a function version. 

* We've added some new predicates, map__common_subset, map__foldl3,
  map__overlay_large_map and map__transform_value, to map.m.

* We've added a predicate, map_fold, to set.m.

* We've added a function, pred_to_bool, to bool.m.

* We've added the three predicates, `is_nan/1', `is_inf/1' and
  `is_nan_or_inf/1' to float.m.  These predicates are for use only on
  systems which support IEEE floating point arithmetic.

* We've added a function version of `hash_table__search/3'.

* We've added a predicate, copy_mutvar, to store.m.

* We've added a function, clk_tck, to time.m.

* builtin.m now contains types and insts `unify' and `compare' for use
  in defining user-defined equality and comparison predicates.

* builtin.m now defines insts `new' and `old' as synonyms for `free' and
  `any', respectively, since some of the HAL literature uses this terminology.
  Likewise it defines modes `no' for `new >> old' and `oo' for `old >> old'.

* We've fixed some problems with the use of `cc_nondet'.

  The incorrect cc_nondet modes of the following predicates have been removed:
	deconstruct.arg/4
	deconstruct.named_arg/4
	deconstruct.limited_deconstruct/6
	std_util.arg_cc/3
	std_util.argument_cc/3
	std_util.named_argument_cc/3
	std_util.limited_deconstruct_cc/5
  These have been replaced by cc_multi versions in which success or failure
  is indicated by returning a maybe type.

* We've added functions get_equivalent_elements, get_minimum_element and 
  remove_equivalent_elements to eqvclass.m.

* We've added semidet functions max_key and min_key to return the maximum and
  minimum keys in maps and 2-3-4 trees.

* We've added predicates member, remove_leq, remove_gt, foldl and filter
  to sparse_bitset.m.

* builtin.m now contains types and insts `unify' and `compare' for use
  in defining user-defined equality and comparison predicates.

* The following predicates, which were added in 0.11.0, have been deprecated:
	io.current_input_stream/3
	io.current_output_stream/3
	io.current_binary_input_stream/3
	io.current_binary_output_stream/3
  They were identical to the following long-existing predicates with
  similar names:
	io.input_stream/3
	io.output_stream/3
	io.binary_input_stream/3
	io.binary_output_stream/3

* The following functions have been added to the integer module:
	integer.zero/0
	integer.one/0
	integer.det_from_string/1
	integer.pow/2
  
  The predicate integer.pow/3 has been deprecated. 

* We've added some functions, rational.int/1, rational.from_integer/1,
  rational.from_integers/2 and rational.reciprocal/1 to rational.m
  The function rational.rational_from_integers/2 has been deprecated.

* A new module `term_to_xml' has been added to the standard library.  This
  module contains predicates to write arbitrary Mercury terms to an output
  stream as XML.  Automatic generation of DTDs for Mercury types is also
  supported.  Once a Mercury term is in XML it can be converted to many other
  formats such as HTML or XUL using an appropriate stylesheet.

Changes to the Mercury compiler:

* We have added optional support for a new type-accurate garbage collector
  as an alternative to using the Boehm et al conservative collector.

  The new collector is enabled by `--grade hlc.agc'.
  For details about how it works, see the paper
  "Accurate garbage collection in an uncooperative environment"
  which is available via our web page.

  Note that the new collector is a very naive copying collector, and still
  has a number of serious limitations which may make it undesirable for
  most applications.  It only works with `--high-level-code'.  The heap
  size is fixed at program startup; the collector does not attempt to
  resize the heap.  It does not do cheap heap reclamation on backtracking.
  There is no support for passing terms on the Mercury heap to C code.
  In most cases, the Boehm et all conservative collector will perform better.

* There's a new warning option `--warn-dead-procs' which can be used
  for detecting unreachable code.

  This is not yet enabled by default, because it can cause some spurious
  warnings in modules containing code which mixes Mercury clauses and
  `pragma foreign_proc' declarations for the same procedure.

* `mmc --make' now works correctly with Microsoft Visual C++.

* It's now easier to use shared libraries on Linux/x86 systems with
  `mmc --make'.  See the documentation for the `--mercury-linkage'
  and `--linkage' options and the `MERCURY_LINKAGE' Mmake variable
  in the Mercury User's Guide.

* The behaviour of the `--pre-link-command' and `--extra-init-command'
  options has changed.  They now take a command which will be passed
  the names of all source files in the program or library, with the
  name of the main module's source file passed first.
  See the "Build system options" section of the "Invocation" chapter
  of the Mercury User's Guide for details.

* It is now possible to reconfigure an existing Mercury installation
  to use a different C compiler.  See the "C compilers" chapter
  of the Mercury User's Guide for details.

* Inlining of builtins can now be disabled using the `--no-inline-builtins'
  option.  This is done by default when debugging, as without this option the
  execution of builtins is not traced.

* The Mercury compiler now uses `.' and not `:' as the module separator
  in all output.

* The environment variables which were previously used to override the
  location of the standard library (MERCURY_ALL_C_INCL_DIRS,
  MERCURY_ALL_MC_C_INCL_DIRS, MERCURY_INT_DIR, MERCURY_C_LIB_DIR,
  MERCURY_MOD_LIB_MODS, MERCURY_TRACE_LIB_MODS) have been removed.

* There is a new analysis: `--analyse-exceptions'.  This identifies
  predicates that will not throw an exception.  This information is
  made available to the optimizing passes of the compiler. 

Portability improvements:

* We have made the implementation compatible with gcc 3.4.
* Shared libraries now work on Mac OS X.

Changes to the Mercury debugger:

* Users can now limit the output from stack traces.

  The mdb command `stack' now takes an optional integer argument that
  specifies the maximum number of stack frames to be printed.

* Users can now put breakpoints on unify and compare predicates.

  The syntax for procedure specifications now has provision for specifying
  unify and compare predicates.

* Users can now save runtime values to files.

  We've added a new mdb command, `save_to_file', that saves a specified term
  to a specified file.

* The declarative debugger can now be told to trust entire modules or 
  individual predicates or functions using the `trust' mdb command.

* The declarative debugger can now also tell you where a value
  appearing in an atom came from (i.e. the call which constructed the value).

* The declarative debugger also now supports a divide-and-query search mode.
  You can tell the declarative debugger to use this search mode by invoking
  it with the command `dd -s divide_and_query'.

* The "pretty" and "raw_pretty" print formats have had their names swapped, so
  the "pretty" format is now prettier than the "raw_pretty" format.

Changes to the compiler back-ends:

* The .NET CLR back-end now bootstraps.

  We've fixed a lot of bugs, and implemented a lot more of the Mercury
  standard library.  As well as being able to bootstrap in grade `il',
  we also now pass more than 90% of the applicable tests in the
  Mercury test suite.  See README.DotNet for details.

* Improvements to the Java back-end.

  We've fixed a lot of bugs, and implemented a lot more of the Mercury
  standard library.  See README.Java for further details on the status
  of this backend.


For news about earlier versions, see the HISTORY file.

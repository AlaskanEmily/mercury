#-----------------------------------------------------------------------------#

THIS_DIR = invalid

# Note: multi-module tests (including tests of nested modules)
# need to be listed separately from single-module tests, since
# we need to make dependencies only for multimodule tests.
# However, multi-module tests where the error is detected when
# building the dependencies (e.g. duplicate_module_test.m) should 
# not be included in this list; we handle those specially (see below).

MULTIMODULE_PROGS= \
	aditi_errors \
	aditi_state_errors \
	aditi_update_derived_relation \
	aditi_update_errors \
	aditi_update_mode_errors \
	duplicate_instance_2 \
	ho_default_func_2.sub \
	import_in_parent \
	imported_mode \
	missing_parent_import \
	partial_implied_mode \
	sub_c \
	test_nested \
	transitive_import \
	transitive_import_class \
	undef_mod_qual

SINGLEMODULE_PROGS= \
	any_mode \
	assert_in_interface \
	bigtest \
	bind_var_errors \
	builtin_int \
	builtin_proc \
	circ_type \
	circ_type2 \
	constrained_poly_insts \
	constructor_warning \
	det_errors \
	duplicate_modes \
	duplicate_module_test \
	errors \
	errors1 \
	errors2 \
	external \
	ext_type \
	ext_type_bug \
	exported_mode \
	field_syntax_error \
	foreign_singleton \
	foreign_type_2 \
	foreign_type_visibility \
	func_errors \
	funcs_as_preds \
	ho_default_func_1 \
	ho_default_func_3 \
	ho_type_mode_bug \
	ho_unique_error \
	impure_method_impl \
	inline_conflict \
	inst_list_dup \
	invalid_main \
	invalid_typeclass \
	io_in_ite_cond \
	lambda_syntax_error \
	merge_ground_any \
	method_impl \
	missing_det_decls \
	missing_interface_import \
	mode_inf \
	modes_erroneous \
	mostly_uniq1 \
	mostly_uniq2 \
	multimode_missing_impure \
	multimode_dcg \
	multimode_syntax \
	multisoln_func \
	nested_impl_in_int \
	no_exports \
	not_a_switch \
	nullary_ho_func_error \
	occurs \
	overloading \
	polymorphic_unification \
	pragma_c_code_dup_var \
	pragma_c_code_no_det \
	predmode \
	prog_io_erroneous \
	qual_basic_test2 \
	qualified_cons_id2 \
	record_syntax_errors \
	some \
	spurious_mode_error \
	state_vars_test1 \
	state_vars_test2 \
	state_vars_test3 \
	state_vars_test4 \
	tc_err1 \
	tc_err2 \
	tricky_assert1 \
	type_inf_loop \
	type_loop \
	type_mismatch \
	type_vars \
	typeclass_bogus_method \
	typeclass_constraint_extra_var \
	typeclass_mode \
	typeclass_missing_det \
	typeclass_missing_det_2 \
	typeclass_missing_det_3 \
	typeclass_missing_mode \
	typeclass_missing_mode_2 \
	typeclass_test_1 \
	typeclass_test_2 \
	typeclass_test_3 \
	typeclass_test_4 \
	typeclass_test_5 \
	typeclass_test_7 \
	typeclass_test_9 \
	types	\
	type_spec \
	unbound_type_vars \
	undef_lambda_mode \
	undef_mode \
	undef_mode_and_no_clauses \
	undef_symbol \
	undef_type \
	undef_type_mod_qual \
	unify_mode_error \
	uniq_modes \
	uniq_neg \
	uu_type \
	vars_in_wrong_places \
	with_type

# The following tests can only be run when building with --use-subdirs
# Note that tests which are compiled with --use-subdirs (or --make,
# which implies --use-subdirs) can only be run if we are building with
# --use-subdirs, otherwise (1) these tests will create the `Mercury'
# subdirectory, which will mean that all remaining tests get run with
# --use-subdirs and (2) if we're testing against a work-space, and the
# workspace wasn't built with --use-subdirs, these tests will fail with
# some misleading error messages, due to the standard library not being
# in the expected place.
USE_SUBDIR_MODULES = \
	nonexistent_import

# XXX we do not yet pass the following tests:
#	foreign_decl_line_number (due to some errors being reported in .c
#		files and .mh files rather than in .m files)
#	duplicate_instance_3 (the error is only detected when doing
#		normal static linking; the error goes undetected
#		when doing dynamic linking, or when the library
#		was built with `--split-c-files')
#	parent.undeclared_child (just not yet implemented)
#	freefree 	(need bromage's aliasing stuff)
#	typeclass_test_8 (minor formatting error in the output --
#			the type class name should be in quotes)
#	typeclass_mode_{2,3,4} (compiler calls error/1)
#	cyclic_typeclass (compiler goes into an infinite loop)
#	ho_default_func_4 (due to a bug in the mode-checker ---
#			see XXX comment in inst_match:inst_matches_final_3)
#	inst_matches_final_bug (due to same bug as ho_default_func_4)

#-----------------------------------------------------------------------------#

ifeq ($(MMAKE_USE_SUBDIRS),yes)
PROGS= $(SINGLEMODULE_PROGS) $(MULTIMODULE_PROGS) $(USE_SUBDIR_MODULES)
else
PROGS= $(SINGLEMODULE_PROGS) $(MULTIMODULE_PROGS)
endif

TESTS = $(MULTIMODULE_PROGS) $(SINGLEMODULE_PROGS:%=%-nodepend)
SUBDIRS = purity
TESTS_DIR=..
include $(TESTS_DIR)/Mmake.common

# Module-specific options should go in Mercury.options so they
# can be found by `mmc --make'.
include Mercury.options

%.runtest: %.err_res ;

#-----------------------------------------------------------------------------#

%.err: %.m
	if $(MC) --errorcheck-only $(ALL_GRADEFLAGS) $(ALL_MCFLAGS) $* \
		> $*.err 2>&1; \
	then false; else true; fi

# For foreign_decl_line_number, the exact output is somewhat dependent
# on the C compiler, etc.  So we just grep the output for "#error" to
# make sure that it contains the lines that we expect.  That way we don't
# fail this test if there is some additional output (e.g. spurious warnings
# in system header files).  We also pipe the output through `sort -u'
# to eliminate duplicates; this avoids spurious failures in cases where
# the C foreign_proc code is inlined by the Mercury compiler.
# We also pipe it through sed to remove "Mercury/cs/"; this
# avoids spurious failures with --use-subdirs.
foreign_decl_line_number.err: foreign_decl_line_number.m
	if $(MC) --errorcheck-only $(ALL_GRADEFLAGS) $(ALL_MCFLAGS) \
		foreign_decl_line_number.m \
		> foreign_decl_line_number.err.orig 2>&1; \
	then false; else true; fi
	grep '#error' foreign_decl_line_number.err.orig | \
		sed 's@Mercury/cs/@@g' | sort -u \
		> foreign_decl_line_number.err

# For duplicate_instance_{1,2}, the error is only caught at link time.
# So we need to use a different rule for that.
# The exact error message varies a lot from system to system,
# so we don't check the error output, we just check the command
# return status.
duplicate_instance_2.err: duplicate_instance_1.m duplicate_instance_2.m
	if $(MCM) duplicate_instance_2 > /dev/null 2>&1; \
	then	false; \
	else	echo "Error was successfully detected" > $*.err; \
	fi

# For these test cases, the bug is caught when generating dependencies,
# so it is easiest just to do that step.
nested_impl_in_int.err duplicate_module_test.err: %.err: %.m
	if $(MC) --generate-dependencies $* > $*.err 2>&1; \
	then false; \
	else true; \
	fi

$(dates_subdir)undef_mod_qual.date: $(int0s_subdir)undef_mod_qual.int0

clean_local:
	rm -f *.err *.err_res

#-----------------------------------------------------------------------------#

*******************************************************************************

TODO LIST:
----------

Required to bootstrap:
----------------------

- polymorphic unifications
- compare/3
- term_io__read_term etc.

code generation:
---------------

- generate code for complicated unifies in partially instantiated modes

- generate code for higher-order predicates
	-  "predicate pointers" (needed to bootstrap)
	-  closures.

- generate code for polymorphic predicates

- The followcode transformation is buggy, in that it can make valid
  code become invalid due to determinism errors.  We need to fix
  this by running determinism analysis once before followcode
  to check for errors, and then running it again after followcode
  this time ignoring any errors.  Or alternately we could put more
  intelligence into the followcode transformation pass so that it doesn't
  apply the transformation if it would introduce a determinism error.

typechecking
------------

- improve error messages for unification of var & functor

- see also wish list comments at the start of typecheck.nl

mode analysis
-------------

- handle implied modes

- handle higher-order pred modes

- handle unique modes (some research issues re backtracking)

- handle polymorphic modes (some research issues?)

- detect incorrect usage of `bound(...)' insts.

- handle undefined insts/modes gracefully

- split construct/deconstruct unifications into their atomic
  "micro-unification" pieces when necessary.

- see also comments at the start of modes.nl

general
-------

- tail recursion optimization using pass-by-reference argument conventions

- other specializations, e.g. if argument is known to be bound to
  f(X,Y), then just pass X and Y in registers

- handle abstract insts in the same way abstract types are handled (a research
  issue)

- improve efficiency of the implicit quantification pass (currently O(N^2))

- improve efficiency of the module import handling (currently O(N^2))

- renaming apart of different occurences
  of the same variable; warning about variables which occur in
  overlapping scopes.

- optimization of various sorts

- Combining heap pointer increments in straight-line code into
  a single increment (should be part of value number)

- garbage collection

mercury_to_goedel.nl
--------------------

- see comments at the start of that file

module system
-------------

- check that the interface for a module is type-correct
  independently of any declarations or imports in the implementation
  section

- handle module qualifiers properly

- imports should not be transitive
  (currently we get this right for predicates, constants, and functors,
  but wrong for types, insts, and modes).

*******************************************************************************

WISH LIST
---------

code generation:
---------------

- The generated code should include some profiling hooks.
  In particular, we should add a version of the heap allocation
  macro which takes an extra string parameter identifying which
  routine allocated the memory.  Then we can do heap-allocation
  profiling to identify which routines use up all the bloody memory.

- We could still generate better code for switches

general
-------

- if-then-else and quantification: currently in
	(if
		some [V] P
	then
		Q
	else
		R
	)
   the scope of V is P and Q, not just P.  This is counter-intuitive.
   We should probably require people to write `if_some' rather than
   `if some' to get that effect.  (No obvious similar solution for
   `(some [V] P -> Q ; R)', unfortunately.)

- switch detection: handle multi-level indexing (cse)

- more work on module system, separate compilation, and the multiple
  specialization problem

- deforestation

- mode segments & high-level transformation of circularly moded programs.

- implement user-defined operators:
	Add a new construct `:- op(Pred, Type, Op).' as in Prolog;
	change prog_io.nl to parse this construct and call io__op
	accordingly.

- optional warning for any implicit quantifiers whose scope is not
  the entire clause (the "John Lloyd" option :-).

- warn about multiple calls to a predicate with the same input arguments,
  because this is likely to be a programming mistake.
  eg.

	p(...) :-
		...
		q(InA, InB, OutC, OutD),
		...
		q(InA, InB, OutE, OutF).

  should result in

	Warning: redundant call to `q(InA, InB, _, _)'

- better error handling

- fix all the `XXX's, `xxx's, `YYY's and `%%%'s.

- implement a debugger and a profiler

*******************************************************************************

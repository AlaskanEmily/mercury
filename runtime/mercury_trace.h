/*
** Copyright (C) 1997-1998 The University of Melbourne.
** This file may only be copied under the terms of the GNU Library General
** Public License - see the file COPYING.LIB in the Mercury distribution.
*/

/*
** mercury_trace.h has two functions.
**
** (a)	It defines the interface between the tracing subsystem of the runtime
**	and compiled code.
**
** (b)	It defines the interface by which the internal and external debuggers
**	can control how the tracing subsystem treats events.
**
** The macros, functions and variables of this module are intended to be
** referred to only from code generated by the Mercury compiler, and from
** hand-written code in the Mercury runtime or the Mercury standard library,
** and even then only if at least some part of the program was compiled
** with some form of execution tracing.
**
** The parts of the tracing system that need to be present even when no
** part of the program is compiled with execution tracing are in the module
** mercury_trace_base.
*/

#ifndef MERCURY_TRACE_H
#define MERCURY_TRACE_H

#include "mercury_trace_base.h"

/* The interface between the tracing subsystem and compiled code. */

#define	MR_trace_incr_seq()	(++MR_trace_call_seqno)
#define	MR_trace_incr_depth()	(++MR_trace_call_depth)
#define	MR_trace_reset_depth(d)	do { MR_trace_call_depth = (d); } while (0)

/*
** This enum should exactly match the definition of the `trace_port' type in
** library/debugger_interface.
*/

typedef	enum {
	MR_PORT_CALL,
	MR_PORT_EXIT,
	MR_PORT_FAIL,
	MR_PORT_THEN,
	MR_PORT_ELSE,
	MR_PORT_DISJ,
	MR_PORT_SWITCH,
	MR_PORT_PRAGMA_FIRST,
	MR_PORT_PRAGMA_LATER
} MR_trace_port;

extern	void	MR_trace(
	const MR_Stack_Layout_Label *,	/* layout info for the event */
	MR_trace_port,
	Word,			/* call sequence number */
	Word,			/* call depth */
	const char *,		/* path to event goal within procedure */
	int,			/* highest numbered rN register in use */
	bool);			/* is this event supposed to be traced */

/* The interface between the debuggers and the tracing subsystem. */

/*
** MR_trace_cmd says what mode the tracer is in, i.e. how events should be
** treated.
**
** If MR_trace_cmd == MR_CMD_GOTO, the event handler will stop at the next
** event whose event number is equal to or greater than MR_trace_stop_event.
**
** If MR_trace_cmd == MR_CMD_FINISH, the event handler will stop at the next
** event that specifies the procedure invocation whose call number is in
** MR_trace_stop_seqno and whose port is final.
**
** If MR_trace_cmd == MR_CMD_RESUME_FORWARD, the event handler will stop at
** the next event of any call whose port is *not* final.
**
** If MR_trace_cmd == MR_CMD_TO_END, the event handler will not stop
** until the end of the program.
**
** If the event handler does not stop at an event, it will print the
** summary line for the event if MR_trace_print_intermediate is true.
*/

typedef enum {
	MR_CMD_GOTO,		/* stop at an event with a given number    */
	MR_CMD_FINISH,		/* stop when exiting/failing out of a proc */
	MR_CMD_RESUME_FORWARD,	/* stop at the next non-final port         */
	MR_CMD_TO_END		/* do not stop until the end of execution  */
} MR_trace_cmd_type;

typedef struct {
	MR_trace_cmd_type	MR_trace_cmd;	
	Unsigned		MR_trace_stop_seqno;
	Unsigned		MR_trace_stop_event;
	bool			MR_trace_print_intermediate;
} MR_trace_cmd_info;

#define	MR_port_is_final(port)	(port == MR_PORT_EXIT || port == MR_PORT_FAIL)

#endif /* MERCURY_TRACE_H */

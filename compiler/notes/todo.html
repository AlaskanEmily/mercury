

<html>
<head>
<title>
	To Do List
</title>
</head>

<body
	bgcolor="#ffffff"
	text="#000000"
>

<hr>
<!-------------------------->

<h1> TODO LIST </h1>

<hr>
<!-------------------------->

<p>


For more information on any of these issues, contact mercury@cs.mu.oz.au.

<p>

<h2> type system </h2>

<p>

<ul>
<li> allow a module exporting an abstract type to specify that other modules
  should not be allowed to test two values of that type for equality (similar
  to Ada's limited private types). This would be useful for e.g. sets
  represented as unordered lists with possible duplicates.
  	[this is a subset of the functionality of type classes]

<li> remove limitation that higher-order terms are monomorphic.
</ul>

<h2> mode analysis </h2>

<p>

<ul>
<li> extend the mode system to allow known aliasing.
  This is needed to make partially instantiated modes and unique modes work.
	[will be done by fjh]

<li> report an error if two mode declarations for a predicate
  specify identical modes

<li> detect incorrect usage of `bound(...)' insts.
  That is, make sure that all of the functors in a bound(...) inst
  are valid functors for the type.

<li> split construct/deconstruct unifications into their atomic
  "micro-unification" pieces when necessary.
  (When is it necessary?)
</ul>

<h2> determinism analysis </h2>

<ul>
<li> allow overloading of nondet/multidet and cc_nondet/cc_multidet
  determinism for the same mode of a predicate.
</ul>

<h2> unique modes </h2>

<ul>
<li> handle unique mode overloading better -
  don't depend on the order of the mode declarations.

<li> handle overloading of unique and mostly_unique modes.
  Currently in modes.m we always pick the unique version, and then in
  unique_modes.m, if it turns out out to be mostly_unique, we report an
  error.  We should changed unique_modes.m to also look for a
  mostly_unique version before reporting an error.
</ul>

<h2> code generation </h2>

<ul>
<li> take advantage of unique modes to do compile-time garbage collection
  and structure reuse.

<li> floating point registers
	<ul>
  	<li> allow floating point fields of structures without boxing
	(need multi-word fields)
	</ul>
</ul>

<h2> module system </h2>

<ul>
<li> check that the interface for a module is type-correct
  independently of any declarations or imports in the implementation
  section

<li> implement a use_module directive
  (like import_module, except that everything must be explicitly
  module qualified).

<li> imports should not be transitive
  (currently we get this right for predicates, constants, and functors,
  but wrong for types, insts, and modes).

<li> produce warnings for imports that are not needed
  	[done by stayl]

<li> produce warnings for imports that are in the wrong place
  (in the interface instead of the implementation, and vice versa)
  	[done by stayl]
</ul>

<h2> C interface </h2>

<ul>
<li> nondeterministic C code

<li> exporting things for manipulating Mercury types from C

<li> better support for types defined in C, and documentation
</ul>

<h2> general </h2>

<ul>
<li> coroutining and parallel versions of Mercury
	[being worked on by conway]

<li> implement streams (need coroutining at least)
	</ul>

<hr>
<!-------------------------->


<h1> WISH LIST </h1>

<h2> type-system </h2>

<ul>
<li> allow explicit type qualifications `X : Type'
	[being done by stayl]

<li> type classes

<li> existential types (possibly)

<li> subtypes

<li> optimisation of type representation and manipulation (possibly
  profiler guided) 

<li> fold/unfolding of types
</ul>

<h2> mode analysis: </h2>

<ul>
<li> implement mode inference
	[being worked on by pets]

<li> handle polymorphic modes (some research issues?)

<li> handle abstract insts in the same way abstract types are handled
  (a research issue - is this possible at all?)

<li> implement `willbe(Inst)' insts?
	  [will be done by conway]

<li> mode segments & high-level transformation of circularly moded programs.
</ul>

<h2> determinism analysis: </h2>

<ul>
<li> propagate information about bindings from the condition of an if-then-else
  to the else so that
	<pre>
	(if X = [] then .... else X = [A|As], ...)
	</pre>
  is considered det.

<li> turn chains of if-then-elses into switchs where possible.
</ul>

<h2> higher-order preds: </h2>

<ul>
<li> implement single-use higher-order predicate modes.
  Single-use higher-order predicates would be allowed to bind curried
  arguments, and to have unique modes for curried arguments.
 
<li> allow taking the address of a predicate with multiple modes
  (This would require mode inference.)
</ul>

<h2> code generation: </h2>

<ul>
<li> The generated code should include some more profiling hooks.
  In particular, we should add a version of the heap allocation
  macro which takes an extra string parameter identifying which
  routine allocated the memory.  Then we can do heap-allocation
  profiling to identify which routines use up all the bloody memory.

<li> inter-procedural register allocation 

<li> stack allocation of structures

<li> retarget code generator to Java VM
</ul>

<h2> source-level transformations </h2>

<ul>
<li> more work on module system, separate compilation, and the multiple
  specialisation problem

<li> deforestation

<li> extended DCGs

<li> transform non-tail-recursive predicates into tail-recursive form
  using accumulators
  [being worked on by jammb]

<li> partial deduction
  [being worked on by stayl]
</ul>

<h2> low-level optimizations </h2>

<ul>
<li> reduce the overhead of higher-order predicate calls (avoid copying
  the real registers into the fake_reg array and back)

<li> tail recursion optimization using pass-by-reference argument conventions
  [being worked on by jammb]

<li> other specializations, e.g. if argument is known to be bound to
  f(X,Y), then just pass X and Y in registers

<li> trim stack frames before making recursive calls, to minimize stack usage
  [this would probably be a pessimization much of the time - zs]
</ul>

  
<h2> compilation speed </h2>

<ul>
<li> improve efficiency of the expansion of equivalence types (currently O(N^2))
  (e.g. this is particularly bad when compiling live_vars.m.)

<li> improve efficiency of the module import handling (currently O(N^2))

<li> improve the efficiency of mode checking very large facts
  (e.g. this is particularly bad when compiling eliza.m.)

<li> improve the efficiency of the type_to_term and term_to_type implementation
  so that we can enable them in the standard distribution of the Mercury
  compiler
</ul>


<h2> better diagnostics </h2>

<ul>
<li> optional warning for any implicit quantifiers whose scope is not
  the entire clause (the "John Lloyd" option :-).

<li> give a better error message for the use of if-then without else.

<li> give a better error message for the use of `<=' instead of `>='
  (but how?)

<li> give a better error message for type errors involving higher-order pred
  constants (requested by Bart Demoen)

<li> give better error messages for syntax errors in lambda expressions
</ul>

<h2> general </h2>


<ul>
<li> implement a very fast turn-around bytecode compiler/interpreter/debugger,
  similar to Gofer

<li> implement a new backend which compiles to high-level C that can
  be debugged at the Mercury source code level using gdb
	[a start has been made by fjh]

<li> implement "accurate" garbage collection
	[being worked on by trd]

<li> implement parallel garbage collection

<li> implement user-defined operators: <br>
	Add a new construct `:- op(Pred, Type, Op).' as in Prolog;
	change prog_io.m to parse this construct and call io__op
	accordingly.  But how does this fit in with the module system?

<li> support for easier formal specification translation (eg a Z library,
  or Z to Mercury).

<li> improve support for constraint programming

<li> implement a source visualisation tool

<li> distributed Mercury

<li> improved development environment

<li> additional software engineering tools
	<ul>
  	<li> coverage analysis
	<li> automatic testing
	</ul>

<li> literate Mercury

<li> implement a GUI library (eg Hugs - Fudgets)

<li> profiling guided optimisations
	<ul>
	<li> use profiling information to direct linker for optimal
	  code placement (Alpha has a tool for this).
	</ul>

<li> attribute grammars
</ul>

<hr>
<!-------------------------->

Last update was $Date: 1997-04-03 05:17:54 $ by $Author: aet $@cs.mu.oz.au. <br>
</body>
</html>

%-----------------------------------------------------------------------------%
% vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
%-----------------------------------------------------------------------------%
% Copyright (C) 2005-2006 The University of Melbourne.
% This file may only be copied under the terms of the GNU General
% Public License - see the file COPYING in the Mercury distribution.
%-----------------------------------------------------------------------------%

% File: trace_counts.m.
% Main author: wangp.
% Modifications by zs and maclarty.

% This module defines predicates to read in the execution trace summaries
% generated by programs compiled using the compiler's tracing options.

%-----------------------------------------------------------------------------%

:- module mdbcomp.trace_counts.
:- interface.

:- import_module mdbcomp.prim_data.
:- import_module mdbcomp.program_representation.

:- import_module bool.
:- import_module io.
:- import_module list.
:- import_module map.

%-----------------------------------------------------------------------------%

:- type trace_count_file_type
    --->    user_all
            % The file contains counts for all labels from user-defined
            % procedures.

    ;       user_nonzero
            % The file contains counts for all labels from user-defined
            % procedures, provided the count is nonzero.

    ;       union(int).
            % The file is a union of some other trace count files.
            % The number of test cases in the union is recorded.

:- type trace_counts == map(proc_label_and_filename, proc_trace_counts).

:- type proc_label_and_filename
    --->    proc_label_and_filename(
                proc_label  ::  proc_label, 
                filename    ::  string
            ).

:- type proc_trace_counts   == map(path_port, line_no_and_count).

:- type path_port
    --->    port_only(trace_port)
    ;       path_only(goal_path)
    ;       port_and_path(trace_port, goal_path).

:- type line_no_and_count
    --->    line_no_and_count(
                line_number :: int,
                exec_count  :: int,
                num_tests   :: int
            ).

:- func make_path_port(goal_path, trace_port) = path_port.

:- pred summarize_trace_counts_list(list(trace_counts)::in, trace_counts::out)
    is det.

:- pred sum_trace_counts(trace_counts::in, trace_counts::in, trace_counts::out)
    is det.

%-----------------------------------------------------------------------------%

:- type read_trace_counts_result
    --->    ok(trace_count_file_type, trace_counts)
    ;       syntax_error(string)
    ;       error_message(string)
    ;       open_error(io__error)
    ;       io_error(io__error).

    % read_trace_counts(FileName, Result, !IO):
    %
    % Read in the trace counts stored in FileName.
    %
:- pred read_trace_counts(string::in, read_trace_counts_result::out,
    io::di, io::uo) is det.

:- type read_trace_counts_list_result
    --->    list_ok(trace_count_file_type, trace_counts)
    ;       list_error_message(string).

    % read_trace_counts_list(ShowProgress, FileName, Result, !IO):
    %
    % Read the trace_counts in the files whose names appear in FileName.
    % The result is a union of all the trace counts.
    % If ShowProgress is yes then print the name of each file to the current
    % output stream just before it is read.
    %
:- pred read_trace_counts_list(bool::in, string::in, 
    read_trace_counts_list_result::out, io::di, io::uo) is det.

:- type slice_source
    --->    file_list
    ;       single_file
    ;       try_single_first.

    % read_trace_counts_source(ShowProgress, Source, FileName, Result, !IO):
    %
    % Read in trace counts stored in one or more trace count files.
    %
    % If Source is file_list, then FileName should contain a list of filenames,
    % and read_trace_counts_source will read in the trace counts from each
    % of those files.
    %
    % If Source is single_file, then FileName should itself be a file
    % containing trace counts data.
    %
    % If Source is try_single_first, then read_trace_counts_source will
    % check to see if FileName contains trace counts data. If yes, it will
    % get trace counts from there. If not, read_trace_counts_source will
    % interpret FileName as a file that itself contains filenames, and
    % will treat it as with Source=file_list.
    %
    % If the source is a list of files and ShowProgress is yes then 
    % the name of each file read will be printed to the current output
    % stream just before it is read.
    %
:- pred read_trace_counts_source(bool::in, slice_source::in, string::in,
    read_trace_counts_list_result::out, io::di, io::uo) is det.

    % write_trace_counts_to_file(FileType, TraceCounts, FileName, Result, !IO).
    % Write the given trace counts to FileName in a format suitable for 
    % reading with read_trace_counts/4.
    %
:- pred write_trace_counts_to_file(trace_count_file_type::in, trace_counts::in,
    string::in, io.res::out, io::di, io::uo) is det.

:- pred string_to_trace_port(string, trace_port).
:- mode string_to_trace_port(in, out) is semidet.
:- mode string_to_trace_port(out, in) is det.

:- pred restrict_trace_counts_to_module(module_name::in, trace_counts::in,
    trace_counts::out) is det.

    % Return the number of tests cases used to generate the trace counts with
    % the given list of file types.
    %
:- func calc_num_tests(list(trace_count_file_type)) = int.

    % Return the number of tests used to create a trace counts file of the
    % given type.
    %
:- func num_tests_for_file_type(trace_count_file_type) = int.

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

:- implementation.

:- import_module char.
:- import_module exception.
:- import_module int.
:- import_module io.
:- import_module lexer.
:- import_module require.
:- import_module set.
:- import_module string.
:- import_module svmap.
:- import_module term_io.
:- import_module univ.

%-----------------------------------------------------------------------------%

summarize_trace_counts_list(TraceCountsList, TraceCounts) :-
    ( TraceCountsList = [TraceCountsPrime] ->
        % optimize the common case
        TraceCounts = TraceCountsPrime
    ;
        list.foldl(sum_trace_counts, TraceCountsList, map.init, TraceCounts)
    ).

sum_trace_counts(TraceCountsA, TraceCountsB, TraceCounts) :-
    map.union(sum_proc_trace_counts, TraceCountsA, TraceCountsB, TraceCounts).

:- pred sum_proc_trace_counts(proc_trace_counts::in, proc_trace_counts::in,
    proc_trace_counts::out) is det.

sum_proc_trace_counts(ProcTraceCountsA, ProcTraceCountsB, ProcTraceCounts) :-
    ProcTraceCounts = map.union(sum_counts_on_line,
        ProcTraceCountsA, ProcTraceCountsB).

:- func sum_counts_on_line(line_no_and_count, line_no_and_count)
    = line_no_and_count.

sum_counts_on_line(LC1, LC2) = LC :-
    % We don't check that LineNumber1 = LineNumber2 since that does not
    % necessarily represent an error. (Consider the case when the two trace
    % files are derived from sources that are identical except for the addition
    % of a comment.)

    LC1 = line_no_and_count(LineNumber1, Count1, NumTests1),
    LC2 = line_no_and_count(_LineNumber, Count2, NumTests2),
    LC = line_no_and_count(LineNumber1, Count1 + Count2, 
        NumTests1 + NumTests2).

%-----------------------------------------------------------------------------%

read_trace_counts_source(ShowProgress, Source, FileName, Result, !IO) :-
    (
        Source = file_list,
        read_trace_counts_list(ShowProgress, FileName, Result, !IO)
    ;
        Source = single_file,
        (
            ShowProgress = yes,
            io.write_string(FileName, !IO),
            io.nl(!IO)
        ;
            ShowProgress = no
        ),
        read_trace_counts(FileName, ReadTCResult, !IO),
        (
            ReadTCResult = ok(FileType, TraceCount),
            Result = list_ok(FileType, TraceCount)
        ;
            ReadTCResult = io_error(IOError),
            ErrMsg = io.error_message(IOError),
            Result = list_error_message("IO error reading file " ++
                "`" ++ FileName ++ "': " ++ ErrMsg)
        ;
            ReadTCResult = open_error(IOError),
            ErrMsg = io.error_message(IOError),
            Result = list_error_message("IO error opening file " ++
                "`" ++ FileName ++ "': " ++ ErrMsg)
        ;
            ReadTCResult = syntax_error(ErrMsg),
            Result = list_error_message("Syntax error in file `" ++
                FileName ++ "': " ++ ErrMsg)
        ;
            ReadTCResult = error_message(ErrMsg),
            Result = list_error_message("Error reading trace counts " ++
                "from file `" ++ FileName ++ "': " ++ ErrMsg)
        )
    ;
        Source = try_single_first,
        read_trace_counts_source(ShowProgress, single_file, FileName, 
            TryResult, !IO),
        (
            TryResult = list_ok(_, _),
            Result = TryResult
        ;
            TryResult = list_error_message(_),
            read_trace_counts_source(ShowProgress, file_list, FileName, 
                Result, !IO)
        )
    ).

read_trace_counts_list(ShowProgress, FileName, Result, !IO) :-
    io.open_input(FileName, OpenResult, !IO),
    (
        OpenResult = ok(FileStream),
        read_trace_counts_list_stream(ShowProgress, union(0), map.init, 
            FileName, FileStream, Result, !IO)
    ;
        OpenResult = error(IOError),
        Result = list_error_message("Error opening file `" ++ FileName ++
            "': " ++ string.string(IOError))
    ).

    % Same as read_trace_counts_list/5, but read the filenames containing
    % the trace_counts from the given stream.  MainFileName is the
    % name of the file being read and is only used for error messages.
    %
:- pred read_trace_counts_list_stream(bool::in, trace_count_file_type::in,
    trace_counts::in, string::in, io.input_stream::in,
    read_trace_counts_list_result::out, io::di, io::uo) is det.

read_trace_counts_list_stream(ShowProgress, FileType0, TraceCounts0, 
        MainFileName, Stream, Result, !IO) :-
    io.read_line_as_string(Stream, ReadResult, !IO),
    (
        ReadResult = ok(Line),
        % Remove trailing whitespace:
        FileName = string.rstrip(Line),
        (
            % Ignore blank lines.
            FileName = ""
        ->
            read_trace_counts_list_stream(ShowProgress, FileType0, 
                TraceCounts0, MainFileName, Stream, Result, !IO)
        ;
            (
                ShowProgress = yes,
                io.write_string(FileName, !IO),
                io.nl(!IO)
            ;
                ShowProgress = no
            ),
            read_trace_counts(FileName, ReadTCResult, !IO),
            (
                ReadTCResult = ok(FileType1, TraceCounts1),
                summarize_trace_counts_list([TraceCounts0, TraceCounts1],
                    TraceCounts),
                NumTests = calc_num_tests([FileType0, FileType1]),
                FileType = union(NumTests),
                read_trace_counts_list_stream(ShowProgress, FileType, 
                    TraceCounts, MainFileName, Stream, Result, !IO)
            ;
                ReadTCResult = io_error(IOError),
                ErrMsg = io.error_message(IOError),
                Result = list_error_message("I/O error reading file " ++
                    "`" ++ FileName ++ "': " ++ ErrMsg)
            ;
                ReadTCResult = open_error(IOError),
                ErrMsg = io.error_message(IOError),
                Result = list_error_message("I/O error opening file " ++
                    "`" ++ FileName ++ "': " ++ ErrMsg)
            ;
                ReadTCResult = syntax_error(ErrMsg),
                Result = list_error_message("Syntax error in file `" ++ 
                    FileName ++ "': " ++ ErrMsg)
            ;
                ReadTCResult = error_message(ErrMsg),
                Result = list_error_message("Error reading trace counts " ++
                    "from file `" ++ FileName ++ "': " ++ ErrMsg)
            )
        )
    ;
        ReadResult = error(Error),
        Result = list_error_message("IO error reading file " ++ "`" ++
            MainFileName ++ "': " ++ string.string(Error))
    ;
        ReadResult = eof,
        Result = list_ok(FileType0, TraceCounts0)
    ).

read_trace_counts(FileName, ReadResult, !IO) :-
    % XXX We should be using zcat here, to avoid deleting the gzipped file
    % and having to recreate it again. Unfortunately, we don't have any
    % facilities equivalent to popen in Unix, and I don't know how to
    % write one in a way that is portable to Windows. zs.
    ( string__remove_suffix(FileName, ".gz", BaseName) ->
        io__call_system("gunzip " ++ FileName, _UnzipResult, !IO),
        ActualFileName = BaseName,
        GzipCmd = "gzip " ++ BaseName
    ;
        ActualFileName = FileName,
        GzipCmd = ""
    ),
    io__open_input(ActualFileName, Result, !IO),
    (
        Result = ok(FileStream),
        io__set_input_stream(FileStream, OldInputStream, !IO),
        io__read_line_as_string(IdReadResult, !IO),
        (
            IdReadResult = ok(FirstLine),
            string.rstrip(FirstLine) = trace_count_file_id
        ->
            promise_only_solution_io(read_trace_counts_from_cur_stream,
                ReadResult, !IO)
        ;
            ReadResult = syntax_error("no trace count file id")
        ),
        io__set_input_stream(OldInputStream, _, !IO),
        io__close_input(FileStream, !IO)
    ;
        Result = error(IOError),
        ReadResult = open_error(IOError)
    ),
    ( GzipCmd = "" ->
        true
    ;
        io__call_system(GzipCmd, _ZipResult, !IO)
    ).

:- func trace_count_file_id = string.

trace_count_file_id = "Mercury trace counts file".

:- pred read_trace_counts_from_cur_stream(read_trace_counts_result::out,
    io::di, io::uo) is cc_multi.

read_trace_counts_from_cur_stream(ReadResult, !IO) :-
    io__read_line_as_string(IdResult, !IO),
    (
        IdResult = ok(IdStr),
        IdStrNoNL = string.rstrip(IdStr),
        string_to_file_type(IdStrNoNL, FileType)
    ->
        try_io(read_trace_counts_setup(map__init), Result, !IO),
        (
            Result = succeeded(TraceCounts),
            ReadResult = ok(FileType, TraceCounts)
        ;
            Result = exception(Exception),
            ( Exception = univ(IOError) ->
                ReadResult = io_error(IOError)
            ; Exception = univ(Message) ->
                ReadResult = error_message(Message)
            ; Exception = univ(trace_count_syntax_error(Error)) ->
                ReadResult = syntax_error(Error)
            ;
                error("read_trace_counts_from_cur_stream: " ++
                    "unexpected exception type: " ++ string(Exception))
            )
        )
    ;
        ReadResult = syntax_error("no info on trace count file type")
    ).

:- pred read_trace_counts_setup(trace_counts::in, trace_counts::out,
    io::di, io::uo) is det.

read_trace_counts_setup(!TraceCounts, !IO) :-
    io__get_line_number(LineNumber, !IO),
    io__read_line_as_string(Result, !IO),
    (
        Result = ok(Line),
        CurFileName = "",
        read_proc_trace_counts(LineNumber, Line, CurFileName, !TraceCounts,
            !IO)
    ;
        Result = eof
    ;
        Result = error(Error),
        throw(Error)
    ).

:- type trace_count_syntax_error
    --->    trace_count_syntax_error(string).

:- pred read_proc_trace_counts(int::in, string::in, string::in,
    trace_counts::in, trace_counts::out, io::di, io::uo) is det.

read_proc_trace_counts(HeaderLineNumber, HeaderLine, CurFileName, !TraceCounts,
        !IO) :-
    lexer__string_get_token_list(HeaderLine, string__length(HeaderLine),
        TokenList, posn(HeaderLineNumber, 1, 0), _),
    (
        TokenList =
            token_cons(name("file"), _,
            token_cons(name(NextFileName), _,
            token_nil))
    ->
        io__read_line_as_string(Result, !IO),
        (
            Result = ok(Line),
            io__get_line_number(LineNumber, !IO),
            read_proc_trace_counts(LineNumber, Line, NextFileName,
                !TraceCounts, !IO)
        ;
            Result = eof
        ;
            Result = error(Error),
            throw(Error)
        )
    ;
        TokenList =
            token_cons(name("proc"), _,
            token_cons(name(DefModuleStr), _,
            token_cons(name(PredOrFuncStr), _,
            token_cons(name(DeclModuleStr), _,
            token_cons(name(Name), _,
            token_cons(integer(Arity), _,
            token_cons(integer(Mode), _,
            token_nil))))))),
        string_to_pred_or_func(PredOrFuncStr, PredOrFunc)
    ->
        string_to_sym_name(DefModuleStr, ".", DefModuleName),
        string_to_sym_name(DeclModuleStr, ".", DeclModuleName),
        % At the moment runtime/mercury_trace_base.c doesn't
        % write out data for unify, compare, index or init procedures.
        ProcLabel = proc(DefModuleName, PredOrFunc, DeclModuleName,
                Name, Arity, Mode),
        ProcLabelAndFile = proc_label_and_filename(ProcLabel, CurFileName),
        % For whatever reason some of the trace counts for a single
        % procedure or function can be split over multiple spans.
        % We collate them as if they appeared in a single span.
        ( svmap__remove(ProcLabelAndFile, ProbeCounts, !TraceCounts) ->
            StartCounts = ProbeCounts
        ;
            StartCounts = map__init
        ),
        read_proc_trace_counts_2(ProcLabelAndFile, StartCounts,
            !TraceCounts, !IO)
    ;
        string__format("parse error on line %d of execution trace",
            [i(HeaderLineNumber)], Message),
        throw(trace_count_syntax_error(Message))
    ).

:- pred read_proc_trace_counts_2(proc_label_and_filename::in,
    proc_trace_counts::in, trace_counts::in, trace_counts::out,
    io::di, io::uo) is det.

read_proc_trace_counts_2(ProcLabelAndFile, ProcCounts0, !TraceCounts, !IO) :-
    CurFileName = ProcLabelAndFile ^ filename,
    io__read_line_as_string(Result, !IO),
    (
        Result = ok(Line),
        ( 
            parse_path_port_line(Line, PathPort, LineNumber, ExecCount, 
                NumTests)
        ->
            LineNoAndCount = line_no_and_count(LineNumber, ExecCount, 
                NumTests),
            map__det_insert(ProcCounts0, PathPort, LineNoAndCount, ProcCounts),
            read_proc_trace_counts_2(ProcLabelAndFile, ProcCounts,
                !TraceCounts, !IO)
        ;
            svmap__det_insert(ProcLabelAndFile, ProcCounts0, !TraceCounts),
            io__get_line_number(LineNumber, !IO),
            read_proc_trace_counts(LineNumber, Line, CurFileName, !TraceCounts,
                !IO)
        )
    ;
        Result = eof,
        svmap__det_insert(ProcLabelAndFile, ProcCounts0, !TraceCounts)
    ;
        Result = error(Error),
        throw(Error)
    ).

:- pred parse_path_port_line(string::in, path_port::out, int::out, int::out,
    int::out) is semidet.

parse_path_port_line(Line, PathPort, LineNumber, ExecCount, NumTests) :-
    Words = string__words(Line),
    ( 
        (
            Words = [Word1, ExecCountStr, LineNumberStr],
            NumTestsStr = "1"
        ;
            Words = [Word1, ExecCountStr, NumTestsStr, LineNumberStr]
        ),
        ( string_to_trace_port(Word1, Port) ->
            PathPort0 = port_only(Port)
        ; Path = string_to_goal_path(Word1) ->
            PathPort0 = path_only(Path)
        ;
            fail
        ),
        string__to_int(ExecCountStr, ExecCount0),
        string__to_int(NumTestsStr, NumTests0),
        string__to_int(LineNumberStr, LineNumber0)
    ->
        PathPort = PathPort0,
        ExecCount = ExecCount0,
        NumTests = NumTests0,
        LineNumber = LineNumber0
    ;
        (
            Words = [PortStr, PathStr, ExecCountStr, LineNumberStr],
            NumTestsStr = "1"
        ;
            Words = [PortStr, PathStr, ExecCountStr, NumTestsStr,
                LineNumberStr]
        ),
        string_to_trace_port(PortStr, Port),
        Path = string_to_goal_path(PathStr),
        PathPort = port_and_path(Port, Path),
        string__to_int(ExecCountStr, ExecCount),
        string__to_int(NumTestsStr, NumTests),
        string__to_int(LineNumberStr, LineNumber)
    ).

:- pred string_to_pred_or_func(string, pred_or_func).
:- mode string_to_pred_or_func(in, out) is semidet.
:- mode string_to_pred_or_func(out, in) is det.

string_to_pred_or_func("p", predicate).
string_to_pred_or_func("f", function).

string_to_trace_port("CALL", call).
string_to_trace_port("EXIT", exit).
string_to_trace_port("REDO", redo).
string_to_trace_port("FAIL", fail).
string_to_trace_port("EXCP", exception).
string_to_trace_port("COND", ite_cond).
string_to_trace_port("THEN", ite_then).
string_to_trace_port("ELSE", ite_else).
string_to_trace_port("NEGE", neg_enter).
string_to_trace_port("NEGS", neg_success).
string_to_trace_port("NEGF", neg_failure).
string_to_trace_port("DISJ", disj).
string_to_trace_port("SWTC", switch).
string_to_trace_port("FRST", nondet_pragma_first).
string_to_trace_port("LATR", nondet_pragma_later).

:- func string_to_goal_path(string) = goal_path is semidet.

string_to_goal_path(String) = Path :-
    string__prefix(String, "<"),
    string__suffix(String, ">"),
    string__length(String, Length),
    string__substring(String, 1, Length-2, SubString),
    path_from_string(SubString, Path).

    % This function should be kept in sync with the MR_named_count_port array
    % in runtime/mercury_trace_base.c.
    %
make_path_port(_GoalPath, call) = port_only(call).
make_path_port(_GoalPath, exit) = port_only(exit).
make_path_port(_GoalPath, redo) = port_only(redo).
make_path_port(_GoalPath, fail) = port_only(fail).
make_path_port(_GoalPath, exception) = port_only(exception).
make_path_port(GoalPath, ite_cond) = path_only(GoalPath).
make_path_port(GoalPath, ite_then) = path_only(GoalPath).
make_path_port(GoalPath, ite_else) = path_only(GoalPath).
make_path_port(GoalPath, neg_enter) = port_and_path(neg_enter, GoalPath).
make_path_port(GoalPath, neg_success) = port_and_path(neg_success, GoalPath).
make_path_port(GoalPath, neg_failure) = port_and_path(neg_failure, GoalPath).
make_path_port(GoalPath, disj) = path_only(GoalPath).
make_path_port(GoalPath, switch) = path_only(GoalPath).
make_path_port(GoalPath, nondet_pragma_first) = path_only(GoalPath).
make_path_port(GoalPath, nondet_pragma_later) = path_only(GoalPath).

%-----------------------------------------------------------------------------%

write_trace_counts_to_file(FileType, TraceCounts, FileName, Res, !IO) :-
    io__open_output(FileName, Result, !IO),
    (
        Result = ok(FileStream),
        Res = ok,
        io.set_output_stream(FileStream, OldOutputStream, !IO),
        io.write_string(trace_count_file_id, !IO),
        io.nl(!IO),
        write_trace_counts(FileType, TraceCounts, !IO),
        io.set_output_stream(OldOutputStream, _, !IO),
        io.close_output(FileStream, !IO)
    ;
        Result = error(Error),
        Res = error(Error)
    ).

:- pred write_trace_counts(trace_count_file_type::in, trace_counts::in, 
    io::di, io::uo) is det.

write_trace_counts(FileType, TraceCounts, !IO) :-
    FileTypeStr = file_type_to_string(FileType),
    io.write_string(FileTypeStr ++ "\n", !IO),
    map.foldl(write_proc_label_and_file_trace_counts, TraceCounts, !IO).

:- pred write_proc_label_and_file_trace_counts(proc_label_and_filename::in, 
    proc_trace_counts::in, io::di, io::uo) is det.

write_proc_label_and_file_trace_counts(ProcLabelAndFileName, PathPortCounts, 
        !IO) :-
    ProcLabelAndFileName = proc_label_and_filename(ProcLabel, FileName),
    io.write_strings(["file '", FileName, "'\n"], !IO),
    write_proc_label(ProcLabel, !IO),
    map.foldl(write_path_port_count, PathPortCounts, !IO).

:- pred write_proc_label(proc_label::in, io::di, io::uo) is det.

write_proc_label(proc(DefModuleSym, PredOrFunc, DeclModuleSym, Name, Arity,
        Mode), !IO) :-
    sym_name_to_string(DefModuleSym, DefModuleStr),
    sym_name_to_string(DeclModuleSym, DeclModuleStr),
    string_to_pred_or_func(PredOrFuncStr, PredOrFunc),
    io.write_string("proc ", !IO),
    term_io.quote_atom(DefModuleStr, !IO),
    io.write_string(" ", !IO),
    io.write_string(PredOrFuncStr, !IO),
    io.write_string(" ", !IO),
    term_io.quote_atom(DeclModuleStr, !IO),
    io.write_string(" ", !IO),
    term_io.quote_atom(Name, !IO),
    io.write_string(" ", !IO),
    io.write_int(Arity, !IO),
    io.write_string(" ", !IO),
    io.write_int(Mode, !IO),
    io.nl(!IO).

    % We don't record special preds in trace counts.
write_proc_label(special_proc(_, _, _, _, _, _), !IO) :-
    error("write_proc_label: special_pred").

:- pred write_path_port_count(path_port::in, line_no_and_count::in, 
    io::di, io::uo) is det.

write_path_port_count(port_only(Port), line_no_and_count(LineNo, 
        ExecCount, NumTests), !IO) :-
    string_to_trace_port(PortStr, Port),
    io.write_strings([
        PortStr, " ", 
        int_to_string(ExecCount), " ", 
        int_to_string(NumTests), " ", 
        int_to_string(LineNo), "\n"], !IO).
write_path_port_count(path_only(Path), line_no_and_count(LineNo, ExecCount,
        NumTests), !IO) :-
    string_from_path(Path, PathStr),
    io.write_strings([
        "<", PathStr, "> ", 
        int_to_string(ExecCount), " ", 
        int_to_string(NumTests), " ", 
        int_to_string(LineNo), 
        "\n"], !IO).
write_path_port_count(port_and_path(Port, Path), 
        line_no_and_count(LineNo, ExecCount, NumTests), !IO) :-
    string_to_trace_port(PortStr, Port),
    string_from_path(Path, PathStr),
    io.write_strings([
        PortStr, " <", PathStr, "> ", 
        int_to_string(ExecCount), " ", 
        int_to_string(NumTests), " ", 
        int_to_string(LineNo), "\n"], !IO).

%-----------------------------------------------------------------------------%

:- func file_type_to_string(trace_count_file_type) = string.

file_type_to_string(user_all) = "user_all".
file_type_to_string(user_nonzero) = "user_nonzero".
file_type_to_string(union(N)) = "union " ++ int_to_string(N).

:- pred string_to_file_type(string::in, trace_count_file_type::out) is semidet.

string_to_file_type(Str, FileType) :-
    ( string.append("union ", NumTestsStr, Str) ->
        string.to_int(NumTestsStr, NumTests),
        FileType = union(NumTests)
    ;
        Str = "user_all",
        FileType = user_all
    ;
        Str = "user_nonzero",
        FileType = user_nonzero
    ).

%-----------------------------------------------------------------------------%

restrict_trace_counts_to_module(ModuleName, TraceCounts0, TraceCounts) :-
    map__foldl(restrict_trace_counts_2(ModuleName), TraceCounts0,
        map__init, TraceCounts).
    
:- pred restrict_trace_counts_2(module_name::in, proc_label_and_filename::in, 
    proc_trace_counts::in, trace_counts::in, trace_counts::out) is det.

restrict_trace_counts_2(ModuleName, ProcLabelAndFile, ProcCounts, Acc0, Acc) :-
    ProcLabel = ProcLabelAndFile ^ proc_label,
    (if ProcLabel = proc(ModuleName, _, _, _, _, _) then
        map__det_insert(Acc0, ProcLabelAndFile, ProcCounts, Acc)
    else
        Acc = Acc0
    ).

%-----------------------------------------------------------------------------%

calc_num_tests([]) = 0.
calc_num_tests([FileType | Rest]) = 
    num_tests_for_file_type(FileType) + calc_num_tests(Rest).

num_tests_for_file_type(union(N)) = N.
num_tests_for_file_type(user_nonzero) = 1.
num_tests_for_file_type(user_all) = 1.
